<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Search Result</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- Font Awesome -->
    <!-- <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"> -->

    <!-- Web Font 추가 -->
    <!-- <link rel="preconnect" href="https://fonts.gstatic.com">
	<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300&display=swap" rel="stylesheet"> -->

    <!-- syntax.css 추가 -->
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="The only limit is your mind." />
    <link rel="shortcut icon" href="https://jjaemin0224.github.io/assets/images/blog/favicon.png" type="image/png" />
    <link rel="canonical" href="https://jjaemin0224.github.io/search" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="Jaemin's BLOG" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Search Result" />
    <meta property="og:description" content="The only limit is your mind." />
    <meta property="og:url" content="https://jjaemin0224.github.io/search" />
    <meta property="og:image" content="https://jjaemin0224.github.io/assets/images/blog/backgroud.jpg" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Search Result" />
    <meta name="twitter:description" content="The only limit is your mind." />
    <meta name="twitter:url" content="https://jjaemin0224.github.io/" />
    <meta name="twitter:image" content="https://jjaemin0224.github.io/assets/images/blog/backgroud.jpg" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="Jaemin's BLOG" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "Jaemin's BLOG",
        "logo": "https://jjaemin0224.github.io/"
    },
    "url": "https://jjaemin0224.github.io/search",
    "image": {
        "@type": "ImageObject",
        "url": "https://jjaemin0224.github.io/assets/images/blog/backgroud.jpg",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://jjaemin0224.github.io/search"
    },
    "description": "The only limit is your mind."
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Search Result" href="/feed.xml" />


</head>
<body class="page-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://jjaemin0224.github.io/">Jaemin's BLOG</a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem">
        <a href="/">Home</a>
    </li>
    <li class="nav-about" role="menuitem">
        <a href="/about/">About</a>
    </li>
    <!-- <li class="nav-knowledge" role="menuitem">
        <a href="/tag/knowledge/">Knowledge</a>
    </li> -->
    <li class="nav-archive" role="menuitem">
        <a href="/archive.html">All Posts</a>
    </li>
    <li class="nav-archive" role="menuitem">
        <a href="/author_archive.html">Tag Posts</a>
    </li>
</ul>

        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Search Result</h1>
            </header>

            

            <section class="post-full-content">
                <form action="/search" method="get" hidden="hidden">
    <label for="search-box"></label>
    <input type="text" id="search-box" name="query">
</form>

<ul class="mylist" id="search-results"></ul>

<script>
    window.store = {
    
    "b14215": {
        "title": "[백준] 14215번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "세 막대문제영선이는 길이가 a, b, c인 세 막대를 가지고 있고, 각 막대의 길이를 마음대로 줄일 수 있다.영선이는 세 막대를 이용해서 아래 조건을 만족하는 삼각형을 만들려고 한다.      각 막대의 길이는 양의 정수이다    세 막대를 이용해서 넓이가 양수인 삼각형을 만들 수 있어야 한다.    삼각형의 둘레를 최대로 해야 한다.  a, b, c가 주어졌을 때, 만들 수 있는 가장 큰 둘레를 구하는 프로그램을 작성하시오.입력첫째 줄에 a, b, c (1 ≤ a, b, c ≤ 100)가 주어진다.출력첫째 줄에 만들 수 있는 가장 큰 삼각형의 둘레를 출력한다.예제 입력 11 2 3예제 출력 15예제 입력 22 2 2예제 출력 26풀이1import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.List;import java.util.Scanner;public class Main {\t\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\tList&lt;Integer&gt; stickList = new ArrayList&lt;&gt;(Arrays.asList(sc.nextInt(), sc.nextInt(), sc.nextInt()));\t\tCollections.sort(stickList);\t\tList&lt;Integer&gt; triangle = getTriangle(stickList);\t\t\t\tint round = 0;\t\tfor (int i : triangle) round += i;\t\tSystem.out.println(round);\t\t\t}\tprivate static List&lt;Integer&gt; getTriangle(List&lt;Integer&gt; stickList) {\t\tif ((stickList.get(0) + stickList.get(1)) &gt; stickList.get(2)) {\t\t\treturn stickList;\t\t}\t\telse {\t\t\tstickList.set(2, (stickList.get(0) + stickList.get(1)) - 1);\t\t\treturn stickList;\t\t}\t}}",
        "url": "/b14215"
    }
    ,
    
    "b5073": {
        "title": "[백준] 5073번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "삼각형과 세 변문제삼각형의 세 변의 길이가 주어질 때 변의 길이에 따라 다음과 같이 정의한다.      Equilateral :  세 변의 길이가 모두 같은 경우    Isosceles : 두 변의 길이만 같은 경우    Scalene : 세 변의 길이가 모두 다른 경우  단 주어진 세 변의 길이가 삼각형의 조건을 만족하지 못하는 경우에는 “Invalid” 를 출력한다. 예를 들어 6, 3, 2가 이 경우에 해당한다. 가장 긴 변의 길이보다 나머지 두 변의 길이의 합이 길지 않으면 삼각형의 조건을 만족하지 못한다.세 변의 길이가 주어질 때 위 정의에 따른 결과를 출력하시오.입력각 줄에는 1,000을 넘지 않는 양의 정수 3개가 입력된다. 마지막 줄은 0 0 0이며 이 줄은 계산하지 않는다.출력각 입력에 맞는 결과 (Equilateral, Isosceles, Scalene, Invalid) 를 출력하시오.예제 입력 17 7 76 5 43 2 56 2 60 0 0예제 출력 1EquilateralScaleneInvalidIsosceles풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.StringTokenizer;public class Main {\t\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tStringTokenizer st;\t\t\t\twhile(true) {\t\t\tst = new StringTokenizer(br.readLine(), \" \");\t\t\tList&lt;Integer&gt; triangle = new ArrayList&lt;&gt;();\t\t\ttriangle.add(Integer.parseInt(st.nextToken()));\t\t\ttriangle.add(Integer.parseInt(st.nextToken()));\t\t\ttriangle.add(Integer.parseInt(st.nextToken()));\t\t\t\t\t\tif (Collections.frequency(triangle, 0) == 3) break;\t\t\telse Collections.sort(triangle);\t\t\t\t\t\tSystem.out.println(classifyTriangle(triangle));\t\t}\t\t\t}\tprivate static String classifyTriangle(List&lt;Integer&gt; triangle) {\t\t\t\tif (Collections.frequency(triangle, triangle.get(0)) == 3) {\t\t\treturn \"Equilateral\";\t\t}\t\telse if ((triangle.get(0) + triangle.get(1)) &gt; triangle.get(2)) {\t\t\tif (Collections.frequency(triangle, triangle.get(0)) == 2 || Collections.frequency(triangle, triangle.get(1)) == 2) {\t\t\t\treturn \"Isosceles\";\t\t\t}\t\t\telse {\t\t\t\treturn \"Scalene\";\t\t\t}\t\t}\t\telse {\t\t\treturn \"Invalid\";\t\t}\t}}",
        "url": "/b5073"
    }
    ,
    
    "b10101": {
        "title": "[백준] 10101번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "삼각형 외우기문제창영이는 삼각형의 종류를 잘 구분하지 못한다. 따라서 프로그램을 이용해 이를 외우려고 한다.삼각형의 세 각을 입력받은 다음,      세 각의 크기가 모두 60이면, Equilateral    세 각의 합이 180이고, 두 각이 같은 경우에는 Isosceles    세 각의 합이 180이고, 같은 각이 없는 경우에는 Scalene    세 각의 합이 180이 아닌 경우에는 Error를 출력하는 프로그램을 작성하시오.  입력총 3개의 줄에 걸쳐 삼각형의 각의 크기가 주어진다. 모든 정수는 0보다 크고, 180보다 작다.출력문제의 설명에 따라 Equilateral, Isosceles, Scalene, Error 중 하나를 출력한다.예제 입력 1607050예제 출력 1Scalene풀이1import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.List;import java.util.Scanner;public class Main {\t\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\tList&lt;Integer&gt; triangle = new ArrayList&lt;&gt;(Arrays.asList(sc.nextInt(), sc.nextInt(), sc.nextInt()));\t\tSystem.out.println(classifyTriangle(triangle));\t\t\t}\tprivate static String classifyTriangle(List&lt;Integer&gt; triangle) {\t\tint sum = 0;\t\tfor (int angle : triangle) sum += angle;\t\t\t\tif (sum == 180) {\t\t\tif (Collections.frequency(triangle, 60) == 3) {\t\t\t\treturn \"Equilateral\";\t\t\t}\t\t\telse if (Collections.frequency(triangle, triangle.get(0)) == 2 || Collections.frequency(triangle, triangle.get(1)) == 2) {\t\t\t\treturn \"Isosceles\";\t\t\t}\t\t\telse {\t\t\t\treturn \"Scalene\";\t\t\t}\t\t}\t\telse {\t\t\treturn \"Error\";\t\t}\t}}",
        "url": "/b10101"
    }
    ,
    
    "b9063": {
        "title": "[백준] 9063번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "대지문제임씨는 1950 년 한국전쟁으로 많은 손해를 본 사람들 중 하나다. 전쟁 통에 손해보지 않은 사람이 어디 있을까 만은 그는 6.25 가 일어나기 전만 해도 충청도 지방에 넓은 대지를 소유한 큰 부자였다. 전쟁이 나자 임씨는 땅문서와 값 나가는 것들만 챙겨서 일본으로 피난을 가지만 피난 중에 그만 땅문서를 잃어버리고 만다. 전쟁이 끝난 후에 임씨의 땅은 이미 다른 사람들의 논밭이 되어 있었고, 임씨는 땅을 되찾으려 했지만 문서가 없으니 생떼 쓰는 것과 다를 바 없었다. 이러다가 임씨는 길바닥에 나앉게 생겼다.이때, 임씨에게 좋은 생각이 떠올랐으니 바로 자신이 습관처럼 땅 깊숙이 뭔가 표식을 해놓았던 사실이다. 임씨는 한적할 때마다 자신의 논밭을 거닐다가 땅속 깊은 곳에 자신의 이름이 씌어진 옥구슬을 묻어놓았던 것이다. 즉, 어떤 지점에서 그의 이름이 적힌 옥구슬이 나온다면 그 지점은 예전에 임씨의 땅이었다는 것을 증명하는 것이다.임씨는 즉시 민사소송을 통해 자신의 땅을 찾고자 했고 논리적인 근거를 들어 옥구슬이 나오는 지점이 원래 자신의 땅의 한 지점이었다는 것을 주장하여 결국 담당판사를 설득하는 데에 성공하였다. 담당판사는 다음과 같은 판결을 내렸다. “ 6.25 이전의 개인소유 대지들은 99%가 남북, 동서 방향으로 평행한 직사각형 모양이었으므로, 임씨의 이름이 새겨진 옥구슬이 나오는 모든 지점을 포함하는 가장 작은 남북, 동서 방향으로 평행한 변을 갖는 직사각형의 대지를 임씨의 소유로 인정한다.” 임씨는 많은 손해를 보는 셈이지만 더 이상을 요구할 만한 근거가 없었기 때문에 이 판결을 따르기로 했다.임씨의 이름이 새겨진 옥구슬의 위치 N 개가 주어질 때에, 임씨에게 돌아갈 대지의 넓이를 계산하는 프로그램을 작성하시오. 단, 옥구슬의 위치는 2 차원 정수 좌표로 주어지고 옥구슬은 같은 위치에 여러 개가 발견될 수도 있으며, x 축의 양의방향을 동쪽, y 축의 양의방향을 북쪽이라고 가정한다.예를 들어 위와 같이 (2, 1), (3, 2), (5, 2), (3, 4) 네 점에서 옥구슬을 발견하였다면, 임씨에게 돌아갈 대지는 (2, 1), (5, 1), (2, 4), (5, 4)를 네 꼭짓점으로 하는 직사각형이며, 넓이는 (5 - 2) × (4 - 1) = 9 가 된다.입력첫째 줄에는 점의 개수 N (1 ≤ N ≤ 100,000) 이 주어진다. 이어지는 N 줄에는 각 점의 좌표가 두 개의 정수로 한 줄에 하나씩 주어진다. 각각의 좌표는 -10,000 이상 10,000 이하의 정수이다.출력첫째 줄에 N 개의 점을 둘러싸는 최소 크기의 직사각형의 넓이를 출력하시오.예제 입력 1320 2440 2110 12예제 출력 1360예제 입력 2115 13예제 출력 20예제 입력 342 13 25 23 4예제 출력 39풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.StringTokenizer;public class Main {\tpublic static void main(String[] args) throws NumberFormatException, IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tStringTokenizer st;\t\t\t\tList&lt;Integer&gt; xList = new ArrayList&lt;&gt;();\t\tList&lt;Integer&gt; yList = new ArrayList&lt;&gt;();\t\tint n = Integer.parseInt(br.readLine());\t\t\t\tfor (int i = 0; i &lt; n; i++) {\t\t\tst = new StringTokenizer(br.readLine(), \" \");\t\t\txList.add(Integer.parseInt(st.nextToken()));\t\t\tyList.add(Integer.parseInt(st.nextToken()));\t\t}\t\t\t\tint x = Collections.max(xList) - Collections.min(xList); \t\tint y = Collections.max(yList) - Collections.min(yList);\t\tSystem.out.println(x * y);\t\t\t}\t}",
        "url": "/b9063"
    }
    ,
    
    "b3009": {
        "title": "[백준] 3009번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "직사각형에서 탈출문제세 점이 주어졌을 때, 축에 평행한 직사각형을 만들기 위해서 필요한 네 번째 점을 찾는 프로그램을 작성하시오.입력세 점의 좌표가 한 줄에 하나씩 주어진다. 좌표는 1보다 크거나 같고, 1000보다 작거나 같은 정수이다.출력직사각형의 네 번째 점의 좌표를 출력한다.예제 입력 15 55 77 5예제 출력 17 7예제 입력 230 2010 1010 20예제 출력 230 10풀이1import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.StringTokenizer;public class Main {\t\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tBufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\t\tStringTokenizer st;\t\tList&lt;Integer&gt; xList = new ArrayList&lt;&gt;();\t\tList&lt;Integer&gt; yList = new ArrayList&lt;&gt;();\t\t\t\tfor (int i = 0; i &lt; 3; i++) {\t\t\tst = new StringTokenizer(br.readLine(), \" \");\t\t\txList.add(Integer.parseInt(st.nextToken()));\t\t\tyList.add(Integer.parseInt(st.nextToken()));\t\t}\t\t\t\tfor (int i = 0; i &lt; 3; i++) {\t\t\tif (Collections.frequency(xList, xList.get(i)) == 1) xList.add(xList.get(i));\t\t\tif (Collections.frequency(yList, yList.get(i)) == 1) yList.add(yList.get(i));\t\t}\t\t\t\tbw.write(xList.get(3) + \" \" + yList.get(3));\t\tbw.flush();\t\tbw.close();\t\t\t}}",
        "url": "/b3009"
    }
    ,
    
    "b15894": {
        "title": "[백준] 15894번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "수학은 체육과목입니다.문제성원이는 수학을 정말 못 하는 고등학생이다. 수학을 못하는 대신 근성과 팔 힘이 뛰어난 성원이는 수학 시험에서 수학 지식을 사용하지 않고 근성과 체력을 사용해 문제를 푼다. 지난 시험에서는 아래 사진에 나와있는 문제를 근성과 체력을 사용해 열심히 풀었지만 사진에서 볼 수 있듯이 틀려버리고 말았다!결국 이 문제는 틀려버렸지만 성원이는 여전히 자신의 체력에 강한 자신감을 갖고 있다. 어떤 어려운 문제가 나와도 이런 식으로 근성과 체력을 사용하면 다 풀 수 있으니 이 방법은 최고의 방법이라고 생각하고 있다.성원이의 친구 형석이는 근성과 체력으로 수학 문제를 푸는 것은 굉장히 무식한 방법이라고 생각한다. 형석이는 수학을 공부하면 문제를 훨씬 빨리 풀 수 있다는 것을 알려주기 위해 위 사진에 나와있는 문제를 갖고 성원이와 퀴즈 내기를 하기로 했다. 위 사진의 문제를 다시 정리하면 아래와 같다.  “한 변의 길이가 1인 정사각형을 아래 그림과 같이 겹치지 않게 빈틈없이 계속 붙여 나간다. 가장 아랫부분의 정사각형이 n개가 되었을 때, 실선으로 이루어진 도형의 둘레의 길이를 구하시오.”가장 아랫부분의 정사각형 개수가 주어지면 그에 해당하는 답을 출력하는 프로그램을 만들어 형석이를 도와주자!입력첫 번째 줄에 가장 아랫부분의 정사각형 개수 n이 주어진다. (1 ≤ n ≤ 10의 9승)출력첫 번째 줄에 형석이가 말해야 하는 답을 출력한다.예제 입력 11예제 출력 14예제 입력 23예제 출력 212풀이1import java.math.BigDecimal;import java.util.Scanner;public class Main {\t\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\tBigDecimal answer = new BigDecimal(sc.nextInt());\t\tBigDecimal four = new BigDecimal(4);\t\tsc.close();\t\tSystem.out.println(answer.multiply(four));\t\t\t}}",
        "url": "/b15894"
    }
    ,
    
    "b1085": {
        "title": "[백준] 1085번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "직사각형에서 탈출문제한수는 지금 (x, y)에 있다. 직사각형은 각 변이 좌표축에 평행하고, 왼쪽 아래 꼭짓점은 (0, 0), 오른쪽 위 꼭짓점은 (w, h)에 있다. 직사각형의 경계선까지 가는 거리의 최솟값을 구하는 프로그램을 작성하시오.입력첫째 줄에 x, y, w, h가 주어진다.출력첫째 줄에 문제의 정답을 출력한다.제한  1 ≤ w, h ≤ 1,000  1 ≤ x ≤ w-1  1 ≤ y ≤ h-1  x, y, w, h는 정수예제 입력 16 2 10 3예제 출력 11예제 입력 21 1 5 5예제 출력 21예제 입력 3653 375 1000 1000예제 출력 3347풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main {\t\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tStringTokenizer st = new StringTokenizer(br.readLine(), \" \");\t\t\t\tint x = Integer.parseInt(st.nextToken());\t\tint y = Integer.parseInt(st.nextToken());\t\tint w = Integer.parseInt(st.nextToken());\t\tint h = Integer.parseInt(st.nextToken());\t\t\t\tint answer = 1000;\t\tint[] arr = {w - x, h - y, x, y};\t\tfor(int i : arr) answer = Math.min(i, answer);\t\t\t\tSystem.out.println(answer);\t\t\t}}",
        "url": "/b1085"
    }
    ,
    
    "b27323": {
        "title": "[백준] 27323번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "직사각형문제정수 A, B 가 주어진다. 세로 길이가 A cm, 가로 길이가 B cm 인 직사각형의 넓이를 cm2 단위로 구하시오.입력표준 입력에 다음과 같은 형태로 입력이 주어진다.AB출력세로 길이가 A cm, 가로 길이가 B cm인 직사각형의 넓이를 cm2 단위로 구하고, 단위 (cm2)를 생략하여 출력한다.예제 입력 123예제 출력 16풀이1import java.util.Scanner;public class Main {\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\tint A = sc.nextInt();\t\tint B = sc.nextInt();\t\tsc.close();\t\tSystem.out.println(A * B);\t\t\t}\t}",
        "url": "/b27323"
    }
    ,
    
    "queue": {
        "title": "[자바] Queue",
            "author": "jjaemin0224",
            "category": "",
            "content": "1. Queue자바에서 Queue는 자료 구조의 한 종류로, 선입선출(FIFO, First-In-First-Out) 원칙을 따르는 컬렉션입니다. 큐는 요소들을 순서대로 저장하고, 새로운 요소는 큐의 끝에 추가되며, 요소들은 큐의 앞에서 제거됩니다.자바에서 Queue 인터페이스는 java.util 패키지에 정의되어 있으며, 다양한 구현체들이 제공됩니다. Queue 인터페이스는 다음과 같은 주요 메서드를 포함하고 있습니다:  boolean add(E element): 큐의 끝에 요소를 추가합니다. 큐에 공간이 부족한 경우 예외를 발생시킵니다.  boolean offer(E element): 큐의 끝에 요소를 추가합니다. 큐에 공간이 부족한 경우 false를 반환합니다.  E remove(): 큐의 앞에서 요소를 제거하고 반환합니다. 큐가 비어있는 경우 예외를 발생시킵니다.  E poll(): 큐의 앞에서 요소를 제거하고 반환합니다. 큐가 비어있는 경우 null을 반환합니다.  E element(): 큐의 앞에 있는 요소를 반환합니다. 큐가 비어있는 경우 예외를 발생시킵니다.  E peek(): 큐의 앞에 있는 요소를 반환합니다. 큐가 비어있는 경우 null을 반환합니다.일반적으로 LinkedList나 ArrayDeque 등이 Queue 인터페이스를 구현한 클래스로 사용됩니다. Queue는 대기열 관리, 이벤트 처리, 작업 스케줄링 등 다양한 상황에서 유용하게 활용될 수 있습니다.2. Queue 활용Queue는 다양한 상황에서 사용될 수 있습니다. 몇 가지 대표적인 Queue 사용 예시를 살펴보겠습니다      대기열 관리: Queue는 대기열을 관리하는 데 사용될 수 있습니다. 예를 들어, 고객 서비스 대기열, 작업 큐 등에서 사용됩니다. 새로운 요청이 도착하면 큐에 추가되고, 처리할 준비가 된 요소는 큐에서 제거되어 처리됩니다.        이벤트 처리: 이벤트 기반 시스템에서는 이벤트가 발생한 순서대로 처리해야 할 때 Queue가 유용합니다. 이벤트가 발생하면 해당 이벤트를 큐에 추가하고, 이벤트 처리기가 큐에서 이벤트를 하나씩 가져와 처리합니다.        멀티스레드 환경: 큐는 멀티스레드 환경에서 작업을 조율하는 데 사용될 수 있습니다. 한 스레드에서 작업을 생성하고 큐에 추가하면, 다른 스레드에서는 큐에서 작업을 가져와 처리할 수 있습니다. 이를 통해 스레드 간의 작업 분배와 동기화를 쉽게 구현할 수 있습니다.        네트워크 통신: 네트워크 프로그래밍에서는 요청을 받아들이고 처리하기 위해 큐를 사용할 수 있습니다. 클라이언트 요청을 큐에 추가하고, 서버에서는 큐에서 요청을 가져와 처리합니다. 이를 통해 요청의 동시 처리와 순서 보장을 할 수 있습니다.  이 외에도 데이터 버퍼링, 탐색 알고리즘 등 다양한 상황에서 Queue를 활용할 수 있습니다. 실제로는 Queue 인터페이스를 구현한 클래스 중 하나를 선택하여 해당 상황에 맞게 활용하게 됩니다.3. Queue 예시코드import java.util.LinkedList;import java.util.Queue;public class Main {    public static void main(String[] args) {        Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();        // 요소 추가        queue.offer(\"A\");        queue.offer(\"B\");        queue.offer(\"C\");        // 큐의 첫 번째 요소 확인        String firstElement = queue.peek();        System.out.println(\"첫 번째 요소: \" + firstElement);        // 큐의 첫 번째 요소 제고        String removeElement = queue.poll();        System.out.println(\"제거된 요소: \" + removeElement);        // 큐의 크기 확인        int size = queue.size();        System.out.println(\"큐의 크기: \" + size);        // 큐가 비어있는지 확인        boolean isEmpty = queue.isEmpty();        System.out.println(\"큐가 비어있는가? \" + isEmpty);    }}실행결과첫 번째 요소: A제거된 요소: A큐의 크기: 2큐가 비어있는가? false  offer(element): 큐의 끝에 요소를 추가합니다.  peek(): 큐의 첫 번째 요소를 확인합니다. 큐가 비어있을 경우 null을 반환합니다.  poll(): 큐의 첫 번째 요소를 제거하고 반환합니다. 큐가 비어있을 경우 null을 반환합니다.  size(): 큐의 크기를 반환합니다.  isEmpty(): 큐가 비어있는지 여부를 확인합니다.4. Queue 장점      데이터의 순서를 보장  Queue는 데이터를 순서대로 저장하고 처리하는 자료구조입니다. 데이터가 들어온 순서대로 처리해야 하는 경우, Queue를 사용하여 순서를 보장할 수 있습니다.        대기열 관리  Queue는 대기열을 관리하는 데에 적합합니다. 작업이 도착한 순서대로 처리해야 하는 상황에서 Queue를 사용하면, 작업을 대기열에 추가하고 순차적으로 처리할 수 있습니다. 예를 들어, 작업 큐나 이벤트 큐 등을 구현할 때 Queue를 활용합니다.        비동기 처리  Queue는 비동기적인 작업 처리에 유용합니다. 비동기 작업을 수행할 때, 작업을 Queue에 추가하고 다른 작업을 계속 처리할 수 있습니다. Queue에서 작업을 꺼내어 처리하는 동안 다른 작업이 도착하면 대기열에 추가됩니다. 이를 통해 비동기적인 작업 흐름을 관리하고 조절할 수 있습니다.        자원 공유와 동기화  Queue는 다중 스레드 환경에서의 자원 공유와 동기화에 사용될 수 있습니다. 여러 스레드가 공유 자원에 접근해야 할 때, Queue를 사용하여 스레드 간 작업을 조율하고 동기화할 수 있습니다. 스레드 간의 작업 순서를 보장하고 상호간의 안전한 통신을 위해 Queue를 활용합니다.        알고리즘 및 데이터 구조 구현  Queue는 다양한 알고리즘과 데이터 구조를 구현하는 데에 사용됩니다. 예를 들어, 너비 우선 탐색(BFS) 알고리즘, 캐시 구현, 버퍼 관리, 라운드 로빈 스케줄링 등에서 Queue를 활용합니다.  Queue는 위와 같은 이유로 다양한 상황에서 사용되며, 데이터의 순서를 관리하고 작업을 조율하는 데에 유용한 자료구조입니다.",
        "url": "/queue"
    }
    ,
    
    "b2581": {
        "title": "[백준] 2581번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "소수문제자연수 M과 N이 주어질 때 M이상 N이하의 자연수 중 소수인 것을 모두 골라 이들 소수의 합과 최솟값을 찾는 프로그램을 작성하시오.예를 들어 M=60, N=100인 경우 60이상 100이하의 자연수 중 소수는 61, 67, 71, 73, 79, 83, 89, 97 총 8개가 있으므로, 이들 소수의 합은 620이고, 최솟값은 61이 된다.입력입력의 첫째 줄에 M이, 둘째 줄에 N이 주어진다.M과 N은 10,000이하의 자연수이며, M은 N보다 작거나 같다.출력M이상 N이하의 자연수 중 소수인 것을 모두 찾아 첫째 줄에 그 합을, 둘째 줄에 그 중 최솟값을 출력한다.단, M이상 N이하의 자연수 중 소수가 없을 경우는 첫째 줄에 -1을 출력한다.예제 입력 160100예제 출력 162061예제 입력 26465예제 출력 2-1풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main {\t\tpublic static void main(String[] args) throws NumberFormatException, IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint N = Integer.parseInt(br.readLine());\t\tStringTokenizer st = new StringTokenizer(br.readLine(), \" \");\t\t\t\tint[] primeNumArr = new int[N];\t\tint primeNumCount = 0;\t\t\t\tfor (int i = 0; i &lt; primeNumArr.length; i++) {\t\t\tprimeNumArr[i] = Integer.parseInt(st.nextToken());\t\t\tif (isPrimeNum(primeNumArr[i])) {\t\t\t\tprimeNumCount++;\t\t\t}\t\t}\t\t\t\tSystem.out.println(primeNumCount);\t\t\t}\tprivate static boolean isPrimeNum(int num) {\t\tint factorCount = 0;\t\tfor (int i = 1; i &lt;= num/2; i++) {\t\t\tif (num % i == 0) {\t\t\t\tfactorCount++;\t\t\t}\t\t}\t\tif (factorCount == 1) return true;\t\telse return false;\t}}import java.util.ArrayList;import java.util.List;import java.util.Scanner;public class Main {\t\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\tint M = sc.nextInt();\t\tint N = sc.nextInt();\t\tsc.close();\t\t\t\tList&lt;Integer&gt; primeNumList = new ArrayList&lt;&gt;();\t\t\t\tfor (int i = M; i &lt;= N; i++) {\t\t\tif (isPrimeNum(i)) {\t\t\t\tprimeNumList.add(i);\t\t\t}\t\t}\t\t\t\tint sum = 0;\t\tfor(int num : primeNumList) {\t\t\tsum += num;\t\t}\t\t\t\tif (primeNumList.size() == 0) {\t\t\tSystem.out.println(-1);\t\t}\t\telse {\t\t\tSystem.out.println(sum);\t\t\tSystem.out.println(primeNumList.get(0));\t\t}\t\t\t}\tprivate static boolean isPrimeNum(int num) {\t\tint factorCount = 0;\t\tfor (int i = 1; i &lt;= num/2; i++) {\t\t\tif (num % i == 0) {\t\t\t\tfactorCount++;\t\t\t}\t\t}\t\tif (factorCount == 1) return true;\t\telse return false;\t}}",
        "url": "/b2581"
    }
    ,
    
    "b1978": {
        "title": "[백준] 1978번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "소수찾기문제주어진 수 N개 중에서 소수가 몇 개인지 찾아서 출력하는 프로그램을 작성하시오.입력첫 줄에 수의 개수 N이 주어진다. N은 100이하이다. 다음으로 N개의 수가 주어지는데 수는 1,000 이하의 자연수이다.출력주어진 수들 중 소수의 개수를 출력한다.예제 입력 141 3 5 7예제 출력 13풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main {\t\tpublic static void main(String[] args) throws NumberFormatException, IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint N = Integer.parseInt(br.readLine());\t\tStringTokenizer st = new StringTokenizer(br.readLine(), \" \");\t\t\t\tint[] primeNumArr = new int[N];\t\tint primeNumCount = 0;\t\t\t\tfor (int i = 0; i &lt; primeNumArr.length; i++) {\t\t\tprimeNumArr[i] = Integer.parseInt(st.nextToken());\t\t\tif (isPrimeNum(primeNumArr[i])) {\t\t\t\tprimeNumCount++;\t\t\t}\t\t}\t\t\t\tSystem.out.println(primeNumCount);\t\t\t}\tprivate static boolean isPrimeNum(int num) {\t\tint factorCount = 0;\t\tfor (int i = 1; i &lt;= num/2; i++) {\t\t\tif (num % i == 0) {\t\t\t\tfactorCount++;\t\t\t}\t\t}\t\tif (factorCount == 1) return true;\t\telse return false;\t}}",
        "url": "/b1978"
    }
    ,
    
    "b9506": {
        "title": "[백준] 9506번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "약수들의 합문제어떤 숫자 n이 자신을 제외한 모든 약수들의 합과 같으면, 그 수를 완전수라고 한다.예를 들어 6은 6 = 1 + 2 + 3 으로 완전수이다.n이 완전수인지 아닌지 판단해주는 프로그램을 작성하라.입력입력은 테스트 케이스마다 한 줄 간격으로 n이 주어진다. (2 &lt; n &lt; 100,000)입력의 마지막엔 -1이 주어진다.출력테스트케이스 마다 한줄에 하나씩 출력해야 한다.n이 완전수라면, n을 n이 아닌 약수들의 합으로 나타내어 출력한다(예제 출력 참고).이때, 약수들은 오름차순으로 나열해야 한다.n이 완전수가 아니라면 n is NOT perfect. 를 출력한다.예제 입력 161228-1예제 출력 16 = 1 + 2 + 312 is NOT perfect.28 = 1 + 2 + 4 + 7 + 14풀이1import java.util.ArrayList;import java.util.List;import java.util.Scanner;public class Main {\t\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\tint inputNum;\t\t\t\twhile((inputNum = sc.nextInt()) != -1) {\t\t\tString result = isPerfectNum(inputNum);\t\t\tSystem.out.println(result);\t\t}\t\tsc.close();\t}\tprivate static String isPerfectNum(int inputNum) {\t\tList&lt;Integer&gt; factorList = new ArrayList&lt;&gt;();\t\tfor (int i = 1; i &lt;= inputNum/2; i++) {\t\t\tif (inputNum % i == 0) factorList.add(i);\t\t}\t\treturn getStrResult(factorList, inputNum);\t}\tprivate static String getStrResult(List&lt;Integer&gt; factorList, int inputNum) {\t\t\t\tint sum = 0;\t\tfor (int num : factorList) {\t\t\tsum += num;\t\t}\t\t\t\tStringBuilder sb = new StringBuilder();\t\t\t\tif (inputNum == sum) {\t\t\tfor (int i = 0; i &lt; factorList.size(); i++) {\t\t\t\tsb.append(factorList.get(i) + \" + \");\t\t\t}\t\t\tsb.setLength(sb.length() - 3);\t\t\treturn inputNum + \" = \" + sb.toString();\t\t}\t\telse {\t\t\treturn inputNum + \" is NOT perfect.\";\t\t}\t\t\t}}",
        "url": "/b9506"
    }
    ,
    
    "b2501": {
        "title": "[백준] 2501번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "약수 구하기문제어떤 자연수 p와 q가 있을 때, 만일 p를 q로 나누었을 때 나머지가 0이면 q는 p의 약수이다.6을 예로 들면      6 ÷ 1 = 6 … 0    6 ÷ 2 = 3 … 0    6 ÷ 3 = 2 … 0    6 ÷ 4 = 1 … 2    6 ÷ 5 = 1 … 1    6 ÷ 6 = 1 … 0그래서 6의 약수는 1, 2, 3, 6, 총 네 개이다.  두 개의 자연수 N과 K가 주어졌을 때, N의 약수들 중 K번째로 작은 수를 출력하는 프로그램을 작성하시오.입력첫째 줄에 N과 K가 빈칸을 사이에 두고 주어진다. N은 1 이상 10,000 이하이다. K는 1 이상 N 이하이다.출력첫째 줄에 N의 약수들 중 K번째로 작은 수를 출력한다. 만일 N의 약수의 개수가 K개보다 적어서 K번째 약수가 존재하지 않을 경우에는 0을 출력하시오.예제 입력 16 3예제 출력 13예제 입력 225 4예제 출력 20예제 입력 32735 1예제 출력 31풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main {\t\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tStringTokenizer st = new StringTokenizer(br.readLine(), \" \");\t\tint N = Integer.parseInt(st.nextToken());\t\tint K = Integer.parseInt(st.nextToken());\t\t\t\tint result = calFactor(N, K);\t\tSystem.out.println(result);\t\t\t}\tprivate static int calFactor(int N, int K) {\t\tint factorSequence = 1;\t\t\t\tfor (int i = 1; i &lt;= N/2; i++) {\t\t\tif (N % i == 0 &amp;&amp; factorSequence == K) {\t\t\t\treturn i;\t\t\t}\t\t\telse if (N % i == 0 &amp;&amp; factorSequence != K) {\t\t\t\tfactorSequence++;\t\t\t}\t\t}\t\t\t\tif (K - factorSequence == 0) return N;\t\t\t\treturn 0;\t}}",
        "url": "/b2501"
    }
    ,
    
    "b11653": {
        "title": "[백준] 11653번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "소인수분해문제정수 N이 주어졌을 때, 소인수분해하는 프로그램을 작성하시오.입력첫째 줄에 정수 N (1 ≤ N ≤ 10,000,000)이 주어진다.출력N의 소인수분해 결과를 한 줄에 하나씩 오름차순으로 출력한다. N이 1인 경우 아무것도 출력하지 않는다.예제 입력 172예제 출력 122233예제 입력 23예제 출력 23예제 입력 29991예제 출력 297103풀이1import java.util.ArrayList;import java.util.List;import java.util.Scanner;public class Main {\t\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\tint N = sc.nextInt();\t\tsc.close();\t\t\t\tif (N == 1) return;\t\t\t\tint leastFactor;\t\tList&lt;Integer&gt; leastFactorList = new ArrayList&lt;&gt;();\t\t\t\twhile ((leastFactor = getLeastFactor(N)) != N) {\t\t\tleastFactorList.add(leastFactor);\t\t\tN /= leastFactor;\t\t}\t\tleastFactorList.add(N);\t\t\t\tfor (int i = 0; i &lt; leastFactorList.size(); i++) {\t\t\tSystem.out.println(leastFactorList.get(i));\t\t}\t\t\t\t\t}\t\tprivate static int getLeastFactor(int N) {\t\t\t\tfor (int i = 2; i &lt;= N; i++) {\t\t\tif (N % i == 0) {\t\t\t\treturn i;\t\t\t}\t\t}\t\treturn N;\t}}",
        "url": "/b11653"
    }
    ,
    
    "b5086": {
        "title": "[백준] 5086번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "배수와 약수문제4 × 3 = 12이다.이 식을 통해 다음과 같은 사실을 알 수 있다.3은 12의 약수이고, 12는 3의 배수이다.4도 12의 약수이고, 12는 4의 배수이다.두 수가 주어졌을 때, 다음 3가지 중 어떤 관계인지 구하는 프로그램을 작성하시오.      첫 번째 숫자가 두 번째 숫자의 약수이다.    첫 번째 숫자가 두 번째 숫자의 배수이다.    첫 번째 숫자가 두 번째 숫자의 약수와 배수 모두 아니다.  입력입력은 여러 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 10,000이 넘지않는 두 자연수로 이루어져 있다. 마지막 줄에는 0이 2개 주어진다. 두 수가 같은 경우는 없다.출력각 테스트 케이스마다 첫 번째 숫자가 두 번째 숫자의 약수라면 factor를, 배수라면 multiple을, 둘 다 아니라면 neither를 출력한다.예제 입력 18 1632 417 50 0예제 출력 1factormultipleneither풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main {\t\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tStringTokenizer st;\t\t\t\twhile(true) {\t\t\tst = new StringTokenizer(br.readLine(), \" \");\t\t\tint A = Integer.parseInt(st.nextToken());\t\t\tint B = Integer.parseInt(st.nextToken());\t\t\tif (A == 0 &amp;&amp; B == 0) break;\t\t\t\t\t\tString result = classifyNum(A, B);\t\t\tSystem.out.println(result);\t\t}\t\t\t}\tprivate static String classifyNum(int a, int b) {\t\t\t\tif (a &lt; b &amp;&amp; (b % a) == 0) {\t\t\treturn \"factor\";\t\t}\t\telse if (a &gt;= b &amp;&amp; (a % b) == 0) {\t\t\treturn \"multiple\";\t\t}\t\telse {\t\t\treturn \"neither\";\t\t}\t}}",
        "url": "/b5086"
    }
    ,
    
    "bfs": {
        "title": "[알고리즘] BFS(너비 우선 탐색)",
            "author": "jjaemin0224",
            "category": "",
            "content": "1. BFSBFS(Breadth-First Search, 너비 우선 탐색)는 그래프를 탐색하는 알고리즘 중 하나로, 루트 노드에서 시작하여 인접한 모든 노드를 먼저 탐색하는 방법입니다. BFS는 너비(레벨) 우선으로 노드를 방문하며, 더 이상 방문할 수 있는 노드가 없을 때까지 탐색을 진행합니다.BFS의 동작 과정은 다음과 같습니다:  시작 노드를 큐(Queue)에 넣고 방문 처리합니다.  큐에서 노드를 하나 꺼내어 해당 노드의 인접한 노드들을 큐에 넣고 방문 처리합니다.  큐가 빌 때까지 2번의 과정을 반복합니다.BFS는 큐(Queue)를 사용하여 노드를 탐색 순서에 따라 저장하고 처리합니다. 이를 통해 너비(레벨) 우선으로 노드를 탐색하며, 같은 레벨에 있는 노드들을 먼저 방문합니다. 이러한 특성 때문에 BFS는 최단 경로를 구하는 문제에 자주 활용됩니다.2. BFS 특징  최단 경로  BFS는 시작 노드에서 목표 노드까지의 최단 경로를 찾는 데에 유리합니다. 너비(레벨) 우선으로 탐색하기 때문에, 같은 레벨의 노드를 모두 탐색한 후에 다음 레벨의 노드를 탐색하므로, 최단 경로를 탐색하는 데에 적합합니다.  모든 노드 탐색  BFS는 그래프의 모든 노드를 방문할 수 있습니다. 시작 노드와 연결된 모든 노드를 탐색하고, 그 다음 연결된 노드들을 탐색하는 방식으로 진행되기 때문입니다.  메모리 사용량  BFS는 큐를 사용하므로, 탐색해야 하는 노드를 큐에 저장해야 합니다. 그래프의 크기에 따라 필요한 메모리 사용량이 증가할 수 있습니다.BFS는 그래프 탐색, 네트워크 라우팅, 게임 AI, 추천 시스템 등 다양한 분야에서 활용되며, 그래프를 탐색하고 최단 경로를 찾는 데에 유용한 알고리즘입니다.3. BFS 예시3-1. 문제(숨바꼭질)한 마을에 숨어있는 사람(N)과 그 사람을 찾으려는 사람(K)이 있습니다. 숨은 사람의 위치와 찾는 사람의 위치가 주어질 때, 찾는 사람이 숨은 사람을 최단 시간 내에 찾을 수 있는 시간을 구하는 문제입니다.3-2. 규칙  사람은 0 이상 100,000 이하의 위치에 있을 수 있습니다.  한 번에 이동할 수 있는 거리는 1칸 앞이나 1칸 뒤로 움직이는 것과, 현재 위치의 2배로 순간 이동하는 것입니다.3-3. 입력  첫 번째 줄에는 숨은 사람의 위치 N과 찾는 사람의 위치 K가 공백으로 구분되어 주어집니다.3-4. 출력  찾는 사람이 숨은 사람을 최단 시간 내에 찾을 수 있는 시간을 출력합니다.3-5. 코드import java.util.*;public class Main {    public static void main(String[] args) {        Scanner scanner = new Scanner(System.in);        int N = scanner.nextInt();  // 숨은 사람의 위치        int K = scanner.nextInt();  // 찾는 사람의 위치        int[] dist = new int[100001];  // 거리를 저장할 배열        // BFS를 위한 큐        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();        queue.offer(N);  // 시작 위치를 큐에 추가        dist[N] = 0;  // 시작 위치의 거리를 0으로 초기화        while (!queue.isEmpty()) {            int current = queue.poll();            // 현재 위치에서 다음 위치로 이동하는 경우의 수를 계산            int[] nextPositions = {current - 1, current + 1, current * 2};            for (int next : nextPositions) {                // 다음 위치가 범위 내에 있고, 방문한 적이 없는 경우에만 탐색                if (next &gt;= 0 &amp;&amp; next &lt;= 100000 &amp;&amp; dist[next] == 0) {                    queue.offer(next);  // 다음 위치를 큐에 추가                    dist[next] = dist[current] + 1;  // 거리 갱신                    // 찾는 사람을 찾은 경우 탐색 종료                    if (next == K) {                        System.out.println(dist[next]);                        return;                    }                }            }        }    }}",
        "url": "/bfs"
    }
    ,
    
    "b11005": {
        "title": "[백준] 11005번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "진법 변환문제10진법 수 N이 주어진다. 이 수를 B진법으로 바꿔 출력하는 프로그램을 작성하시오.10진법을 넘어가는 진법은 숫자로 표시할 수 없는 자리가 있다. 이런 경우에는 다음과 같이 알파벳 대문자를 사용한다.A: 10, B: 11, …, F: 15, …, Y: 34, Z: 35입력첫째 줄에 N과 B가 주어진다. (2 ≤ B ≤ 36) N은 10억보다 작거나 같은 자연수이다.출력첫째 줄에 10진법 수 N을 B진법으로 출력한다.예제 입력 160466175 36예제 출력 1ZZZZZ풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main {\t\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tString[] input = br.readLine().split(\" \");\t\t\t\tint N = Integer.parseInt(input[0]);\t\tint B = Integer.parseInt(input[1]);\t\t\t\tStringBuilder sb = new StringBuilder();\t\t\t\twhile(N &gt; 0) {\t\t\tint tmp = N % B;\t\t\tif (tmp &gt;= 10) {\t\t\t\tsb.append((char) (tmp + 55)); // 10 이상인 경우 A부터 문자로 표현\t\t\t} else {\t\t\t\tsb.append((char) (tmp + 48)); // 0부터 9까지는 그대로 문자로 표현\t\t\t}\t\t\tN /= B;\t\t\t\t\t}\t\t\t\tSystem.out.println(sb.reverse().toString());\t\t\t}\t}",
        "url": "/b11005"
    }
    ,
    
    "b2745": {
        "title": "[백준] 2745번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "진법 변환문제B진법 수 N이 주어진다. 이 수를 10진법으로 바꿔 출력하는 프로그램을 작성하시오.10진법을 넘어가는 진법은 숫자로 표시할 수 없는 자리가 있다. 이런 경우에는 다음과 같이 알파벳 대문자를 사용한다.A: 10, B: 11, …, F: 15, …, Y: 34, Z: 35입력첫째 줄에 N과 B가 주어진다. (2 ≤ B ≤ 36)B진법 수 N을 10진법으로 바꾸면, 항상 10억보다 작거나 같다.출력첫째 줄에 B진법 수 N을 10진법으로 출력한다.예제 입력 1ZZZZZ 36예제 출력 160466175풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main {\t\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tStringTokenizer st = new StringTokenizer(br.readLine(), \" \");\t\t\t\tString N = st.nextToken();\t\tint B = Integer.parseInt(st.nextToken());\t\tint number = 0;\t\t\t\tfor (int i = 0; i &lt; N.length(); i++) {\t\t\tint tmp = N.charAt(i);\t\t\tif (tmp &gt;= 48 &amp;&amp; tmp &lt;= 57) {\t\t\t\tnumber += (tmp-48)*Math.pow(B, N.length()-1-i);\t\t\t}\t\t\telse if (tmp &gt;= 65 &amp;&amp; tmp &lt;= 90) {\t\t\t\tnumber += (tmp-55)*Math.pow(B, N.length()-1-i);\t\t\t}\t\t}\t\t\t\tSystem.out.println(number);\t\t\t}}풀이2 (개선)import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main {    public static void main(String[] args) throws IOException {        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        String[] input = br.readLine().split(\" \");        String N = input[0];        int B = Integer.parseInt(input[1]);        int number = 0;        char[] digits = N.toCharArray();        int length = digits.length;        for (int i = 0; i &lt; length; i++) {            int tmp = digits[i];            int value;            if (tmp &gt;= '0' &amp;&amp; tmp &lt;= '9') {                value = tmp - '0';            } else if (tmp &gt;= 'A' &amp;&amp; tmp &lt;= 'Z') {                value = tmp - 'A' + 10;            } else {                continue;            }            number += value * pow(B, length - 1 - i);        }        System.out.println(number);    }    public static int pow(int base, int exponent) {        int result = 1;        while (exponent &gt; 0) {            if (exponent % 2 == 1) {                result *= base;            }            base *= base;            exponent /= 2;        }        return result;    }}  ‘StringTokenizer’는 현재 Java 버전에서는 사용이 권장되지 않는 클래스이므로 ‘split()’을 사용한다.  문자열을 문자 배열로 변환하고 배열을 순회하는 방법을 사용하기 위해 ‘N.charAt(i)’ 대신 ‘N.toCharArray()[i]’를 사용한다.  ‘Math.pow()’ 메서드를 사용하는 대신, 다른 방법을 사용하여 제곱을 계산한다.  관련링크      Exponentiation by Squaring (지수의 분할 정복)  ",
        "url": "/b2745"
    }
    ,
    
    "b10757": {
        "title": "[백준] 10757번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "큰 수 A+B문제두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.입력첫째 줄에 A와 B가 주어진다. (0 &lt; A,B &lt; 10의 10000승)출력첫째 줄에 A+B를 출력한다.예제 입력 19223372036854775807 9223372036854775808예제 출력 118446744073709551615풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.math.BigDecimal;import java.util.StringTokenizer;public class Main {\t\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tStringTokenizer st = new StringTokenizer(br.readLine(), \" \");\t\tBigDecimal A = new BigDecimal(st.nextToken());\t\tBigDecimal B = new BigDecimal(st.nextToken());\t\t\t\tSystem.out.println(A.add(B));\t}}",
        "url": "/b10757"
    }
    ,
    
    "b2869": {
        "title": "[백준] 2869번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "달팽이는 올라가고 싶다문제땅 위에 달팽이가 있다. 이 달팽이는 높이가 V미터인 나무 막대를 올라갈 것이다.달팽이는 낮에 A미터 올라갈 수 있다. 하지만, 밤에 잠을 자는 동안 B미터 미끄러진다. 또, 정상에 올라간 후에는 미끄러지지 않는다.달팽이가 나무 막대를 모두 올라가려면, 며칠이 걸리는지 구하는 프로그램을 작성하시오.입력첫째 줄에 세 정수 A, B, V가 공백으로 구분되어서 주어진다. (1 ≤ B &lt; A ≤ V ≤ 1,000,000,000)출력첫째 줄에 달팽이가 나무 막대를 모두 올라가는데 며칠이 걸리는지 출력한다.예제 입력 12 1 5예제 출력 14예제 입력 25 1 6예제 출력 22예제 입력 3100 99 1000000000예제 출력 3999999901풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main {\t\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tStringTokenizer st = new StringTokenizer(br.readLine(), \" \");\t\t\t\tint A = Integer.parseInt(st.nextToken());\t\tint B = Integer.parseInt(st.nextToken());\t\tint V = Integer.parseInt(st.nextToken());\t\t\t\tint day = ((V - B) / (A - B));\t\t\t\tif((V - B) % (A - B) != 0) day++;\t\t\t\tSystem.out.println(day);\t}\t}",
        "url": "/b2869"
    }
    ,
    
    "b1193": {
        "title": "[백준] 1193번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "분수찾기문제무한히 큰 배열에 다음과 같이 분수들이 적혀있다.1/1\t1/2\t1/3\t1/4\t1/5\t…2/1\t2/2\t2/3\t2/4\t…\t…3/1\t3/2\t3/3\t…\t…\t…4/1\t4/2\t…\t…\t…\t…5/1\t…\t…\t…\t…\t……\t…\t…\t…\t…\t…이와 같이 나열된 분수들을 1/1 → 1/2 → 2/1 → 3/1 → 2/2 → … 과 같은 지그재그 순서로 차례대로 1번, 2번, 3번, 4번, 5번, … 분수라고 하자.X가 주어졌을 때, X번째 분수를 구하는 프로그램을 작성하시오.입력첫째 줄에 X(1 ≤ X ≤ 10,000,000)가 주어진다.출력첫째 줄에 분수를 출력한다.예제 입력 11예제 출력 11/1예제 입력 22예제 출력 21/2예제 입력 33예제 출력 32/1풀이1import java.util.Scanner;public class Main {\t\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\tint N = sc.nextInt();\t\tsc.close();\t\t\t\tint diagonal = 1;\t\t\t\twhile(N - diagonalSum(diagonal) &gt; 0) {\t\t\tdiagonal++;\t\t}\t\t\t\tint remain = diagonalSum(diagonal) - N;\t\t\t\tif (diagonal % 2 == 0) {\t\t\t\t\t\tSystem.out.println((diagonal - remain) + \"/\" + (remain + 1));\t\t}\t\telse {\t\t\tSystem.out.println((remain + 1) + \"/\" + (diagonal - remain));\t\t}\t\t\t\t\t}\t\tprivate static int diagonalSum(int diagonal) {\t\tint sum = 0;\t\tfor (int i = 0; i &lt;= diagonal; i++) {\t\t\tsum += i;\t\t}\t\treturn sum;\t}\t}",
        "url": "/b1193"
    }
    ,
    
    "b2292": {
        "title": "[백준] 2292번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "벌집문제위의 그림과 같이 육각형으로 이루어진 벌집이 있다. 그림에서 보는 바와 같이 중앙의 방 1부터 시작해서 이웃하는 방에 돌아가면서 1씩 증가하는 번호를 주소로 매길 수 있다. 숫자 N이 주어졌을 때, 벌집의 중앙 1에서 N번 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나가는지(시작과 끝을 포함하여)를 계산하는 프로그램을 작성하시오. 예를 들면, 13까지는 3개, 58까지는 5개를 지난다.입력첫째 줄에 N(1 ≤ N ≤ 1,000,000,000)이 주어진다.출력입력으로 주어진 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나는지 출력한다.예제 입력 113예제 출력 13풀이1import java.util.Scanner;public class Main {\t\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\t\t\tint room = sc.nextInt();\t\t\t\tif (room == 1) {\t\t\tSystem.out.println(1);\t\t\treturn;\t\t}\t\t\t\troom = room - 1;\t\tint count = 1;\t\twhile (room &gt; 0) {\t\t\troom -= (6 * count);\t\t\tcount++; \t\t}\t\t\t\tSystem.out.println(count);\t\t\t}}",
        "url": "/b2292"
    }
    ,
    
    "b2903": {
        "title": "[백준] 2903번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "중앙 이동 알고리즘문제상근이는 친구들과 함께 SF영화를 찍으려고 한다. 이 영화는 외계 지형이 필요하다. 실제로 우주선을 타고 외계 행성에 가서 촬영을 할 수 없기 때문에, 컴퓨터 그래픽으로 CG처리를 하려고 한다.외계 지형은 중앙 이동 알고리즘을 이용해서 만들려고 한다.알고리즘을 시작하면서 상근이는 정사각형을 이루는 점 4개를 고른다. 그 후에는 다음과 같은 과정을 거쳐서 지형을 만든다.정사각형의 각 변의 중앙에 점을 하나 추가한다.정사각형의 중심에 점을 하나 추가한다.초기 상태에서 위와 같은 과정을 한 번 거치면 총 4개의 정사각형이 새로 생긴다. 이와 같은 과정을 상근이가 만족할 때 까지 계속한다.아래 그림은 과정을 총 2번 거쳤을 때까지의 모습이다.상근이는 어떤 점은 한 개 보다 많은 정사각형에 포함될 수 있다는 사실을 알았다. 메모리 소모량을 줄이기 위해서 중복하는 점을 한 번만 저장하려고 한다. 과정을 N번 거친 후 점 몇 개를 저장해야 하는지 구하는 프로그램을 작성하시오.입력첫째 줄에 N이 주어진다. (1 ≤ N ≤ 15)출력첫째 줄에 과정을 N번 거친 후 점의 수를 출력한다.예제 입력 11예제 출력 19예제 입력 22예제 출력 225예제 입력 35예제 출력 31089풀이1import java.util.Scanner;public class Main {\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\t\t\tint N = sc.nextInt();\t\tint point = 2;\t\t\t\tfor (int i = 0; i &lt; N; i++) {\t\t\tpoint = point + (point - 1);\t\t}\t\t\t\tSystem.out.println(point * point);\t\t\t}\t}",
        "url": "/b2903"
    }
    ,
    
    "b2720": {
        "title": "[백준] 2720번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "세탁소 사장 동혁문제미국으로 유학간 동혁이는 세탁소를 운영하고 있다. 동혁이는 최근에 아르바이트로 고등학생 리암을 채용했다.동혁이는 리암에게 실망했다.리암은 거스름돈을 주는 것을 자꾸 실수한다.심지어 $0.5달러를 줘야하는 경우에 거스름돈으로 $5달러를 주는것이다!어쩔수 없이 뛰어난 코딩 실력을 발휘해 리암을 도와주는 프로그램을 작성하려고 하지만, 디아블로를 하느라 코딩할 시간이 없어서 이 문제를 읽고 있는 여러분이 대신 해주어야 한다.거스름돈의 액수가 주어지면 리암이 줘야할 쿼터(Quarter, $0.25)의 개수, 다임(Dime, $0.10)의 개수, 니켈(Nickel, $0.05)의 개수, 페니(Penny, $0.01)의 개수를 구하는 프로그램을 작성하시오. 거스름돈은 항상 $5.00 이하이고, 손님이 받는 동전의 개수를 최소로 하려고 한다. 예를 들어, $1.24를 거슬러 주어야 한다면, 손님은 4쿼터, 2다임, 0니켈, 4페니를 받게 된다.입력첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 거스름돈 C를 나타내는 정수 하나로 이루어져 있다. C의 단위는 센트이다. (1달러 = 100센트) (1&lt;=C&lt;=500)출력각 테스트케이스에 대해 필요한 쿼터의 개수, 다임의 개수, 니켈의 개수, 페니의 개수를 공백으로 구분하여 출력한다.예제 입력 1312425194예제 출력 14 2 0 41 0 0 07 1 1 4풀이1import java.util.Scanner;public class Main {\t\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\tint N = sc.nextInt();\t\tint[] changes;\t\t\t\tint[] arr = new int[N];\t\tfor (int i = 0; i &lt; arr.length; i++) {\t\t\tarr[i] = sc.nextInt();\t\t}\t\t\t\tfor (int i = 0; i &lt; arr.length; i++) {\t\t\tchanges = calChange(arr[i]);\t\t\tSystem.out.println(changes[0] + \" \" + changes[1] + \" \" + changes[2] + \" \" + changes[3] );\t\t}\t\t\t}\tprivate static int[] calChange(int money) {\t\tint[] changes = new int[4];\t\tchanges[0] = money / 25;\t\tmoney %= 25;\t\tchanges[1] = money / 10;\t\tmoney %= 10;\t\tchanges[2] = money / 5;\t\tmoney %= 5;\t\tchanges[3] = money;\t\treturn changes;\t}\t}",
        "url": "/b2720"
    }
    ,
    
    "b25206": {
        "title": "[백준] 25206번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "너의 평점은문제인하대학교 컴퓨터공학과를 졸업하기 위해서는, 전공평점이 3.3 이상이거나 졸업고사를 통과해야 한다. 그런데 아뿔싸, 치훈이는 깜빡하고 졸업고사를 응시하지 않았다는 사실을 깨달았다!치훈이의 전공평점을 계산해주는 프로그램을 작성해보자.전공평점은 전공과목별 (학점 × 과목평점)의 합을 학점의 총합으로 나눈 값이다.P/F 과목의 경우 등급이 P또는 F로 표시되는데, 등급이 P인 과목은 계산에서 제외해야 한다.과연 치훈이는 무사히 졸업할 수 있을까?입력20줄에 걸쳐 치훈이가 수강한 전공과목의 과목명, 학점, 등급이 공백으로 구분되어 주어진다.출력치훈이의 전공평점을 출력한다.정답과의 절대오차 또는 상대오차가 (10^{-4}) 이하이면 정답으로 인정한다.제한  1 ≤ 과목명의 길이 ≤ 50  과목명은 알파벳 대소문자 또는 숫자로만 이루어져 있으며, 띄어쓰기 없이 주어진다. 입력으로 주어지는 모든 과목명은 서로 다르다.  학점은 1.0,2.0,3.0,4.0중 하나이다.  등급은 A+,A0,B+,B0,C+,C0,D+,D0,F,P중 하나이다.  적어도 한 과목은 등급이 P가 아님이 보장된다.예제 입력 1ObjectOrientedProgramming1 3.0 A+IntroductiontoComputerEngineering 3.0 A+ObjectOrientedProgramming2 3.0 A0CreativeComputerEngineeringDesign 3.0 A+AssemblyLanguage 3.0 A+InternetProgramming 3.0 B0ApplicationProgramminginJava 3.0 A0SystemProgramming 3.0 B0OperatingSystem 3.0 B0WirelessCommunicationsandNetworking 3.0 C+LogicCircuits 3.0 B0DataStructure 4.0 A+MicroprocessorApplication 3.0 B+EmbeddedSoftware 3.0 C0ComputerSecurity 3.0 D+Database 3.0 C+Algorithm 3.0 B0CapstoneDesigninCSE 3.0 B+CompilerDesign 3.0 D0ProblemSolving 4.0 P예제 출력 13.284483풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main {\t\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tStringTokenizer st;\t\t\t\tdouble score_sum = 0;\t\tint score_num = 0;\t\t\t\tfor (int i = 0; i &lt; 20; i++) {\t\t\tst = new StringTokenizer(br.readLine(), \" \");\t\t\tst.nextToken();\t\t\tdouble credits = Double.parseDouble(st.nextToken());\t\t\tString score = st.nextToken();\t\t\t\t\t\tscore_num += credits;\t\t\t\t\t\tswitch(score) {\t\t\t\tcase \"A+\" : \t\t\t\t\tscore_sum += (4.5 * credits);\t\t\t\t\tbreak;\t\t\t\tcase \"A0\" :\t\t\t\t\tscore_sum += (4.0 * credits);\t\t\t\t\tbreak;\t\t\t\tcase \"B+\" : \t\t\t\t\tscore_sum += (3.5 * credits);\t\t\t\t\tbreak;\t\t\t\tcase \"B0\" : \t\t\t\t\tscore_sum += (3.0 * credits);\t\t\t\t\tbreak;\t\t\t\tcase \"C+\" :\t\t\t\t\tscore_sum += (2.5 * credits);\t\t\t\t\tbreak;\t\t\t\tcase \"C0\" :\t\t\t\t\tscore_sum += (2.0 * credits);\t\t\t\t\tbreak;\t\t\t\tcase \"D+\" : \t\t\t\t\tscore_sum += (1.5 * credits);\t\t\t\t\tbreak;\t\t\t\tcase \"D0\" :\t\t\t\t\tscore_sum += (1.0 * credits);\t\t\t\t\tbreak;\t\t\t\tcase \"F\" : \t\t\t\t\tbreak;\t\t\t\tcase \"P\" : \t\t\t\t\tscore_num -= credits;\t\t\t\t\tbreak;\t\t\t\tdefault :\t\t\t\t\tbreak;\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t}\t\tSystem.out.println(score_sum / score_num);\t\t\t\t\t}}\t",
        "url": "/b25206"
    }
    ,
    
    "b2563": {
        "title": "[백준] 2563번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "색종이문제가로, 세로의 크기가 각각 100인 정사각형 모양의 흰색 도화지가 있다. 이 도화지 위에 가로, 세로의 크기가 각각 10인 정사각형 모양의 검은색 색종이를 색종이의 변과 도화지의 변이 평행하도록 붙인다. 이러한 방식으로 색종이를 한 장 또는 여러 장 붙인 후 색종이가 붙은 검은 영역의 넓이를 구하는 프로그램을 작성하시오.예를 들어 흰색 도화지 위에 세 장의 검은색 색종이를 그림과 같은 모양으로 붙였다면 검은색 영역의 넓이는 260이 된다.입력첫째 줄에 색종이의 수가 주어진다. 이어 둘째 줄부터 한 줄에 하나씩 색종이를 붙인 위치가 주어진다. 색종이를 붙인 위치는 두 개의 자연수로 주어지는데 첫 번째 자연수는 색종이의 왼쪽 변과 도화지의 왼쪽 변 사이의 거리이고, 두 번째 자연수는 색종이의 아래쪽 변과 도화지의 아래쪽 변 사이의 거리이다. 색종이의 수는 100 이하이며, 색종이가 도화지 밖으로 나가는 경우는 없다출력첫째 줄에 색종이가 붙은 검은 영역의 넓이를 출력한다.예제 입력 133 715 75 2예제 출력 1260풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main {\t\tpublic static void main(String[] args) throws NumberFormatException, IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tStringTokenizer st;\t\t\t\tint N = Integer.parseInt(br.readLine());\t\tboolean[][] arr = new boolean[100][100];\t\tint width = 0;\t\t\t\tfor (int i = 0; i &lt; N; i++) {\t\t\tst = new StringTokenizer(br.readLine(), \" \");\t\t\tint x = Integer.parseInt(st.nextToken());\t\t\tint y = Integer.parseInt(st.nextToken());\t\t\t\t\t\tfor (int j = x; j &lt; x+10; j++) {\t\t\t\tfor (int k = y; k &lt; y+10; k++) {\t\t\t\t\tarr[j][k] = true;\t\t\t\t}\t\t\t}\t\t}\t\t\t\tfor (int i = 0; i &lt; arr.length; i++) {\t\t\tfor (int j = 0; j &lt; arr[i].length; j++) {\t\t\t\tif (arr[i][j]) width++;\t\t\t}\t\t}\t\t\t\tSystem.out.println(width);\t\t\t}}",
        "url": "/b2563"
    }
    ,
    
    "b10798": {
        "title": "[백준] 10798번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "세로 읽기문제아직 글을 모르는 영석이가 벽에 걸린 칠판에 자석이 붙어있는 글자들을 붙이는 장난감을 가지고 놀고 있다.이 장난감에 있는 글자들은 영어 대문자 ‘A’부터 ‘Z’, 영어 소문자 ‘a’부터 ‘z’, 숫자 ‘0’부터 ‘9’이다. 영석이는 칠판에 글자들을 수평으로 일렬로 붙여서 단어를 만든다. 다시 그 아래쪽에 글자들을 붙여서 또 다른 단어를 만든다. 이런 식으로 다섯 개의 단어를 만든다. 아래 그림 1은 영석이가 칠판에 붙여 만든 단어들의 예이다.A A B C D Da f z z 0 9 1 2 1a 8 E W g 6P 5 h 3 k x한 줄의 단어는 글자들을 빈칸 없이 연속으로 나열해서 최대 15개의 글자들로 이루어진다. 또한 만들어진 다섯 개의 단어들의 글자 개수는 서로 다를 수 있다.심심해진 영석이는 칠판에 만들어진 다섯 개의 단어를 세로로 읽으려 한다. 세로로 읽을 때, 각 단어의 첫 번째 글자들을 위에서 아래로 세로로 읽는다. 다음에 두 번째 글자들을 세로로 읽는다. 이런 식으로 왼쪽에서 오른쪽으로 한 자리씩 이동 하면서 동일한 자리의 글자들을 세로로 읽어 나간다. 위의 그림 1의 다섯 번째 자리를 보면 두 번째 줄의 다섯 번째 자리의 글자는 없다. 이런 경우처럼 세로로 읽을 때 해당 자리의 글자가 없으면, 읽지 않고 그 다음 글자를 계속 읽는다. 그림 1의 다섯 번째 자리를 세로로 읽으면 D1gk로 읽는다.그림 1에서 영석이가 세로로 읽은 순서대로 글자들을 공백 없이 출력하면 다음과 같다:Aa0aPAf985Bz1EhCz2W3D1gkD6x칠판에 붙여진 단어들이 주어질 때, 영석이가 세로로 읽은 순서대로 글자들을 출력하는 프로그램을 작성하시오.입력총 다섯줄의 입력이 주어진다. 각 줄에는 최소 1개, 최대 15개의 글자들이 빈칸 없이 연속으로 주어진다. 주어지는 글자는 영어 대문자 ‘A’부터 ‘Z’, 영어 소문자 ‘a’부터 ‘z’, 숫자 ‘0’부터 ‘9’ 중 하나이다. 각 줄의 시작과 마지막에 빈칸은 없다.출력영석이가 세로로 읽은 순서대로 글자들을 출력한다. 이때, 글자들을 공백 없이 연속해서 출력한다.예제 입력 1ABCDEabcde01234FGHIJfghij예제 출력 1Aa0FfBb1GgCc2HhDd3IiEe4Jj예제 입력 2AABCDDafzz09121a8EWg6P5h3kx예제 출력 2Aa0aPAf985Bz1EhCz2W3D1gkD6x풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main {\t\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tString[][] arr = new String[5][];\t\tint maxLen = 0;\t\t\t\tfor (int i = 0; i &lt; 5; i++) {\t\t\tString tmp = br.readLine();\t\t\tarr[i] = tmp.split(\"\");\t\t\tif (tmp.length() &gt; maxLen) maxLen = tmp.length();\t\t}\t\t\t\tStringBuilder sb = new StringBuilder();\t\t\t\tfor (int i = 0; i &lt; maxLen; i++) {\t\t\tfor (int j = 0; j &lt; 5; j++) {\t\t\t\ttry {\t\t\t\t\tsb.append(arr[j][i]);\t\t\t\t} catch (Exception e) {\t\t\t\t}\t\t\t}\t\t}\t\t\t\tSystem.out.println(sb.toString());\t\t\t}}풀이2 (개선)import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main {        public static void main(String[] args) throws IOException {                BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        char[][] arr = new char[5][15];        int maxLen = 0;                for (int i = 0; i &lt; 5; i++) {            String tmp = br.readLine();            int len = tmp.length();            maxLen = Math.max(maxLen, len);            for (int j = 0; j &lt; len; j++) {                arr[i][j] = tmp.charAt(j);            }        }                StringBuilder sb = new StringBuilder();                for (int i = 0; i &lt; maxLen; i++) {            for (int j = 0; j &lt; 5; j++) {                if (arr[j][i] != '\\0') {                    sb.append(arr[j][i]);                }            }        }                System.out.println(sb.toString());    }}  String 타입 대신에 char 타입을 사용하여 메모리 사용량을 줄인다.  try-catch문 대신에 조건문을 사용하여 배열의 인덱스를 체크한다.  ‘\\0’는 널 문자로 문자열의 끝을 표시하는 특별한 문자다.",
        "url": "/b10798"
    }
    ,
    
    "b2566": {
        "title": "[백준] 2566번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "최댓값문제&lt;그림 1&gt;과 같이 9×9 격자판에 쓰여진 81개의 자연수 또는 0이 주어질 때, 이들 중 최댓값을 찾고 그 최댓값이 몇 행 몇 열에 위치한 수인지 구하는 프로그램을 작성하시오.예를 들어, 다음과 같이 81개의 수가 주어지면 \t1열\t2열\t3열\t4열\t5열\t6열\t7열\t8열\t9열1행\t3\t23\t85\t34\t17\t74\t25\t52\t652행\t10\t7\t39\t42\t88\t52\t14\t72\t633행\t87\t42\t18\t78\t53\t45\t18\t84\t534행\t34\t28\t64\t85\t12\t16\t75\t36\t555행\t21\t77\t45\t35\t28\t75\t90\t76\t16행\t25\t87\t65\t15\t28\t11\t37\t28\t747행\t65\t27\t75\t41\t7\t89\t78\t64\t398행\t47\t47\t70\t45\t23\t65\t3\t41\t449행\t87\t13\t82\t38\t31\t12\t29\t29\t80이들 중 최댓값은 90이고, 이 값은 5행 7열에 위치한다.입력첫째 줄부터 아홉 번째 줄까지 한 줄에 아홉 개씩 수가 주어진다. 주어지는 수는 100보다 작은 자연수 또는 0이다.출력첫째 줄에 최댓값을 출력하고, 둘째 줄에 최댓값이 위치한 행 번호와 열 번호를 빈칸을 사이에 두고 차례로 출력한다. 최댓값이 두 개 이상인 경우 그 중 한 곳의 위치를 출력한다.예제 입력 13 23 85 34 17 74 25 52 6510 7 39 42 88 52 14 72 6387 42 18 78 53 45 18 84 5334 28 64 85 12 16 75 36 5521 77 45 35 28 75 90 76 125 87 65 15 28 11 37 28 7465 27 75 41 7 89 78 64 3947 47 70 45 23 65 3 41 4487 13 82 38 31 12 29 29 80예제 출력 1905 7풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main {\t\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tStringTokenizer st;\t\t\t\tint[][] arr = new int[9][9];\t\tint max = 0, maxI = 0, maxJ = 0;\t\t\t\tfor (int i = 0; i &lt; 9; i++) {\t\t\tst = new StringTokenizer(br.readLine(), \" \");\t\t\tfor (int j = 0; j &lt; 9; j++) {\t\t\t\tarr[i][j] = Integer.parseInt(st.nextToken());\t\t\t\tif (arr[i][j] &gt; max) {\t\t\t\t\tmax = arr[i][j];\t\t\t\t\tmaxI = i;\t\t\t\t\tmaxJ = j;\t\t\t\t}\t\t\t}\t\t}\t\tSystem.out.println(max);\t\tSystem.out.println((maxI+1) + \" \" + (maxJ+1));\t\t\t}}",
        "url": "/b2566"
    }
    ,
    
    "b2728": {
        "title": "[백준] 2728번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "행렬 덧셈문제N*M크기의 두 행렬 A와 B가 주어졌을 때, 두 행렬을 더하는 프로그램을 작성하시오.입력첫째 줄에 행렬의 크기 N 과 M이 주어진다. 둘째 줄부터 N개의 줄에 행렬 A의 원소 M개가 차례대로 주어진다. 이어서 N개의 줄에 행렬 B의 원소 M개가 차례대로 주어진다. N과 M은 100보다 작거나 같고, 행렬의 원소는 절댓값이 100보다 작거나 같은 정수이다.출력첫째 줄부터 N개의 줄에 행렬 A와 B를 더한 행렬을 출력한다. 행렬의 각 원소는 공백으로 구분한다.예제 입력 13 31 1 12 2 20 1 03 3 34 4 45 5 100예제 출력 14 4 46 6 65 6 100풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main {\t\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tStringTokenizer st = new StringTokenizer(br.readLine(), \" \");\t\tint N = Integer.parseInt(st.nextToken());\t\tint M = Integer.parseInt(st.nextToken());\t\t\t\tint[][] arr1 = new int[N][M];\t\tint[][] arr2 = new int[N][M];\t\t\t\t\t\t\t\tfor (int i = 0; i &lt; N; i++) {\t\t\tst = new StringTokenizer(br.readLine(), \" \");\t\t\tfor (int j = 0; j &lt; M; j++) {\t\t\t\tarr1[i][j] = Integer.parseInt(st.nextToken());\t\t\t}\t\t}\t\t\t\tfor (int i = 0; i &lt; N; i++) {\t\t\tst = new StringTokenizer(br.readLine(), \" \");\t\t\tfor (int j = 0; j &lt; M; j++) {\t\t\t\tarr2[i][j] = Integer.parseInt(st.nextToken());\t\t\t}\t\t}\t\t\t\tStringBuilder sb = new StringBuilder();\t    for(int i =0 ; i &lt; N; i++) {\t    \tfor(int j = 0; j &lt; M; j++) {\t    \t\tsb.append((arr1[i][j] + arr2[i][j]) + \" \");\t    \t}\t    \tsb.append(\"\\n\");\t    }                System.out.println(sb.toString());\t\t\t}\t}",
        "url": "/b2728"
    }
    ,
    
    "b1316": {
        "title": "[백준] 1316번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "그룹 단어 체커문제      그룹 단어란 단어에 존재하는 모든 문자에 대해서, 각 문자가 연속해서 나타나는 경우만을 말한다. 예를 들면, ccazzzzbb는 c, a, z, b가 모두 연속해서 나타나고, kin도 k, i, n이 연속해서 나타나기 때문에 그룹 단어이지만, aabbbccb는 b가 떨어져서 나타나기 때문에 그룹 단어가 아니다.        단어 N개를 입력으로 받아 그룹 단어의 개수를 출력하는 프로그램을 작성하시오.  입력  첫째 줄에 단어의 개수 N이 들어온다. N은 100보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 단어가 들어온다. 단어는 알파벳 소문자로만 되어있고 중복되지 않으며, 길이는 최대 100이다.출력  첫째 줄에 그룹 단어의 개수를 출력한다.예제 입력 13happynewyear예제 출력 13예제 입력 14abaabababcabca예제 출력 11풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main {\t\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tpublic static void main(String[] args) throws IOException {\t\t\t\tint N = Integer.parseInt(br.readLine());\t\tint count = 0;\t\t\t\tfor (int i = 0; i &lt; N; i++) {\t\t\tif(check() == true) {\t\t\t\tcount++;\t\t\t}\t\t}\t\t\t\tSystem.out.println(count);\t}// end main\tprivate static boolean check() throws IOException {\t\t\t\tString str = br.readLine();\t\tboolean[] arr = new boolean[26];\t\tint preCharAt = 0;\t\t\t\tfor (int i = 0; i &lt; str.length(); i++) {\t\t\t\t\t\tif(str.charAt(i) != preCharAt) {\t\t\t\tif(arr[str.charAt(i) - 'a'] == false) {\t\t\t\t\tarr[str.charAt(i) - 'a'] = true;\t\t\t\t\tpreCharAt = str.charAt(i);\t\t\t\t}\t\t\t\telse {\t\t\t\t\treturn false;\t\t\t\t}\t\t\t}else {\t\t\t\tcontinue;\t\t\t}\t\t\t\t\t}\t\t\t\treturn true;\t\t\t}// end check}// end class",
        "url": "/b1316"
    }
    ,
    
    "b2941": {
        "title": "[백준] 2941번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "크로아티아 알파벳문제  예전에는 운영체제에서 크로아티아 알파벳을 입력할 수가 없었다. 따라서, 다음과 같이 크로아티아 알파벳을 변경해서 입력했다.크로아티아 알파벳        변경č\t                    c=ć\t                    c-dž\t                    dz=đ\t                    d-lj\t                    ljnj\t                    njš\t                    s=ž\t                    z=      예를 들어, ljes=njak은 크로아티아 알파벳 6개(lj, e, š, nj, a, k)로 이루어져 있다. 단어가 주어졌을 때, 몇 개의 크로아티아 알파벳으로 이루어져 있는지 출력한다.        dž는 무조건 하나의 알파벳으로 쓰이고, d와 ž가 분리된 것으로 보지 않는다. lj와 nj도 마찬가지이다. 위 목록에 없는 알파벳은 한 글자씩 센다.  입력      첫째 줄에 최대 100글자의 단어가 주어진다. 알파벳 소문자와 ‘-‘, ‘=’로만 이루어져 있다.        단어는 크로아티아 알파벳으로 이루어져 있다. 문제 설명의 표에 나와있는 알파벳은 변경된 형태로 입력된다.  출력  입력으로 주어진 단어가 몇 개의 크로아티아 알파벳으로 이루어져 있는지 출력한다.예제 입력 1ljes=njak예제 출력 16예제 입력 1ddz=z=예제 출력 13풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main {\t\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\t\t\tString str = br.readLine();\t\t\t\tint count = 0;\t\t\t\tfor (int i = 0; i &lt; str.length(); i++) {\t\t\t\t\t\tif (str.charAt(i) == 'c' &amp;&amp; i &lt; str.length() - 1) {\t\t\t\tif (str.charAt(i+1) == '=' || str.charAt(i+1) == '-') {\t\t\t\t\ti++;\t\t\t\t}\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\telse if (str.charAt(i) == 'd' &amp;&amp; i &lt; str.length() - 1) {\t\t\t\tif (str.charAt(i+1) == '-') {\t\t\t\t\ti++;\t\t\t\t} else if (str.charAt(i+1) == 'z' &amp;&amp; i &lt; str.length() - 2) {\t\t\t\t\tif (str.charAt(i+2) == '=') {\t\t\t\t\t\ti += 2;\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\t\t\t\t\t\t\telse if (str.charAt(i) == 'l' &amp;&amp; i &lt; str.length() - 1) {\t\t\t\tif (str.charAt(i+1) == 'j') {\t\t\t\t\ti++;\t\t\t\t}\t\t\t}\t\t\t\t\t\t\t\t\telse if (str.charAt(i) == 'n' &amp;&amp; i &lt; str.length() - 1) {\t\t\t\tif (str.charAt(i+1) == 'j') {\t\t\t\t\ti++;\t\t\t\t} \t\t\t}\t\t\t\t\t\t\t\t\telse if (str.charAt(i) == 's' &amp;&amp; i &lt; str.length() - 1) {\t\t\t\tif (str.charAt(i+1) == '=') {\t\t\t\t\ti++;\t\t\t\t} \t\t\t}\t\t\t\t\t\t\t\t\telse if (str.charAt(i) == 'z' &amp;&amp; i &lt; str.length() - 1) {\t\t\t\tif (str.charAt(i+1) == '=') {\t\t\t\t\ti++;\t\t\t\t} \t\t\t}\t\t\t\t\t\tcount++;\t\t\t\t\t}// end for\t\t\t\tSystem.out.println(count);\t\t\t}// end main}// end class",
        "url": "/b2941"
    }
    ,
    
    "b1157": {
        "title": "[백준] 1157번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "단어 공부문제  알파벳 대소문자로 된 단어가 주어지면, 이 단어에서 가장 많이 사용된 알파벳이 무엇인지 알아내는 프로그램을 작성하시오. 단, 대문자와 소문자를 구분하지 않는다.입력  첫째 줄에 알파벳 대소문자로 이루어진 단어가 주어진다. 주어지는 단어의 길이는 1,000,000을 넘지 않는다.출력  첫째 줄에 이 단어에서 가장 많이 사용된 알파벳을 대문자로 출력한다. 단, 가장 많이 사용된 알파벳이 여러 개 존재하는 경우에는 ?를 출력한다.예제 입력 1Mississipi예제 출력 1?예제 입력 2zZa예제 출력 2Z풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main {\t\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\t\t\tString str = br.readLine();\t\t\t\tint[] arr = new int[26];\t\t\t\tfor (int i = 0; i &lt; str.length(); i++) {\t\t\tif (str.charAt(i) &gt;= 'A' &amp;&amp; str.charAt(i) &lt;= 'Z' ) {\t\t\t\tarr[str.charAt(i) - 'A']++;\t\t\t}else {\t\t\t\tarr[str.charAt(i) - 'a']++;\t\t\t}\t\t}\t\t\t\tint max = 0;\t\tchar ch = '?';\t\t\t\tfor (int i = 0; i &lt; arr.length; i++) {\t\t\tif(max &lt; arr[i]) {\t\t\t\tmax = arr[i];\t\t\t\tch = (char)(i + 'A');\t\t\t}else if(max == arr[i]) {\t\t\t\tch = '?';\t\t\t}\t\t}\t\t\t\tSystem.out.print(ch);\t}}",
        "url": "/b1157"
    }
    ,
    
    "b10988": {
        "title": "[백준] 10988번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "팰린드롬인지 확인하기문제      알파벳 소문자로만 이루어진 단어가 주어진다. 이때, 이 단어가 팰린드롬인지 아닌지 확인하는 프로그램을 작성하시오.        팰린드롬이란 앞으로 읽을 때와 거꾸로 읽을 때 똑같은 단어를 말한다.        level, noon은 팰린드롬이고, baekjoon, online, judge는 팰린드롬이 아니다.  입력  첫째 줄에 단어가 주어진다. 단어의 길이는 1보다 크거나 같고, 100보다 작거나 같으며, 알파벳 소문자로만 이루어져 있다.출력  첫째 줄에 팰린드롬이면 1, 아니면 0을 출력한다.예제 입력 1level예제 출력 11예제 입력 2baekjoon예제 출력 20풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main {\t\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tString word = br.readLine();\t\tStringBuilder sb = new StringBuilder(word);\t\tString reverse = sb.reverse().toString();\t\t\t\tif (word.equals(reverse)) System.out.println(1);\t\telse System.out.println(0);\t\t\t}}",
        "url": "/b10988"
    }
    ,
    
    "b2444": {
        "title": "[백준] 2444번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "별 찍기 - 7문제  예제를 보고 규칙을 유추한 뒤에 별을 찍어 보세요.입력  첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다.출력  첫째 줄부터 2×N-1번째 줄까지 차례대로 별을 출력한다.예제 입력 15예제 출력 1    *   ***  ***** **************** *******  *****   ***    *풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main {\tpublic static void main(String[] args) throws NumberFormatException, IOException{\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint N = Integer.parseInt(br.readLine());\t\tStringBuilder sb = new StringBuilder();\t\t\t\tfor (int i = 1; i &lt;= N; i++) {\t\t\tfor (int j = 1; j &lt;= N - i; j++) {\t\t\t\tsb.append(\" \");\t\t\t}\t\t\tfor (int j = 1; j &lt;= 2*i - 1; j++) {\t\t\t\tsb.append(\"*\");\t\t\t}\t\t\tsb.append(\"\\n\");\t\t}\t\t\t\tfor (int i = N - 1; i &gt;= 1; i--) {            for (int j = 1; j &lt;= N - i; j++) {                sb.append(\" \");            }            for (int j = 1; j &lt;= 2*i - 1; j++) {                sb.append(\"*\");            }            sb.append(\"\\n\");        }\t\t\t\tSystem.out.println(sb);\t}}",
        "url": "/b2444"
    }
    ,
    
    "b3003": {
        "title": "[백준] 3003번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "새싹문제      동혁이는 오래된 창고를 뒤지다가 낡은 체스판과 피스를 발견했다.        체스판의 먼지를 털어내고 걸레로 닦으니 그럭저럭 쓸만한 체스판이 되었다. 하지만, 검정색 피스는 모두 있었으나, 흰색 피스는 개수가 올바르지 않았다.        체스는 총 16개의 피스를 사용하며, 킹 1개, 퀸 1개, 룩 2개, 비숍 2개, 나이트 2개, 폰 8개로 구성되어 있다.        동혁이가 발견한 흰색 피스의 개수가 주어졌을 때, 몇 개를 더하거나 빼야 올바른 세트가 되는지 구하는 프로그램을 작성하시오.  입력  첫째 줄에 동혁이가 찾은 흰색 킹, 퀸, 룩, 비숍, 나이트, 폰의 개수가 주어진다. 이 값은 0보다 크거나 같고 10보다 작거나 같은 정수이다.출력  첫째 줄에 입력에서 주어진 순서대로 몇 개의 피스를 더하거나 빼야 되는지를 출력한다. 만약 수가 양수라면 동혁이는 그 개수 만큼 피스를 더해야 하는 것이고, 음수라면 제거해야 하는 것이다.예제 입력 10 1 2 2 2 7예제 출력 11 0 0 0 0 1예제 입력 22 1 2 1 2 1예제 출력 2-1 0 0 1 0 7풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main {\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\t\t\tStringTokenizer st = new StringTokenizer(br.readLine(), \" \");\t\tint king = 1;\t\tint queen = 1;\t\tint rook = 2;\t\tint bishop = 2;\t\tint knight = 2;\t\tint pawn = 8;\t\t\t\tking = king - Integer.parseInt(st.nextToken());\t\tqueen = queen - Integer.parseInt(st.nextToken());\t\trook = rook - Integer.parseInt(st.nextToken());\t\tbishop = bishop - Integer.parseInt(st.nextToken());\t\tknight = knight - Integer.parseInt(st.nextToken());\t\tpawn = pawn - Integer.parseInt(st.nextToken());\t\t\t\tSystem.out.print(king + \" \");\t\tSystem.out.print(queen + \" \");\t\tSystem.out.print(rook + \" \");\t\tSystem.out.print(bishop + \" \");\t\tSystem.out.print(knight + \" \");\t\tSystem.out.print(pawn + \" \");\t\t\t}}",
        "url": "/b3003"
    }
    ,
    
    "b25083": {
        "title": "[백준] 25083번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "새싹문제  아래 예제와 같이 새싹을 출력하시오.입력  입력은 없다.출력  새싹을 출력한다.예제 입력 1예제 출력 1         ,r'\"7r`-_   ,'  ,/ \\. \". L_r'   `~\\/      |      |풀이1public class Main {\t\tpublic static void main(String[] args) {\t\t\t\tSystem.out.println(\"         ,r'\\\"7\");\t\tSystem.out.println(\"r`-_   ,'  ,/\");\t\tSystem.out.println(\" \\\\. \\\". L_r'\");\t\tSystem.out.println(\"   `~\\\\/\");\t\tSystem.out.println(\"      |\");\t\tSystem.out.println(\"      |\");\t}// end main} //end class",
        "url": "/b25083"
    }
    ,
    
    "b9086": {
        "title": "[백준] 9086번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "문자열문제  문자열을 입력으로 주면 문자열의 첫 글자와 마지막 글자를 출력하는 프로그램을 작성하시오.입력  입력의 첫 줄에는 테스트 케이스의 개수 T(1 ≤ T ≤ 10)가 주어진다. 각 테스트 케이스는 한 줄에 하나의 문자열이 주어진다. 문자열은 알파벳 A~Z 대문자로 이루어지며 알파벳 사이에 공백은 없으며 문자열의 길이는 1000보다 작다.출력  각 테스트 케이스에 대해서 주어진 문자열의 첫 글자와 마지막 글자를 연속하여 출력한다.예제 입력 13ACDKJFOWIEGHEOAB예제 출력 1AEOOAB풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main {\t\tpublic static void main(String[] args) throws NumberFormatException, IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint N = Integer.parseInt(br.readLine());\t\t\t\tfor (int i = 0; i &lt; N; i++) {\t\t\tString str = br.readLine();\t\t\tSystem.out.println(str.charAt(0)+\"\"+str.charAt(str.length()-1));\t\t}\t\t\t\t\t}}",
        "url": "/b9086"
    }
    ,
    
    "b2743": {
        "title": "[백준] 2743번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "단어 길이 재기문제  알파벳으로만 이루어진 단어를 입력받아, 그 길이를 출력하는 프로그램을 작성하시오.입력  첫째 줄에 영어 소문자와 대문자로만 이루어진 단어가 주어진다. 단어의 길이는 최대 100이다.출력  첫째 줄에 입력으로 주어진 단어의 길이를 출력한다.예제 입력 1pulljima예제 출력 18풀이1import java.util.Scanner;public class Main {\t\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\tString str = sc.next();\t\t\t\tSystem.out.println(str.length());\t\t\t}}",
        "url": "/b2743"
    }
    ,
    
    "b27866": {
        "title": "[백준] 27866번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "문자와 문자열문제  단어 S와 정수 i가 주어졌을 때, S의 i번째 글자를 출력하는 프로그램을 작성하시오.입력      첫째 줄에 영어 소문자와 대문자로만 이루어진 단어 S가 주어진다. 단어의 길이는 최대 1000이다.        둘째 줄에 정수 i가 주어진다.  출력  S의 i번째 글자를 출력한다.예제 입력 1Sprout3예제 출력 1r예제 입력 2shiftpsh6예제 출력 2p풀이1import java.util.Scanner;public class Main {\t\t\t\tpublic static void main(String[] args) {\t\t\t\t\t\tScanner sc = new Scanner(System.in);\t\t\tString S = sc.next();\t\t\tint i = sc.nextInt();\t\t\t\t\t\tSystem.out.println(S.charAt(i-1));\t\t\t\t\t}\t\t}",
        "url": "/b27866"
    }
    ,
    
    "b11718": {
        "title": "[백준] 11718번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "그대로 출력하기문제  입력 받은 대로 출력하는 프로그램을 작성하시오.입력  입력이 주어진다. 입력은 최대 100줄로 이루어져 있고, 알파벳 소문자, 대문자, 공백, 숫자로만 이루어져 있다. 각 줄은 100글자를 넘지 않으며, 빈 줄은 주어지지 않는다. 또, 각 줄은 공백으로 시작하지 않고, 공백으로 끝나지 않는다.출력  입력받은 그대로 출력한다.예제 입력 1HelloBaekjoonOnline Judge예제 출력 1HelloBaekjoonOnline Judge풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main {\t\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\t \t\tString str = \"\";\t\t \t\twhile ((str = br.readLine()) != null) {\t\t    System.out.println(str);\t\t}\t\t\t}}",
        "url": "/b11718"
    }
    ,
    
    "b5622": {
        "title": "[백준] 5622번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "다이얼문제      상근이의 할머니는 아래 그림과 같이 오래된 다이얼 전화기를 사용한다.        전화를 걸고 싶은 번호가 있다면, 숫자를 하나를 누른 다음에 금속 핀이 있는 곳 까지 시계방향으로 돌려야 한다. 숫자를 하나 누르면 다이얼이 처음 위치로 돌아가고, 다음 숫자를 누르려면 다이얼을 처음 위치에서 다시 돌려야 한다.        숫자 1을 걸려면 총 2초가 필요하다. 1보다 큰 수를 거는데 걸리는 시간은 이보다 더 걸리며, 한 칸 옆에 있는 숫자를 걸기 위해선 1초씩 더 걸린다.        상근이의 할머니는 전화 번호를 각 숫자에 해당하는 문자로 외운다. 즉, 어떤 단어를 걸 때, 각 알파벳에 해당하는 숫자를 걸면 된다. 예를 들어, UNUCIC는 868242와 같다.        할머니가 외운 단어가 주어졌을 때, 이 전화를 걸기 위해서 필요한 최소 시간을 구하는 프로그램을 작성하시오.  입력  첫째 줄에 알파벳 대문자로 이루어진 단어가 주어진다. 단어의 길이는 2보다 크거나 같고, 15보다 작거나 같다.출력  첫째 줄에 다이얼을 걸기 위해서 필요한 최소 시간을 출력한다.예제 입력 1WA예제 출력 113예제 입력 2UNUCIC예제 출력 236풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main {\t\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\t\t\tString str = br.readLine();\t\tint sum = 0;\t\t\t\tfor (int i = 0; i &lt; str.length(); i++) {\t\t\tif(str.charAt(i) &gt;= 'A' &amp;&amp; str.charAt(i) &lt;= 'C') {\t\t\t\tsum += 3;\t\t\t}\t\t\telse if(str.charAt(i) &gt;= 'D' &amp;&amp; str.charAt(i) &lt;= 'F') {\t\t\t\tsum += 4;\t\t\t}\t\t\telse if(str.charAt(i) &gt;= 'G' &amp;&amp; str.charAt(i) &lt;= 'I') {\t\t\t\tsum += 5;\t\t\t}\t\t\telse if(str.charAt(i) &gt;= 'J' &amp;&amp; str.charAt(i) &lt;= 'L') {\t\t\t\tsum += 6;\t\t\t}\t\t\telse if(str.charAt(i) &gt;= 'M' &amp;&amp; str.charAt(i) &lt;= 'O') {\t\t\t\tsum += 7;\t\t\t}\t\t\telse if(str.charAt(i) &gt;= 'P' &amp;&amp; str.charAt(i) &lt;= 'S') {\t\t\t\tsum += 8;\t\t\t}\t\t\telse if(str.charAt(i) &gt;= 'T' &amp;&amp; str.charAt(i) &lt;= 'V') {\t\t\t\tsum += 9;\t\t\t}\t\t\telse if(str.charAt(i) &gt;= 'W' &amp;&amp; str.charAt(i) &lt;= 'Z') {\t\t\t\tsum += 10;\t\t\t}\t\t}\t\tSystem.out.println(sum);\t\t\t\t\t}}",
        "url": "/b5622"
    }
    ,
    
    "b2908": {
        "title": "[백준] 2908번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "상수문제      상근이의 동생 상수는 수학을 정말 못한다. 상수는 숫자를 읽는데 문제가 있다. 이렇게 수학을 못하는 상수를 위해서 상근이는 수의 크기를 비교하는 문제를 내주었다. 상근이는 세 자리 수 두 개를 칠판에 써주었다. 그 다음에 크기가 큰 수를 말해보라고 했다.        상수는 수를 다른 사람과 다르게 거꾸로 읽는다. 예를 들어, 734와 893을 칠판에 적었다면, 상수는 이 수를 437과 398로 읽는다. 따라서, 상수는 두 수중 큰 수인 437을 큰 수라고 말할 것이다.        두 수가 주어졌을 때, 상수의 대답을 출력하는 프로그램을 작성하시오.  입력  첫째 줄에 상근이가 칠판에 적은 두 수 A와 B가 주어진다. 두 수는 같지 않은 세 자리 수이며, 0이 포함되어 있지 않다.출력  첫째 줄에 상수의 대답을 출력한다.예제 입력 1734 893예제 출력 1437예제 입력 2221 231예제 출력 2132예제 입력 3839 237예제 출력 3938풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main {\t\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tStringTokenizer st = new StringTokenizer(br.readLine(), \" \");\t\t\t\tint N = Integer.parseInt(st.nextToken());\t\tint M = Integer.parseInt(st.nextToken());\t\t\t\tint X = (N/100) + (((N%100)/10)*10) + ((N%10)*100);\t\tint Y = (M/100) + (((M%100)/10)*10) + ((M%10)*100);\t\t\t\tint max = (X &gt; Y) ? X : Y;\t\t\t\tSystem.out.println(max);\t\t\t}\t}",
        "url": "/b2908"
    }
    ,
    
    "b1152": {
        "title": "[백준] 1152번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "단어의 개수문제  영어 대소문자와 공백으로 이루어진 문자열이 주어진다. 이 문자열에는 몇 개의 단어가 있을까? 이를 구하는 프로그램을 작성하시오. 단, 한 단어가 여러 번 등장하면 등장한 횟수만큼 모두 세어야 한다.입력  첫 줄에 영어 대소문자와 공백으로 이루어진 문자열이 주어진다. 이 문자열의 길이는 1,000,000을 넘지 않는다. 단어는 공백 한 개로 구분되며, 공백이 연속해서 나오는 경우는 없다. 또한 문자열은 공백으로 시작하거나 끝날 수 있다.출력  첫째 줄에 단어의 개수를 출력한다.예제 입력 1The Curious Case of Benjamin Button예제 출력 16예제 입력 2 The first character is a blank예제 출력 26예제 입력 3The last character is a blank 예제 출력 36풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main {\t\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\t\t\tStringTokenizer st = new StringTokenizer(br.readLine(), (\" \"));\t\t\t\tSystem.out.println(st.countTokens());\t}}",
        "url": "/b1152"
    }
    ,
    
    "b2675": {
        "title": "[백준] 2675번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "문자열 반복문제      문자열 S를 입력받은 후에, 각 문자를 R번 반복해 새 문자열 P를 만든 후 출력하는 프로그램을 작성하시오. 즉, 첫 번째 문자를 R번 반복하고, 두 번째 문자를 R번 반복하는 식으로 P를 만들면 된다. S에는 QR Code “alphanumeric” 문자만 들어있다.        QR Code “alphanumeric” 문자는 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ$%*+-./: 이다.  입력  첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 1,000)가 주어진다. 각 테스트 케이스는 반복 횟수 R(1 ≤ R ≤ 8), 문자열 S가 공백으로 구분되어 주어진다. S의 길이는 적어도 1이며, 20글자를 넘지 않는다.출력  각 테스트 케이스에 대해 P를 출력한다.예제 입력 123 ABC5 /HTP예제 출력 1AAABBBCCC/////HHHHHTTTTTPPPPP풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main {\t\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\t\t\tint N = Integer.parseInt(br.readLine());\t\t\t\tfor (int i = 0; i &lt; N; i++) {\t\t\t\t\t\tString[] S = br.readLine().split(\" \");\t\t\t\t\t\tint M = Integer.parseInt(S[0]);\t\t\tString str = S[1];\t\t\t\t\t\tfor (int j = 0; j &lt; str.length(); j++) {\t\t\t\tfor (int k = 0; k &lt; M; k++) {\t\t\t\t\tSystem.out.print(str.charAt(j));\t\t\t\t}\t\t\t}\t\t\tSystem.out.println();\t\t}\t\t\t}}",
        "url": "/b2675"
    }
    ,
    
    "b10809": {
        "title": "[백준] 10809번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "알파벳 찾기문제  알파벳 소문자로만 이루어진 단어 S가 주어진다. 각각의 알파벳에 대해서, 단어에 포함되어 있는 경우에는 처음 등장하는 위치를, 포함되어 있지 않은 경우에는 -1을 출력하는 프로그램을 작성하시오.입력  첫째 줄에 단어 S가 주어진다. 단어의 길이는 100을 넘지 않으며, 알파벳 소문자로만 이루어져 있다.출력      각각의 알파벳에 대해서, a가 처음 등장하는 위치, b가 처음 등장하는 위치, … z가 처음 등장하는 위치를 공백으로 구분해서 출력한다.        만약, 어떤 알파벳이 단어에 포함되어 있지 않다면 -1을 출력한다. 단어의 첫 번째 글자는 0번째 위치이고, 두 번째 글자는 1번째 위치이다.  예제 입력 1baekjoon예제 출력 11 0 -1 -1 2 -1 -1 -1 -1 4 3 -1 -1 7 5 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main {\t\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tString str = br.readLine();\t\t\t\tint[] arr = new int[26];\t\t\t\tfor (int i = 0; i &lt; arr.length; i++) {\t\t\tarr[i] = -1;\t\t}\t\t\t\tfor (int i = 0; i &lt; str.length(); i++) {\t\t\t\t\t\tif(arr[str.charAt(i) - 'a'] == -1) {\t\t\t\tarr[str.charAt(i) - 'a'] = i;\t\t\t}\t\t}\t\t\t\tfor(int val : arr) {\t\t\tSystem.out.println(val);\t\t}\t}}",
        "url": "/b10809"
    }
    ,
    
    "b11720": {
        "title": "[백준] 11720번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "숫자의 합문제  N개의 숫자가 공백 없이 쓰여있다. 이 숫자를 모두 합해서 출력하는 프로그램을 작성하시오.입력  첫째 줄에 숫자의 개수 N (1 ≤ N ≤ 100)이 주어진다. 둘째 줄에 숫자 N개가 공백없이 주어진다.출력  입력으로 주어진 숫자 N개의 합을 출력한다.예제 입력 111예제 출력 11예제 입력 2554321예제 출력 215풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main {\t\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\t\t\tint N = Integer.parseInt(br.readLine());\t\tString number = br.readLine();\t\t\t\tint sum = 0;\t\t\t\tfor (int i = 0; i &lt; N; i++) {\t\t\tsum += number.charAt(i) - '0';\t\t}\t\t\t\tSystem.out.println(sum);\t}\t\t}",
        "url": "/b11720"
    }
    ,
    
    "b11654": {
        "title": "[백준] 11654번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "아스키 코드문제  알파벳 소문자, 대문자, 숫자 0-9중 하나가 주어졌을 때, 주어진 글자의 아스키 코드값을 출력하는 프로그램을 작성하시오.입력  알파벳 소문자, 대문자, 숫자 0-9 중 하나가 첫째 줄에 주어진다.출력  입력으로 주어진 글자의 아스키 코드 값을 출력한다.예제 입력 1A예제 출력 165예제 입력 2z예제 출력 2122풀이1import java.util.Scanner;public class Main {\t\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\t\t\tString str = sc.next();\t\t\t\tsc.close();\t\t\t\tSystem.out.println((int)(str.charAt(0)));\t\t\t\t\t}}",
        "url": "/b11654"
    }
    ,
    
    "exponentiation-by-squaring": {
        "title": "[알고리즘] Exponentiation by Squaring (지수의 분할 정복)",
            "author": "jjaemin0224",
            "category": "",
            "content": "1. Exponentiation by Squaring지수의 분할 정복(Exponentiation by Squaring)는 주어진 지수를 작은 지수들로 분할하고, 작은 지수들로부터 제곱 연산을 통해 계산을 수행하는 알고리즘을 의미합니다. 지수의 분할 정복은 큰 지수를 작은 지수들로 나누어 계산하는 방법입니다. 이 방법은 제곱 연산을 더 효율적으로 수행할 수 있도록 도와줍니다.Exponentiation by Squaring의 동작 과정은 다음과 같습니다:  기저 조건 설정 :          제곱 연산을 수행하는 함수에는 기저 조건이 필요합니다. 일반적으로 지수(exponent)가 0일 때는 결과로 1을 반환하도록 설정합니다.        지수의 홀수/짝수 확인:          주어진 지수가 홀수인지 짝수인지 확인합니다.        홀수인 경우 :                  지수를 반으로 나눕니다. (지수를 2로 나눈 몫과 나머지를 구합니다.)        제곱 연산을 수행하기 위해 밑(base)을 제곱합니다. (base * base)        결과를 저장할 변수에 밑(base)을 곱합니다.        반으로 나눈 지수와 새로운 밑(base)으로 재귀적으로 제곱 연산을 수행합니다.              짝수인 경우 :                  지수를 반으로 나눕니다. (지수를 2로 나눈 몫과 나머지를 구합니다.)        제곱 연산을 수행하기 위해 밑(base)을 제곱합니다. (base * base)        새로운 밑(base)으로 재귀적으로 제곱 연산을 수행합니다.              최종 결과 반환 :          모든 재귀 호출이 완료되면 최종 결과를 반환합니다.      지수의 분할 정복을 사용하면 지수(exponent)가 큰 경우에도 더 효율적으로 제곱 연산을 수행할 수 있습니다. 지수의 분할 정복은 주로 고속 거듭제곱 알고리즘 등에서 사용되며, 계산 효율성을 높이는 데 도움을 줍니다.이해해보기예를 들어 2의 10승을 표현해보면 2 x 2 x 2 x 2 x 2 x 2 x 2 x 2 x 2 x 2 입니다.   2 x 2 x 2 x 2 x 2 x 2 x 2 x 2 x 2 x 2 =&gt; (2의 10승)  4 x 4 x 4 x 4 x 4 =&gt; (4의 5승)  4 x 16 x 16 =&gt; (4 x (16의 2승))2. 활용 (비재귀)public static int power(int base, int exponent) {        int result = 1;    while (exponent &gt; 0) {        if (exponent % 2 == 1) {            result *= base;        }        base *= base;        exponent /= 2;    }    return result;}위 코드에서는 ‘result’ 변수를 사용하여 최종 결과를 저장하고, ‘while’ 반복문을 통해 지수의 분할 정복을 수행합니다.  ‘result’를 1로 초기화합니다. 이는 제곱 연산 결과를 누적하여 저장하기 위한 변수입니다.  ‘exponent’가 0보다 큰 동안 반복합니다. 지수를 2로 나누면서 분할 정복을 수행합니다.  ‘exponent’가 홀수인 경우 ‘result’에 ‘base’를 곱합니다. 이는 홀수 지수를 처리하는 부분입니다.  ‘base’를 제곱하여 갱신합니다. 이는 짝수 지수를 처리하는 부분입니다.  ‘exponent’를 2로 나눕니다. 이는 지수를 절반으로 줄여가며 분할 정복을 수행하는 부분입니다.  ‘exponent’가 0이 되면 반복문을 종료하고 ‘result’를 반환합니다.3. 활용 (재귀)public static int power(int base, int exponent) {        if (exponent == 0) {        return 1;    }    if (exponent &amp; 2 == 1) {        int halfPower = power(base, exponent / 2);        return base * halfPower * halfPower;    }    else {        int halfPower = power(base, exponent / 2);        return halfPower * halfPower;    }}위 코드에서 ‘power’ 함수는 밑(base)과 지수(exponent)를 입력받아 제곱 연산을 수행하는 함수입니다.  기저 조건으로 ‘exponent’가 0이면 항상 1을 반환합니다. 이는 모든 수를 0제곱했을 때 결과가 1이 되는 성질을 반영한 것입니다.  ‘exponent’가 홀수일 때는 밑(base)을 그대로 사용하지 않고, 밑의 절반의 제곱을 구한 후 다시 밑과 곱하여 결과를 반환합니다. 이렇게 함으로써 홀수 지수를 짝수로 만들어 계산의 효율성을 높일 수 있습니다.  ‘exponent’가 짝수일 때는 밑의 절반의 제곱을 구한 후 그 결과를 반환합니다. 이렇게 함으로써 제곱 연산을 더 적게 수행하여 계산의 효율성을 높일 수 있습니다.",
        "url": "/exponentiation-by-squaring"
    }
    ,
    
    "b1546": {
        "title": "[백준] 1546번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "평균문제      세준이는 기말고사를 망쳤다. 세준이는 점수를 조작해서 집에 가져가기로 했다. 일단 세준이는 자기 점수 중에 최댓값을 골랐다. 이 값을 M이라고 한다. 그리고 나서 모든 점수를 점수/M*100으로 고쳤다.        예를 들어, 세준이의 최고점이 70이고, 수학점수가 50이었으면 수학점수는 50/70*100이 되어 71.43점이 된다.        세준이의 성적을 위의 방법대로 새로 계산했을 때, 새로운 평균을 구하는 프로그램을 작성하시오.  입력  첫째 줄에 시험 본 과목의 개수 N이 주어진다. 이 값은 1000보다 작거나 같다. 둘째 줄에 세준이의 현재 성적이 주어진다. 이 값은 100보다 작거나 같은 음이 아닌 정수이고, 적어도 하나의 값은 0보다 크다.출력  첫째 줄에 새로운 평균을 출력한다. 실제 정답과 출력값의 절대오차 또는 상대오차가 10-2 이하이면 정답이다.예제 입력 1340 80 60예제 출력 175.0예제 입력 2310 20 30예제 출력 266.666667풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main {\t\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\t\t\tint N = Integer.parseInt(br.readLine());\t\tStringTokenizer st = new StringTokenizer(br.readLine(), \" \");\t\tint[] arr = new int[N];\t\tint max = 0;\t\tint sum = 0;\t\t\t\tfor (int i = 0; i &lt; N; i++) {\t\t\tarr[i] = Integer.parseInt(st.nextToken());\t\t\tsum += arr[i];\t\t\tif (max &lt; arr[i]) {\t\t\t\tmax = arr[i];\t\t\t}\t\t}\t\t\t\tbr.close();\t\t\t\tSystem.out.println((((double)sum*100)/max)/N);\t}}",
        "url": "/b1546"
    }
    ,
    
    "b10811": {
        "title": "[백준] 10811번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "바구니 뒤집기문제      도현이는 바구니를 총 N개 가지고 있고, 각각의 바구니에는 1번부터 N번까지 번호가 순서대로 적혀져 있다. 바구니는 일렬로 놓여져 있고, 가장 왼쪽 바구니를 1번째 바구니, 그 다음 바구니를 2번째 바구니, …, 가장 오른쪽 바구니를 N번째 바구니라고 부른다.        도현이는 앞으로 M번 바구니의 순서를 역순으로 만들려고 한다. 도현이는 한 번 순서를 역순으로 바꿀 때, 순서를 역순으로 만들 범위를 정하고, 그 범위에 들어있는 바구니의 순서를 역순으로 만든다.        바구니의 순서를 어떻게 바꿀지 주어졌을 때, M번 바구니의 순서를 역순으로 만든 다음, 바구니에 적혀있는 번호를 가장 왼쪽 바구니부터 출력하는 프로그램을 작성하시오.  입력      첫째 줄에 N (1 ≤ N ≤ 100)과 M (1 ≤ M ≤ 100)이 주어진다.        둘째 줄부터 M개의 줄에는 바구니의 순서를 역순으로 만드는 방법이 주어진다. 방법은 i j로 나타내고, 왼쪽으로부터 i번째 바구니부터 j번째 바구니의 순서를 역순으로 만든다는 뜻이다. (1 ≤ i ≤ j ≤ N)        도현이는 입력으로 주어진 순서대로 바구니의 순서를 바꾼다.  출력  모든 순서를 바꾼 다음에, 가장 왼쪽에 있는 바구니부터 바구니에 적혀있는 순서를 공백으로 구분해 출력한다.예제 입력 15 41 23 41 42 2예제 출력 13 4 1 2 5풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main {\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tStringTokenizer st = new StringTokenizer(br.readLine(), \" \");\t\t\t\tint N = Integer.parseInt(st.nextToken());\t\tint M = Integer.parseInt(st.nextToken());\t\t\t\tint[] arr = new int[N];\t\t\t\tfor (int i = 0; i &lt; N; i++) {\t\t\tarr[i] = i+1;\t\t}\t\t\t\tfor (int i = 0; i &lt; M; i++) {\t\t\tst = new StringTokenizer(br.readLine(), \" \");\t\t\tint X = Integer.parseInt(st.nextToken());\t\t\tint Y = Integer.parseInt(st.nextToken());\t\t\t\t\t\twhile(X &lt;= Y) {\t\t\t\tint temp = arr[X-1];\t\t\t\tarr[X-1] = arr[Y-1];\t\t\t\tarr[Y-1] = temp;\t\t\t\tX++;\t\t\t\tY--;\t\t\t}\t\t}\t\t\t\tfor (int i = 0; i &lt; arr.length; i++) {\t\t\tSystem.out.print(arr[i] + \" \");\t\t}\t\t\t\t\t}\t}",
        "url": "/b10811"
    }
    ,
    
    "b3052": {
        "title": "[백준] 3052번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "나머지문제      두 자연수 A와 B가 있을 때, A%B는 A를 B로 나눈 나머지 이다. 예를 들어, 7, 14, 27, 38을 3으로 나눈 나머지는 1, 2, 0, 2이다.        수 10개를 입력받은 뒤, 이를 42로 나눈 나머지를 구한다. 그 다음 서로 다른 값이 몇 개 있는지 출력하는 프로그램을 작성하시오.  입력  첫째 줄부터 열번째 줄 까지 숫자가 한 줄에 하나씩 주어진다. 이 숫자는 1,000보다 작거나 같고, 음이 아닌 정수이다.출력  첫째 줄에, 42로 나누었을 때, 서로 다른 나머지가 몇 개 있는지 출력한다.예제 입력 112345678910예제 출력 110  각 수를 42로 나눈 나머지는 1,2,3,4,5,6,7,8,9,10이다.예제 입력 242842524208401264284420126예제 출력21  모든 수를 42로 나눈 나머지는 0이다.예제 입력339404142434482838485예제 출력36  각 수를 42로 나눈 나머지는 39, 40, 41, 0, 1, 2, 40, 41, 0, 1이다. 서로 다른 값은 6개가 있다.풀이1import java.util.HashSet;import java.util.Scanner;public class Main {\t\tpublic static void main(String[] args) {\t\tScanner sc = new Scanner(System.in);\t\t\t\tHashSet&lt;Integer&gt; hs = new HashSet&lt;&gt;();\t\t\t\tfor (int i = 0; i &lt; 10; i++) {\t\t\ths.add(sc.nextInt()%42);\t\t}\t\t\t\tsc.close();\t\t\t\tSystem.out.println(hs.size());\t\t\t\t\t} // end main} //end class풀이2import java.util.Scanner;public class Main {\t\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\t\t\tint[] arr = new int[] {sc.nextInt(), sc.nextInt(), sc.nextInt(), \t\t\t\t               sc.nextInt(), sc.nextInt(), sc.nextInt(), \t\t\t\t               sc.nextInt(), sc.nextInt(), sc.nextInt(), sc.nextInt()};\t\t\t\tsc.close();\t\t\t\tint[] count = new int[42];\t\t\t\tint num = 0;\t\t\t\tfor (int i = 0; i &lt; arr.length; i++) {\t\t\tcount[arr[i]%42]++;\t\t}\t\t\t\tfor(int e : count) {\t\t\tif(e != 0) {\t\t\t\tnum++;\t\t\t}\t\t}\t\t\t\tSystem.out.println(num);\t}}",
        "url": "/b3052"
    }
    ,
    
    "b5597": {
        "title": "[백준] 5597번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "과제 안 내신 분..?문제      X대학 M교수님은 프로그래밍 수업을 맡고 있다. 교실엔 학생이 30명이 있는데, 학생 명부엔 각 학생별로 1번부터 30번까지 출석번호가 붙어 있다.        교수님이 내준 특별과제를 28명이 제출했는데, 그 중에서 제출 안 한 학생 2명의 출석번호를 구하는 프로그램을 작성하시오.  입력  입력은 총 28줄로 각 제출자(학생)의 출석번호 n(1 ≤ n ≤ 30)가 한 줄에 하나씩 주어진다. 출석번호에 중복은 없다.출력  출력은 2줄이다. 1번째 줄엔 제출하지 않은 학생의 출석번호 중 가장 작은 것을 출력하고, 2번째 줄에선 그 다음 출석번호를 출력한다.예제 입력 13145796101112131415161718192021222324252627282930예제 출력 128예제 입력 29306121020211175284182917192713162614232215312425예제 출력228풀이1import java.util.Scanner;public class Main {\t\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\tint[] arr = new int[30];\t\t\t\tfor (int i = 0; i &lt; 28; i++) {\t\t\tarr[sc.nextInt() - 1] = 1;\t\t}\t\t\t\tfor (int i = 0; i &lt; arr.length; i++) {\t\t\tif (arr[i] != 1) System.out.println(i + 1);\t\t}\t\t\t}}",
        "url": "/b5597"
    }
    ,
    
    "b10813": {
        "title": "[백준] 10813번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "공 바꾸기문제      도현이는 바구니를 총 N개 가지고 있고, 각각의 바구니에는 1번부터 N번까지 번호가 매겨져 있다. 바구니에는 공이 1개씩 들어있고, 처음에는 바구니에 적혀있는 번호와 같은 번호가 적힌 공이 들어있다.        도현이는 앞으로 M번 공을 바꾸려고 한다. 도현이는 공을 바꿀 바구니 2개를 선택하고, 두 바구니에 들어있는 공을 서로 교환한다.        공을 어떻게 바꿀지가 주어졌을 때, M번 공을 바꾼 이후에 각 바구니에 어떤 공이 들어있는지 구하는 프로그램을 작성하시오.  입력      첫째 줄에 N (1 ≤ N ≤ 100)과 M (1 ≤ M ≤ 100)이 주어진다.        둘째 줄부터 M개의 줄에 걸쳐서 공을 교환할 방법이 주어진다. 각 방법은 두 정수 i j로 이루어져 있으며, i번 바구니와 j번 바구니에 들어있는 공을 교환한다는 뜻이다. (1 ≤ i ≤ j ≤ N)        도현이는 입력으로 주어진 순서대로 공을 교환한다.  출력  1번 바구니부터 N번 바구니에 들어있는 공의 번호를 공백으로 구분해 출력한다.예제 입력 15 41 23 41 42 2예제 출력 13 1 4 2 5풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main {\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tStringTokenizer st = new StringTokenizer(br.readLine(), \" \");\t\t\t\tint N = Integer.parseInt(st.nextToken());\t\tint M = Integer.parseInt(st.nextToken());\t\t\t\tint[] arr = new int[N];\t\tfor (int i = 0; i &lt; arr.length; i++) {\t\t\tarr[i] = i+1;\t\t}\t\t\t\tfor (int i = 0; i &lt; M; i++) {\t\t\tst = new StringTokenizer(br.readLine(), \" \");\t\t\tint x = Integer.parseInt(st.nextToken());\t\t\tint y = Integer.parseInt(st.nextToken());\t\t\t\t\t\tint a = arr[x-1];\t\t\tint b = arr[y-1];\t\t\t\t\t\tarr[x-1] = b;\t\t\tarr[y-1] = a;\t\t\t\t\t}\t\t\t\tfor (int i = 0; i &lt; arr.length; i++) {\t\t\tSystem.out.print(arr[i] + \" \");\t\t}\t\t\t}\t}",
        "url": "/b10813"
    }
    ,
    
    "b10810": {
        "title": "[백준] 10810번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "공 넣기문제      도현이는 바구니를 총 N개 가지고 있고, 각각의 바구니에는 1번부터 N번까지 번호가 매겨져 있다. 또, 1번부터 N번까지 번호가 적혀있는 공을 매우 많이 가지고 있다. 가장 처음 바구니에는 공이 들어있지 않으며, 바구니에는 공을 1개만 넣을 수 있다.        도현이는 앞으로 M번 공을 넣으려고 한다. 도현이는 한 번 공을 넣을 때, 공을 넣을 바구니 범위를 정하고, 정한 바구니에 모두 같은 번호가 적혀있는 공을 넣는다. 만약, 바구니에 공이 이미 있는 경우에는 들어있는 공을 빼고, 새로 공을 넣는다. 공을 넣을 바구니는 연속되어 있어야 한다.        공을 어떻게 넣을지가 주어졌을 때, M번 공을 넣은 이후에 각 바구니에 어떤 공이 들어 있는지 구하는 프로그램을 작성하시오.  입력      첫째 줄에 N (1 ≤ N ≤ 100)과 M (1 ≤ M ≤ 100)이 주어진다.        둘째 줄부터 M개의 줄에 걸쳐서 공을 넣는 방법이 주어진다. 각 방법은 세 정수 i j k로 이루어져 있으며, i번 바구니부터 j번 바구니까지에 k번 번호가 적혀져 있는 공을 넣는다는 뜻이다. 예를 들어, 2 5 6은 2번 바구니부터 5번 바구니까지에 6번 공을 넣는다는 뜻이다. (1 ≤ i ≤ j ≤ N, 1 ≤ k ≤ N)        도현이는 입력으로 주어진 순서대로 공을 넣는다.  출력  1번 바구니부터 N번 바구니에 들어있는 공의 번호를 공백으로 구분해 출력한다. 공이 들어있지 않은 바구니는 0을 출력한다.예제 입력 15 41 2 33 4 41 4 12 2 2예제 출력 11 2 1 1 0풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main {\t\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tStringTokenizer st = new StringTokenizer(br.readLine(), \" \");\t\tint M = Integer.parseInt(st.nextToken());\t\tint N = Integer.parseInt(st.nextToken());\t\t\t\tint[] arr = new int[M];\t\t\t\t\t\tfor (int i = 0; i &lt; N; i++) {\t\t\tst = new StringTokenizer(br.readLine(), \" \");\t\t\tint x = Integer.parseInt(st.nextToken());\t\t\tint y = Integer.parseInt(st.nextToken());\t\t\tint z = Integer.parseInt(st.nextToken());\t\t\t\t\t\tfor (int j = x; j &lt;= y; j++) {\t\t\t\tarr[j-1] = z;\t\t\t}\t\t\t\t\t}\t\t\t\tfor (int i = 0; i &lt; arr.length; i++) {\t\t\tSystem.out.print(arr[i] + \" \");\t\t}\t\t\t}}",
        "url": "/b10810"
    }
    ,
    
    "b2562": {
        "title": "[백준] 2562번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "최소, 최대문제      9개의 서로 다른 자연수가 주어질 때, 이들 중 최댓값을 찾고 그 최댓값이 몇 번째 수인지를 구하는 프로그램을 작성하시오.        예를 들어, 서로 다른 9개의 자연수        3, 29, 38, 12, 57, 74, 40, 85, 61        이 주어지면, 이들 중 최댓값은 85이고, 이 값은 8번째 수이다.  입력  첫째 줄부터 아홉 번째 줄까지 한 줄에 하나의 자연수가 주어진다. 주어지는 자연수는 100 보다 작다.출력  첫째 줄에 최댓값을 출력하고, 둘째 줄에 최댓값이 몇 번째 수인지를 출력한다.예제 입력 132938125774408561예제 출력 1858풀이1import java.util.Arrays;import java.util.Collections;import java.util.List;import java.util.Scanner;public class Main {\t\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\tList&lt;Integer&gt; list = Arrays.asList(sc.nextInt(), sc.nextInt(), sc.nextInt(),\t\t\t\t\t\t\t               sc.nextInt(), sc.nextInt(), sc.nextInt(),\t\t\t\t\t\t\t               sc.nextInt(), sc.nextInt(), sc.nextInt());\t\tsc.close();\t\t\t\tint max = Collections.max(list);\t\tint idx = list.indexOf(max) + 1;\t\t\t\tSystem.out.println(max + \"\\n\" + idx);\t\t\t}}풀이2import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main {\t\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\t\t\tint[] arr = new int[9];\t\tint max = 0;\t\tint index = 0;\t\t\t\tfor (int i = 0; i &lt; 9; i++) {\t\t\tarr[i] = Integer.parseInt(br.readLine());\t\t\tif (max &lt; arr[i]) {\t\t\t\tmax = arr[i];\t\t\t\tindex = i + 1;\t\t\t}\t\t}\t\t\t\tSystem.out.println(max + \"\\n\" + index);\t\t\t}}",
        "url": "/b2562"
    }
    ,
    
    "b10818": {
        "title": "[백준] 10818번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "최소, 최대문제  N개의 정수가 주어진다. 이때, 최솟값과 최댓값을 구하는 프로그램을 작성하시오.입력  첫째 줄에 정수의 개수 N (1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄에는 N개의 정수를 공백으로 구분해서 주어진다. 모든 정수는 -1,000,000보다 크거나 같고, 1,000,000보다 작거나 같은 정수이다.출력  첫째 줄에 주어진 정수 N개의 최솟값과 최댓값을 공백으로 구분해 출력한다.예제 입력 1520 10 35 30 7예제 출력 17 35풀이import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Arrays;import java.util.StringTokenizer;public class Main {\t\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\t\t\tint N = Integer.parseInt(br.readLine());\t\tStringTokenizer st = new StringTokenizer(br.readLine(), \" \");\t\t\t\tint[] arr = new int[N];\t\tint index = 0;\t\t\t\tfor (int i = 0; st.hasMoreTokens(); i++) {\t\t\tarr[i] = Integer.parseInt(st.nextToken());\t\t}\t\t\t\tArrays.sort(arr);\t\tSystem.out.println(arr[0] + \" \" + arr[N-1]);\t\t\t}}",
        "url": "/b10818"
    }
    ,
    
    "b10871": {
        "title": "[백준] 10871번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "X보다 작은 수문제  정수 N개로 이루어진 수열 A와 정수 X가 주어진다. 이때, A에서 X보다 작은 수를 모두 출력하는 프로그램을 작성하시오.입력      첫째 줄에 N과 X가 주어진다. (1 ≤ N, X ≤ 10,000)        둘째 줄에 수열 A를 이루는 정수 N개가 주어진다. 주어지는 정수는 모두 1보다 크거나 같고, 10,000보다 작거나 같은 정수이다.  출력  X보다 작은 수를 입력받은 순서대로 공백으로 구분해 출력한다. X보다 작은 수는 적어도 하나 존재한다.예제 입력 110 51 10 4 9 2 3 8 5 7 6예제 출력 11 4 2 3풀이import java.util.Scanner;public class Main {\t\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\t\t\tint N = sc.nextInt();\t\tint X = sc.nextInt();\t\t\t\tint[] arr = new int[N];\t\t\t\tfor (int i = 0; i &lt; arr.length; i++) {\t\t\tarr[i] = sc.nextInt();\t\t\tif(arr[i] &lt; X) {\t\t\t\tSystem.out.print(arr[i] + \" \");\t\t\t}\t\t}\t}}",
        "url": "/b10871"
    }
    ,
    
    "b10807": {
        "title": "[백준] 10807번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "개수 세기문제  총 N개의 정수가 주어졌을 때, 정수 v가 몇 개인지 구하는 프로그램을 작성하시오.입력  첫째 줄에 정수의 개수 N(1 ≤ N ≤ 100)이 주어진다. 둘째 줄에는 정수가 공백으로 구분되어져있다. 셋째 줄에는 찾으려고 하는 정수 v가 주어진다. 입력으로 주어지는 정수와 v는 -100보다 크거나 같으며, 100보다 작거나 같다.출력  첫째 줄에 입력으로 주어진 N개의 정수 중에 v가 몇 개인지 출력한다.예제 입력 1111 4 1 2 4 2 4 2 3 4 42예제 출력 13예제 입력 2111 4 1 2 4 2 4 2 3 4 45예제 출력 20풀이import java.util.Scanner;public class Main {\t\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\t\t\tint[] arr = new int[sc.nextInt()];\t\t\t\tfor (int i = 0; i &lt; arr.length; i++) {\t\t\tarr[i] = sc.nextInt();\t\t}\t\t\t\tint V = sc.nextInt();\t\tint count = 0;\t\t\t\tfor (int i = 0; i &lt; arr.length; i++) {\t\t\tif (arr[i] == V) count++;\t\t}\t\t\t\tsc.close();\t\t\t\tSystem.out.println(count);\t\t\t}}",
        "url": "/b10807"
    }
    ,
    
    "b4344": {
        "title": "[백준] 4344번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "평균은 넘겠지문제  대학생 새내기들의 90%는 자신이 반에서 평균은 넘는다고 생각한다. 당신은 그들에게 슬픈 진실을 알려줘야 한다.입력      첫째 줄에는 테스트 케이스의 개수 C가 주어진다.        둘째 줄부터 각 테스트 케이스마다 학생의 수 N(1 ≤ N ≤ 1000, N은 정수)이 첫 수로 주어지고, 이어서 N명의 점수가 주어진다. 점수는 0보다 크거나 같고, 100보다 작거나 같은 정수이다.  출력  각 케이스마다 한 줄씩 평균을 넘는 학생들의 비율을 반올림하여 소수점 셋째 자리까지 출력한다.예제 입력 155 50 50 70 80 1007 100 95 90 80 70 60 503 70 90 803 70 90 819 100 99 98 97 96 95 94 93 91예제 출력 140.000%57.143%33.333%66.667%55.556%풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main {\t\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\t\t\tint[] arr;\t\t\t\tint std_case = Integer.parseInt(br.readLine());\t\t\t\tStringTokenizer st;\t\t\t\t\t\tfor (int i = 0; i &lt; std_case; i++) {\t\t\t\t\t\tst = new StringTokenizer(br.readLine(), \" \");\t\t\t\t\t\t\t\t\tint std_num = Integer.parseInt(st.nextToken());\t\t\tarr = new int[std_num];\t\t\t\t\t\t\t\t\tdouble sum = 0;\t\t\t\t\t\tfor (int j = 0; j &lt; std_num; j++) {\t\t\t\tint val = Integer.parseInt(st.nextToken());\t\t\t\tarr[j] = val;\t\t\t\tsum += val;\t\t\t}\t\t\t\t\t\t\t\t\tdouble avg = sum/std_num;\t\t\tdouble count = 0;\t\t\t\t\t\tfor (int j = 0; j &lt; std_num; j++) {\t\t\t\tif (arr[j] &gt; avg) {\t\t\t\t\tcount++;\t\t\t\t}\t\t\t}\t\t\t\t\t\tSystem.out.printf(\"%.3f%%\\n\", (count/std_num)*100);\t\t}\t\t\t\t\t\t\t}}",
        "url": "/b4344"
    }
    ,
    
    "b10812": {
        "title": "[백준] 10812번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "바구니 순서 바꾸기문제      도현이는 바구니를 총 N개 가지고 있고, 각각의 바구니에는 1번부터 N번까지 번호가 순서대로 적혀져 있다. 바구니는 일렬로 놓여져 있고, 가장 왼쪽 바구니를 1번째 바구니, 그 다음 바구니를 2번째 바구니, …, 가장 오른쪽 바구니를 N번째 바구니라고 부른다.        도현이는 앞으로 M번 바구니의 순서를 회전시키려고 만들려고 한다. 도현이는 바구니의 순서를 회전시킬 때, 순서를 회전시킬 범위를 정하고, 그 범위 안에서 기준이 될 바구니를 선택한다. 도현이가 선택한 바구니의 범위가 begin, end이고, 기준이 되는 바구니를 mid라고 했을 때, begin, begin+1, …, mid-1, mid, mid+1, …, end-1, end 순서로 되어있는 바구니의 순서를 mid, mid+1, …, end-1, end, begin, begin+1, …, mid-1로 바꾸게 된다.        바구니의 순서를 어떻게 회전시킬지 주어졌을 때, M번 바구니의 순서를 회전시킨 다음, 바구니에 적혀있는 번호를 가장 왼쪽 바구니부터 출력하는 프로그램을 작성하시오.  입력      첫째 줄에 N (1 ≤ N ≤ 100)과 M (1 ≤ M ≤ 100)이 주어진다.        둘째 줄부터 M개의 줄에는 바구니의 순서를 바꾸는 만드는 방법이 주어진다. 방법은 i, j, k로 나타내고, 왼쪽으로부터 i번째 바구니부터 j번째 바구니의 순서를 회전시키는데, 그 때 기준 바구니는 k번째 바구니라는 뜻이다. (1 ≤ i ≤ k ≤ j ≤ N)        도현이는 입력으로 주어진 순서대로 바구니의 순서를 회전시킨다.  출력  모든 순서를 회전시킨 다음에, 가장 왼쪽에 있는 바구니부터 바구니에 적혀있는 순서를 공백으로 구분해 출력한다.예제 입력 110 51 6 43 9 82 10 51 3 32 6 2예제 출력 11 4 6 2 3 7 10 5 8 9풀이1import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main {\t\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tStringTokenizer st = new StringTokenizer(br.readLine(), \" \");\t\t\t\tint N = Integer.parseInt(st.nextToken());\t\tint M = Integer.parseInt(st.nextToken());\t\t\t\tint[] arr = new int[N];\t\t\t\tfor (int i = 0; i &lt; arr.length; i++) {\t\t\tarr[i] = i+1;\t\t}\t\t\t\tfor (int i = 0; i &lt; M; i++) {\t\t\t\t\t\tst = new StringTokenizer(br.readLine(), \" \");\t\t\tint x = Integer.parseInt(st.nextToken());\t\t\tint y = Integer.parseInt(st.nextToken());\t\t\tint z = Integer.parseInt(st.nextToken());\t\t\t\t\t\tfor (int j = 0; j &lt; z-x; j++) {\t\t\t\tfor (int k = 0; k &lt; y-x; k++) {\t\t\t\t\tint tmp = arr[x - 1 + k];\t\t\t\t\tarr[x - 1 + k] = arr[x + k];\t\t\t\t\tarr[x + k] = tmp;\t\t\t\t}\t\t\t}\t\t}\t\t\t\tfor (int i = 0; i &lt; arr.length; i++) {\t\t\tSystem.out.print(arr[i] + \" \");\t\t}\t\t\t}\t}",
        "url": "/b10812"
    }
    ,
    
    "b10951": {
        "title": "[백준] 10951번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "A + B - 4문제  두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.입력      입력은 여러 개의 테스트 케이스로 이루어져 있다.        각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. (0 &lt; A, B &lt; 10)  출력  각 테스트 케이스마다 A+B를 출력한다.예제 입력 11 12 33 49 85 2예제 출력 1257177풀이import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main {\t\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tStringBuilder sb = new StringBuilder();\t\tStringTokenizer st;\t\tString str;\t\t\t\twhile((str = br.readLine()) != null) {\t\t\t\t\t\tst = new StringTokenizer(str, \" \");\t\t\tint a = Integer.parseInt(st.nextToken());\t\t\tint b = Integer.parseInt(st.nextToken());\t\t\tsb.append(a+b).append(\"\\n\");\t\t}\t\tSystem.out.println(sb);\t\t\t}\t}",
        "url": "/b10951"
    }
    ,
    
    "b10952": {
        "title": "[백준] 10952번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "A + B - 5문제  두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.입력      입력은 여러 개의 테스트 케이스로 이루어져 있다.        각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. (0 &lt; A, B &lt; 10)        입력의 마지막에는 0 두 개가 들어온다.  출력  각 테스트 케이스마다 A+B를 출력한다.예제 입력 11 12 33 49 85 20 0예제 출력 1257177풀이import java.util.Scanner;public class Main {\t\tpublic static void main(String[] args) {\t\tScanner sc = new Scanner(System.in);\t\twhile(true) {\t\t\tint a = sc.nextInt();\t\t\tint b = sc.nextInt();\t\t\tif(a == 0 &amp;&amp; b == 0) return;\t\t\tSystem.out.println(a + b);\t\t}\t\t} // end main} //end class",
        "url": "/b10952"
    }
    ,
    
    "b2439": {
        "title": "[백준] 2439번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "별 찍기 - 2문제      첫째 줄에는 별 1개, 둘째 줄에는 별 2개, N번째 줄에는 별 N개를 찍는 문제        하지만, 오른쪽을 기준으로 정렬한 별(예제 참고)을 출력하시오.  입력  첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다.출력  첫째 줄부터 N번째 줄까지 차례대로 별을 출력한다.예제 입력 15예제 출력 1    *   **  *** *********풀이import java.util.Scanner;public class Main {\t\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\t\t\tint N = sc.nextInt();\t\t\t\tsc.close();\t\t\t\tfor (int i = 1; i &lt; N + 1; i++) {\t\t\tfor (int j = N - i; j &gt; 0 ; j--) {\t\t\t\tSystem.out.print(\" \");\t\t\t}\t\t\tfor (int k = 1; k &lt;= i; k++) {\t\t\t\tSystem.out.print(\"*\");\t\t\t}\t\t\tSystem.out.println();\t\t}\t\t\t}}",
        "url": "/b2439"
    }
    ,
    
    "b2438": {
        "title": "[백준] 2438번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "별 찍기 - 1문제  첫째 줄에는 별 1개, 둘째 줄에는 별 2개, N번째 줄에는 별 N개를 찍는 문제입력  첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다.출력  첫째 줄부터 N번째 줄까지 차례대로 별을 출력한다.풀이import java.util.Scanner;public class Main {\tpublic static void main(String[] args) {\t\tScanner sc = new Scanner(System.in);\t\tint a = sc.nextInt();\t\tfor(int i = 1; i &lt; a + 1; i++) {\t\t\tfor(int j = 0; j &lt; i; j++) {\t\t\t\tSystem.out.print(\"*\");\t\t\t}\t\t\tSystem.out.println(\"\");\t\t}\t\t\t}// end main} //end class",
        "url": "/b2438"
    }
    ,
    
    "b11022": {
        "title": "[백준] 11022번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "A + B - 8문제  두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.입력      첫째 줄에 테스트 케이스의 개수 T가 주어진다.        각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. (0 &lt; A, B &lt; 10)  출력  각 테스트 케이스마다 “Case #x: A + B = C” 형식으로 출력한다. x는 테스트 케이스 번호이고 1부터 시작하며, C는 A+B이다.풀이1import java.util.Scanner;public class Main {\t\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\t\t\tint N = sc.nextInt();\t\t\t\tfor (int i = 0; i &lt; N; i++) {\t\t\tint a = sc.nextInt();\t\t\tint b = sc.nextInt();\t\t\tSystem.out.println(\"Case #\" + (i + 1) + \": \" + (a + b));\t\t}\t\t\t\tsc.close();\t}풀이2import java.util.Scanner;public class Main {\t\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\t\t\tint N = sc.nextInt();\t\t\t\tfor (int i = 0; i &lt; N; i++) {\t\t\tint a = sc.nextInt();\t\t\tint b = sc.nextInt();\t\t\tSystem.out.printf(\"Case #%d: %d + %d = %d\\n\",(i + 1), a, b, (a + b));\t\t}\t\t\t\tsc.close();\t}}",
        "url": "/b11022"
    }
    ,
    
    "b11021": {
        "title": "[백준] 11021번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "A + B - 7문제  두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.입력      첫째 줄에 테스트 케이스의 개수 T가 주어진다.        각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. (0 &lt; A, B &lt; 10)  출력  각 테스트 케이스마다 “Case #x: “를 출력한 다음, A+B를 출력한다. 테스트 케이스 번호는 1부터 시작한다.풀이import java.util.Scanner;public class Main {\t\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\t\t\tint N = sc.nextInt();\t\t\t\tfor (int i = 0; i &lt; N; i++) {\t\t\tint a = sc.nextInt();\t\t\tint b = sc.nextInt();\t\t\tSystem.out.println(\"Case #\" + (i + 1) + \": \" + (a + b));\t\t}\t\t\t\tsc.close();\t}}",
        "url": "/b11021"
    }
    ,
    
    "b15552": {
        "title": "[백준] 15552번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "빠른 A + B문제      본격적으로 for문 문제를 풀기 전에 주의해야 할 점이 있다. 입출력 방식이 느리면 여러 줄을 입력받거나 출력할 때 시간초과가 날 수 있다는 점이다.        C++을 사용하고 있고 cin/cout을 사용하고자 한다면, cin.tie(NULL)과 sync_with_stdio(false)를 둘 다 적용해 주고, endl 대신 개행문자(\\n)를 쓰자. 단, 이렇게 하면 더 이상 scanf/printf/puts/getchar/putchar 등 C의 입출력 방식을 사용하면 안 된다.        Java를 사용하고 있다면, Scanner와 System.out.println 대신 BufferedReader와 BufferedWriter를 사용할 수 있다. BufferedWriter.flush는 맨 마지막에 한 번만 하면 된다.        Python을 사용하고 있다면, input 대신 sys.stdin.readline을 사용할 수 있다. 단, 이때는 맨 끝의 개행문자까지 같이 입력받기 때문에 문자열을 저장하고 싶을 경우 .rstrip()을 추가로 해 주는 것이 좋다.        또한 입력과 출력 스트림은 별개이므로, 테스트케이스를 전부 입력받아서 저장한 뒤 전부 출력할 필요는 없다. 테스트케이스를 하나 받은 뒤 하나 출력해도 된다.  입력  첫 줄에 테스트케이스의 개수 T가 주어진다. T는 최대 1,000,000이다. 다음 T줄에는 각각 두 정수 A와 B가 주어진다. A와 B는 1 이상, 1,000 이하이다.출력  각 테스트케이스마다 A+B를 한 줄에 하나씩 순서대로 출력한다.풀이import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main {\t\tpublic static void main(String[] args) throws IOException {\t\t\t\t//StringBuilder 사용\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\t\t\tint N = Integer.parseInt(br.readLine());\t\t\t\tStringTokenizer st;\t\tStringBuilder sb = new StringBuilder();\t\t\t\tfor (int i = 0; i &lt; N; i++) {\t\t\tst = new StringTokenizer(br.readLine(), \" \");\t\t\tsb.append(Integer.parseInt(st.nextToken()) + Integer.parseInt(st.nextToken()) + \"\\n\");\t\t}\t\t\t\tbr.close();\t\t\t\tSystem.out.println(sb);\t}}",
        "url": "/b15552"
    }
    ,
    
    "b25314": {
        "title": "[백준] 25314번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "코딩은 체육과목입니다.문제      오늘은 혜아의 면접 날이다. 면접 준비를 열심히 해서 앞선 질문들을 잘 대답한 혜아는 이제 마지막으로 칠판에 직접 코딩하는 문제를 받았다. 혜아가 받은 문제는 두 수를 더하는 문제였다. C++ 책을 열심히 읽었던 혜아는 간단히 두 수를 더하는 코드를 칠판에 적었다. 코드를 본 면접관은 다음 질문을 했다. “만약, 입출력이  N바이트 크기의 정수라면 프로그램을 어떻게 구현해야 할까요?”        혜아는 책에 있는 정수 자료형과 관련된 내용을 기억해 냈다. 책에는 long int는 4바이트 정수까지 저장할 수 있는 정수 자료형이고 long long int는 8바이트 정수까지 저장할 수 있는 정수 자료형이라고 적혀 있었다. 혜아는 이런 생각이 들었다. “int 앞에 long을 하나씩 더 붙일 때마다 4바이트씩 저장할 수 있는 공간이 늘어나는 걸까? 분명 long long long int는 12바이트, long long long long int는 16바이트까지 저장할 수 있는 정수 자료형일 거야!” 그렇게 혜아는 당황하는 면접관의 얼굴을 뒤로한 채 칠판에 정수 자료형을 써 내려가기 시작했다.        혜아가 N바이트 정수까지 저장할 수 있다고 생각해서 칠판에 쓴 정수 자료형의 이름은 무엇일까?  입력  첫 번째 줄에는 문제의 정수 N이 주어진다. (4 &lt;= N &lt;= 1000; N은 4의 배수) 출력  혜아가 N바이트 정수까지 저장할 수 있다고 생각하는 정수 자료형의 이름을 출력하여라.풀이import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main {\tpublic static void main(String[] args) throws NumberFormatException, IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\t\t\tint N = Integer.parseInt(br.readLine());\t\t\t\tStringBuilder sb = new StringBuilder();\t\t\t\tfor (int i = 0; i &lt; N/4; i++) {\t\t\tsb.append(\"long \");\t\t}\t\tsb.append(\"int\");\t\t\t\tSystem.out.println(sb);\t\t\t}\t}",
        "url": "/b25314"
    }
    ,
    
    "b25304": {
        "title": "[백준] 25304번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "영수증문제      준원이는 저번 주에 살면서 처음으로 코스트코를 가 봤다. 정말 멋졌다. 그런데, 몇 개 담지도 않았는데 수상하게 높은 금액이 나오는 것이다! 준원이는 영수증을 보면서 정확하게 계산된 것이 맞는지 확인해보려 한다.        영수증에 적힌,    구매한 각 물건의 가격과 개수      구매한 물건들의 총 금액    을 보고, 구매한 물건의 가격과 개수로 계산한 총 금액이 영수증에 적힌 총 금액과 일치하는지 검사해보자.입력      첫째 줄에는 영수증에 적힌 총 금액 X가 주어진다.        둘째 줄에는 영수증에 적힌 구매한 물건의 종류의 수 N이 주어진다.        이후 N개의 줄에는 각 물건의 가격 A와 개수 B가 공백을 사이에 두고 주어진다.  출력  구매한 물건의 가격과 개수로 계산한 총 금액이 영수증에 적힌 총 금액과 일치하면 Yes를 출력한다. 일치하지 않는다면 No를 출력한다.풀이import java.util.Scanner;public class Main {\t\tpublic static void main(String[] args){\t\t\t\tScanner sc = new Scanner(System.in);\t\tint real_amount = sc.nextInt();\t\tint count = sc.nextInt();\t\t\t\tint total_amount = 0;\t\t\t\tfor (int i = 0; i &lt; count; i++) {\t\t\tint item_amount = sc.nextInt();\t\t\tint item_count = sc.nextInt();\t\t\ttotal_amount += (item_amount * item_count);\t\t}\t\t\t\tif (real_amount == total_amount) System.out.println(\"Yes\");\t\telse System.out.println(\"No\");\t\t\t}}",
        "url": "/b25304"
    }
    ,
    
    "b8393": {
        "title": "[백준] 8393번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "합문제  n이 주어졌을 때, 1부터 n까지 합을 구하는 프로그램을 작성하시오.입력  첫째 줄에 n (1 ≤ n ≤ 10,000)이 주어진다.출력  1부터 n까지 합을 출력한다.풀이import java.util.Scanner;public class Main {\tpublic static void main(String[] args) {\t\tScanner sc = new Scanner(System.in);\t\tint a = sc.nextInt();\t\tint sum = 0;\t\tfor(int i = 1; i &lt; a + 1; i++) {\t\t\tsum += i;\t\t}\t\tSystem.out.println(sum);\t} // end main} //end class",
        "url": "/b8393"
    }
    ,
    
    "b10950": {
        "title": "[백준] 10950번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "A + B - 3문제  두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.입력  첫째 줄에 테스트 케이스의 개수 T가 주어진다.  각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. (0 &lt; A, B &lt; 10)출력  각 테스트 케이스마다 A+B를 출력한다.풀이import java.util.Scanner;public class Main {\t\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\t\t\tint N = sc.nextInt();\t\t\t\tfor (int i = 0; i &lt; N; i++) {\t\t\tint A = sc.nextInt();\t\t\tint B = sc.nextInt();\t\t\tSystem.out.println(A+B);\t\t}\t\t\t\tsc.close();\t}}",
        "url": "/b10950"
    }
    ,
    
    "b2739": {
        "title": "[백준] 2739번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "구구단문제  N을 입력받은 뒤, 구구단 N단을 출력하는 프로그램을 작성하시오. 출력 형식에 맞춰서 출력하면 된다.입력  첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 9보다 작거나 같다.출력  출력형식과 같게 N1부터 N9까지 출력한다.풀이import java.util.Scanner;public class Main {\tpublic static void main(String[] args) {\t\tScanner sc = new Scanner(System.in);\t\tint a = sc.nextInt();\t\tfor(int i = 1; i &lt; 10; i++) {\t\t\tSystem.out.println(a + \" * \" + i + \" = \" + (a * i));\t\t}\t\t\t} // end main} //end class",
        "url": "/b2739"
    }
    ,
    
    "sorting-algorithm": {
        "title": "[알고리즘] 정렬",
            "author": "jjaemin0224",
            "category": "",
            "content": "1. 정렬 알고리즘1-1. 개념정렬 알고리즘은 주어진 데이터를 일정한 순서로 정렬하는 알고리즘입니다. 데이터를 정렬하는 이유는 데이터를 보다 효율적으로 검색하거나 다른 연산을 수행하기 위함입니다. 다양한 정렬 아고리즘이 개발되었으며, 각 알고리즘은 다양한 특징과 성능을 가지고 있습니다.여러 정렬 알고리즘 중에서 가장 기본적인 알고리즘은 버블 정렬(Bubble Sort)이며, 이 외에도 선택 정렬(Selection Sort), 삽입 정렬(Insertion Sort), 퀵 정렬(Quick Sort), 병합 정렬(Merge Sort), 힙 정렬(Heap Sort) 등이 있습니다.1-2. 특징  시간 복잡도(Time Complexity)          정렬 알고리즘은 입력 크기에 따라 수행 시간이 달라집니다. 일부 알고리즘은 최선, 평균, 최악의 경우에 따라 다른 시간 복잡도를 가집니다.        공간 복잡도(Space Complexity)          정렬 알고리즘은 추가적인 메모리 공간을 요구할 수도 있습니다. 일부 알고리즘은 입력 데이터를 직접 정렬하는 것이 아니라 새로운 배열이나 리스트를 생성하여 정렬할 수 있습니다.        안정성(Stability)          일부 정렬 알고리즘은 동일한 값에 대해 상대적인 순서를 보존하는 안정한 정렬을 제공합니다. 안정한 정렬 알고리즘은 중요한 데이터에서 중복된 값이 있는 경우 유용합니다.        비교 기반 정렬(Comparison-based Sorting)          대부분의 정렬 알고리즘은 데이터 간의 상대적인 크기를 비교하여 정렬합니다. 이러한 알고리즘은 데이터 비교에 기반하여 정렬을 수행하므로 비교 기반 정렬 알고리즘이라고도 합니다.        내부 정렬(Internal Sorting)          대부분의 정렬 알고리즘은 메모리 상에서 수행되는 내부 정렬 알고리즘이며, 입력 데이터를 메모리에 모두 저장하고 정렬합니다.        외부 정렬(External Sorting)          정렬해야 하는 데이터가 메모리에 모두 올라오지 않고 디스크나 파일과 같은 외부 저장 장치에 저장된 경우에 사용되는 정렬 알고리즘입니다. 외부 정렬은 데이터의 일부만을 메모리에 올리고 정렬하는 과정 반복하여 정렬을 수행합니다.      이러한 특징들을 고려하여 정렬 알고리즘은 선택하게 되며, 입력 데이터의 크기, 성능 요구 사항, 안정성의 필요 여부 등을 고려하여 적합한 알고리즘을 선택하는 것이 중요합니다.2. 버블 정렬(Bubble Sort)버블 정렬(Bubble Sort)은 인접한 두 원소를 비교하고, 필요한 경우 위치를 교환하여 정렬하는 알고리즘입니다. 매번 인접한 두 원소를 비교하면서 가장 큰 원소가 배열의 맨뒤로 이동하는 과정을 반복하며 정렬을 수행합니다.  동작 과정                  배열의 첫 번째 원소부터 마지막 원소까지 반복합니다.        현재 원소와 다음 원소를 비교합니다.        현재 원소가 다음 원소보다 크다면 두 원소의 위치를 교환합니다.        배열의 끝까지 도달하면 가장 큰 원소가 맨 뒤로 이동한 것으므로, 다음 반복에서는 맨 뒤의 원소를 제외하고 정렬 과정을 반복합니다.        정렬이 완료될 때까지 위의 과정을 반복합니다.            버블 정렬의 시간 복잡도는 최악, 평균, 최선의 경우 모두 O(n^2)입니다. 따라서 배열의 크기가 크거나 정렬할 데이터가 많은 경우에는 성능이 좋지 않을 수 있습니다.def bubble_sort(arr):    n = len(arr)    # 배열 크기만큼 반복    for i in range(n):        # 마지막 i개의 원소는 이미 정렬되었으므로 제외        for j in range(0, n-i-1):            # 현재 원소와 다음 원소를 비교하여 위치 교환            if arr[j] &gt; arr[j+1]:                arr[j], arr[j+1] = arr[j+1], arr[j]arr = [64, 34, 25, 12, 22, 11, 90]bubble_sort(arr)print(\"정렬 결과:\", arr)# 정렬 결과: [11, 12, 22, 25, 34, 64, 90]3. 선택 정렬(Selection Sort)선택 정렬(Selection Sort)은 주어진 배열에서 가장 작은(또는 가장 큰) 원소를 선택하여 정렬하는 알고리즘입니다. 배열을 순회하면서 가장 작은 원소를 찾아 배열의 첫 번째 원소와 교환한 후, 다음으로 작은 원소를 찾아 두 번째 원소와 교환하는 과정을 반복하여 정렬을 수행합니다.  동작과정                  배열의 첫 번째 원소를 기준으로 설정합니다.        나머지 원소들을 순회하면서 현재 기준 원소보다 작은(또는 큰) 값을 찾습니다.        가장 작은(또는 큰) 값을 찾으면 해당 값을 현재 기준 원소와 교환합니다.        다음 원소를 기준으로 설정하고 위의 과정을 반복합니다.        정렬이 완료될 때까지 위의 과정을 반복합니다.            선택 정렬의 시간 복잡도는 최악, 평균, 최선의 경우 모드 O(n^2)입니다. 버블 정렬과 마찬가지로 성능이 좋지 않을 수 있습니다.def selection_sort(arr):    n = len(arr)    # 배열 크기만큼 반복    for i in range(n):        # 현재 기준 원소의 인덱스를 저장        min_idx = i        # 나머지 원소들을 순회하며 최솟값을 찾음        for j in range(i+1, n):            if arr[j] &lt; arr[min_idx]:                min_idx = j        # 현재 기준 원소와 최솝값을 교환        arr[i], arr[min_idx] = arr[min_idx], arr[i]arr = [64, 25, 12, 22, 11]selection_sort(arr)print(\"정렬결과: \", arr)# 정렬결과: [11, 12, 22, 25, 64]4. 삽입 정렬(Insertion Sort)삽입 정렬(Insertion Sort)은 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누고, 정렬되지 않은 부분의 원소를 정렬된 부분에 삽입하는 방식으로 정렬하는 알고리즘입니다. 배열의 첫 번째 원소는 이미 정렬되었다고 가정하고, 두 번째 원소부터 시작하여 한 번에 하나씩 정렬된 부분에 삽입하면서 정렬을 완성합니다.  동작 과정                  배열의 첫 번째 원소는 이미 정렬되었다고 가정합니다.        정렬되지 않은 부분의 첫 번째 원소를 선택합니다.        선택한 원소를 정렬된 부분의 올바른 위치에 삽입합니다. 이를 위해 정렬된 부분을 순회하면서 선택한 원소보다 큰 원소를 찾아 오른쪽으로 이동시킵니다.        선택한 원소를 적절한 위치에 삽입하면 정렬된 부분의 크기가 1 증가합니다.        정렬되지 않은 부분의 원소가 남아있다면, 2단계부터 반복하여 정렬을 완성합니다.            삽입 정렬의 시간 복잡도는 최악, 평균, 최선의 경우 모두 O(n^2)입니다. 버블 정렬과 선택 정렬과 마찬가지로 성능이 좋지 않을 수 있습니다. 하지만 입력 데이터가 이미 정렬되어 있는 경우 최선의 경우에는 선형 시간(O(n))에 정렬을 완료할 수 있습니다.def insertion_sort(arr):    n = len(arr)    # 배열 크기만큼 반복    for i in range(1, n):        key = arr[i]  # 선택한 원소        j = i - 1     # key의 왼쪽에 있는 원소부터 비교하기 위한 인덱스        # key보다 큰 원소를 오른쪽으로 한 칸씩 이동        while j &gt;= 0 and arr[j] &gt; key:            arr[j + 1] = arr[j]            j -= 1        # key를 올바른 위치에 삽입        arr[j + 1] = keyarr = [64, 25, 12, 22, 11]insertion_sort(arr)print(\"정렬 결과:\", arr)# 정렬 결과: [11, 12, 22, 25, 64]5. 셸 정렬(Shell Sort)셸 정렬(Shell Sort)은 삽입 정렬을 개선한 정렬 알고리즘으로, 배열을 일정한 간격으로 나누어 부분적으로 정렬한 후, 간격을 점차 줄여가며 정렬을 반복합니다. 간격을 줄여가면서 정렬하는 과정을 여러 번 반복하면서 최종적으로 전체 배열을 정렬합니다.  동작 과정                  정렬할 배열을 일정한 간격(gap)으로 나눕니다.        각 부분 배열에 대해 삽입 정렬을 수행합니다. 간격(gap)이 1이 될 때까지 이 과정을 반복합니다.        간격(gap)을 줄여가며 정렬을 반복합니다. 일반적으로 간격(gap)은 초기 배열 크기의 절반으로 시작하여 점차 반으로 줄여가는 방식을 사용합니다.        간격(gap)이 1이 되면 최종적으로 전체 배열을 정렬합니다.            셸 정렬의 시간 복잡도는 최악의 경우 O(n^2)이지만 평균적으로는 O(n log n) 정도의 성능을 가집니다. 삽입 정렬보다는 빠르지만, 퀵 정렬이나 병합 정렬과 같은 다른 고급 정렬 알고리즘에 비해서는 성능이 상대적으로 떨어집니다.def shell_sort(arr):    n = len(arr)    gap = n // 2  # 초기 간격 설정    while gap &gt; 0:        for i in range(gap, n):            temp = arr[i]            j = i            while j &gt;= gap and arr[j - gap] &gt; temp:                arr[j] = arr[j - gap]                j -= gap            arr[j] = temp        gap //= 2  # 간격을 줄여가며 반복arr = [64, 25, 12, 22, 11]shell_sort(arr)print(\"정렬 결과:\", arr)# 정렬 결과: [11, 12, 22, 25, 64]6. 병합 정렬(Merge Sort)병합 정렬(Merge Sort)은 분할 정복(Divide and Conquer) 방식을 사용하여 배열을 정렬하는 알고리즘입니다. 배열을 반으로 나눈 후, 각각을 재귀적으로 정렬하고 다시 합병하는 과정을 통해 정렬을 완성합니다.  동작 과정                  배열을 반으로 나눕니다. 이때, 배열의 길이가 1 이하면 이미 정렬된 것으로 간주합니다.        나뉜 배열을 각각 재귀적으로 정렬합니다.        정렬된 두 개의 배열을 합병(merge)하여 하나의 정렬된 배열로 만듭니다. 합병 과정에서는 두 배열의 첫 번째 원소를 비교하여 작은 원소를 결과 배열에 추가하고, 해당 원소가 속한 배열의 다음 원소를 비교합니다.        합병이 완료되면 최종적으로 정렬된 배열이 생성됩니다.            병합 정렬의 시간 복잡도는 항상 O(n log n)입니다. 배열을 분할하고 합병하는 과정을 log n번 반복하고, 각 단계에서의 합병에는 최대 n개의 원소가 참여하기 때문입니다. 따라서 대부분의 경우에 효율적인 정렬 알고리즘으로 사용됩니다.def merge_sort(arr):    if len(arr) &lt;= 1:        return arr    mid = len(arr) // 2    left = merge_sort(arr[:mid])    right = merge_sort(arr[mid:])    return merge(left, right)def merge(left, right):    merged = []    left_index, right_index = 0, 0    while left_index &lt; len(left) and right_index &lt; len(right):        if left[left_index] &lt;= right[right_index]:            merged.append(left[left_index])            left_index += 1        else:            merged.append(right[right_index])            right_index += 1    # 남은 원소들을 추가    merged.extend(left[left_index:])    merged.extend(right[right_index:])    return mergedarr = [64, 25, 12, 22, 11]sorted_arr = merge_sort(arr)print(\"정렬 결과:\", sorted_arr)# 정렬 결과: [11, 12, 22, 25, 64]7. 퀵 정렬(Quick Sort)퀵 정렬(Quick Sort)은 분할 정복(Divide and Conquer) 방식을 사용하여 배열을 정렬하는 알고리즘입니다. 배열에서 피벗(pivot)을 선택하고, 피벗을 기준으로 작은 원소는 피벗의 왼쪽으로, 큰 원소는 피벗의 오른쪽으로 분할합니다. 이후 각 부분 배열에 대해 재귀적으로 퀵 정렬을 적용하여 정렬을 완성합니다.  동작 과정                  배열에서 피벗(pivot)을 선택합니다. 피벗은 일반적으로 배열의 중간 원소를 선택하거나 랜덤하게 선택합니다.        피벗을 기준으로 작은 원소는 피벗의 왼쪽으로, 큰 원소는 피벗의 오른쪽으로 분할합니다. 이 과정을 피벗을 중심으로 수행하며, 작은 원소와 큰 원소를 교환합니다.        분할된 두 개의 부분 배열에 대해 재귀적으로 위의 과정을 반복합니다.        분할된 부분 배열의 크기가 1 이하가 되면 재귀를 종료합니다.        모든 재귀 호출이 종료되면 정렬이 완료됩니다.            퀵 정렬의 시간 복잡도는 평균적으로 O(n log n)이며, 최악의 경우 O(n^2)입니다. 하지만 평균적인 경우에 매우 빠른 성능을 보이며, 대부분의 실제 데이터에 대해서 효과적으로 동작합니다.def quick_sort(arr):    if len(arr) &lt;= 1:        return arr    pivot = arr[len(arr) // 2]    left, equal, right = [], [], []    for num in arr:        if num &lt; pivot:            left.append(num)        elif num &gt; pivot:            right.append(num)        else:            equal.append(num)    return quick_sort(left) + equal + quick_sort(right)arr = [64, 25, 12, 22, 11]sorted_arr = quick_sort(arr)print(\"정렬 결과:\", sorted_arr)# 정렬 결과: [11, 12, 22, 25, 64]8. 힙 정렬(Heap Sort)힙 정렬(Heap Sort)은 힙 자료구조를 기반으로한 정렬 알고리즘입니다. 힙은 완전 이진 트리의 일종으로, 부모 노드의 값이 항상 자식 노드의 값보다 크거나 작은 특성을 가지고 있습니다. 힙 정렬은 주어진 배열을 최대 힙 또는 최소 힙으로 구성한 후, 힙에서 최대값(또는 최소값)을 반복적으로 꺼내어 배열에 저장하여 정렬을 수행합니다.  동작 과정                  주어진 배열을 최대 힙 또는 최소 힙으로 구성합니다. 최대 힙을 구성하는 경우에는 부모 노드의 값이 항상 자식 노드의 값보다 크도록, 최소 힙을 구성하는 경우에는 부모 노드의 값이 항상 자식 노드의 값보다 작도록 합니다.        최대 힙 또는 최소 힙에서 루트 노드의 값을 꺼내어 배열의 가장 끝에 저장합니다.        힙에서 루트 노드를 제거한 후, 힙의 특성을 유지하도록 조정(Heapify)합니다.        배열의 끝에 저장된 값을 제외한 나머지 요소들에 대해 2~3단계를 반복 수행합니다.        모든 요소를 꺼내면 배열은 정렬된 상태가 됩니다.            힙 정렬의 시간 복잡도는 항상 O(n log n)입니다. 힙의 구성에 O(n)의 시간이 소요되며, 배열의 크기만큼 루트 노드를 꺼내어 정렬하는 과정을 반복하므로 O(n log n)의 시간이 소요됩니다.def heapify(arr, n, i):    largest = i    left = 2 * i + 1    right = 2 * i + 2    if left &lt; n and arr[left] &gt; arr[largest]:        largest = left    if right &lt; n and arr[right] &gt; arr[largest]:        largest = right    if largest != i:        arr[i], arr[largest] = arr[largest], arr[i]        heapify(arr, n, largest)def heap_sort(arr):    n = len(arr)    # 최대 힙 구성    for i in range(n // 2 - 1, -1, -1):        heapify(arr, n, i)    # 힙 정렬 수행    for i in range(n - 1, 0, -1):        arr[i], arr[0] = arr[0], arr[i]        heapify(arr, i, 0)arr = [64, 25, 12, 22, 11]heap_sort(arr)print(\"정렬 결과:\", arr)# 정렬 결과: [11, 12, 22, 25, 64]9. 버킷 정렬(Bucket Sort)버킷 정렬(Bucket Sort)은 원소들을 동일한 크기의 버킷에 할당하고, 각 버킷을 정렬하여 최종적으로 버킷들을 합치는 방식으로 정렬을 수행하는 알고리즘입니다. 주어진 입력 배열이 균등한 분포를 가지고 있을 때 효과적으로 동작합니다.  동작 과정                  입력 배열의 최소값(min)과 최대값(max)을 찾습니다.        입력 배열의 범위를 버킷의 개수로 나누어 각 버킷의 범위(delta)를 구합니다.        버킷의 개수만큼 빈 버킷을 생성합니다.        입력 배열의 각 원소를 해당하는 버킷에 할당합니다. 원소 값이 범위 내에 속하는 버킷에 할당됩니다.        각 버킷 내부에서는 적절한 정렬 알고리즘(일반적으로 삽입 정렬)을 사용하여 원소들을 정렬합니다.        정렬된 각 버킷의 원소들을 차례대로 추출하여 합치면 정렬된 배열이 완성됩니다.            버킷 정렬의 시간 복잡도는 입력 배열의 원소 수(n)에 대해 O(n + k), 여기서 k는 버킷의 개수입니다. 입력 배열을 한 번 순회하여 각 원소를 버킷에 할당하는 시간이 O(n)이며, 각 버킷 내부에서의 정렬에 걸리는 시간이 O(k)입니다. 이 때, 버킷의 개수 k가 작을수록(입력 배열의 분포가 균등할수록) 더 효율적인 정렬 알고리즘이 됩니다.def insertion_sort(arr):    for i in range(1, len(arr)):        key = arr[i]        j = i - 1        while j &gt;= 0 and arr[j] &gt; key:            arr[j + 1] = arr[j]            j -= 1        arr[j + 1] = keydef bucket_sort(arr):    n = len(arr)    if n &lt;= 1:        return arr    min_val = min(arr)    max_val = max(arr)    bucket_size = 5  # 버킷의 개수 설정    # 버킷 생성    buckets = [[] for _ in range(bucket_size)]    # 원소를 버킷에 할당    for num in arr:        index = (num - min_val) // ((max_val - min_val + 1) // bucket_size)        buckets[index].append(num)    # 버킷 내부의 원소들 정렬    for i in range(bucket_size):        insertion_sort(buckets[i])    # 정렬된 버킷을 합쳐서 결과 배열 생성    sorted_arr = []    for i in range(bucket_size):        sorted_arr += buckets[i]    return sorted_arrarr = [64, 25, 12, 22, 11]sorted_arr = bucket_sort(arr)print(\"정렬 결과:\", sorted_arr)# 정렬 결과: [11, 12, 22, 25, 64]10. 기수 정렬(Radix Sort)기수 정렬(Radix Sort)은 비교 기반 정렬 알고리즘이 아닌 자릿수를 기준으로 원소를 정렬하는 정렬 알고리즘입니다. 입력된 원소들을 자릿수별로 비교하여 정렬하는 방식으로 동작합니다.  동작 과정                  입력 배열의 가장 작은 자릿수부터 가장 큰 자릿수까지 반복합니다.        각 자릿수에 대해 원소들을 비교하여 정렬합니다. 이때, 자릿수에 따라 원소들을 그룹화하고, 각 그룹별로 정렬을 수행합니다.        가장 작은 자릿수부터 가장 큰 자릿수까지 반복하여 모든 자릿수에 대한 정렬을 완료합니다.            기수 정렬은 주로 비교 기반 정렬 알고리즘에 비해 안정적인 성능을 보이며, 원소들이 동일한 자릿수를 가질 때 효과적으로 동작합니다. 또한, 정렬 대상이 정수 또는 고정된 자릿수를 가진 문자열과 같이 비교 가능한 형태일 때 사용될 수 있습니다.def counting_sort(arr, exp):    n = len(arr)    output = [0] * n    count = [0] * 10    # 각 자릿수별로 빈도수 계산    for i in range(n):        index = arr[i] // exp        count[index % 10] += 1    # count 배열 업데이트    for i in range(1, 10):        count[i] += count[i - 1]    # output 배열 구성    i = n - 1    while i &gt;= 0:        index = arr[i] // exp        output[count[index % 10] - 1] = arr[i]        count[index % 10] -= 1        i -= 1    # 원본 배열에 output 배열 복사    for i in range(n):        arr[i] = output[i]def radix_sort(arr):    max_val = max(arr)    exp = 1    while max_val // exp &gt; 0:        counting_sort(arr, exp)        exp *= 10    return arrarr = [170, 45, 75, 90, 802, 24, 2, 66]sorted_arr = radix_sort(arr)print(\"정렬 결과:\", sorted_arr)# 정렬 결과: [2, 24, 45, 66, 75, 90, 170, 802]",
        "url": "/sorting-algorithm"
    }
    ,
    
    "tree-data-structure": {
        "title": "[알고리즘] 트리",
            "author": "jjaemin0224",
            "category": "",
            "content": "1. 트리(Tree)1-1. 개념트리(Tree)는 계층적인 구조를 가지며, 노드(Node)들로 구성된 비선형 자료구조입니다. 트리는 하나의 루트(Root) 노드를 가지고 있고, 각 노드는 부모-자식 관계로 연결되어 있습니다.1-2. 구성 요소  노드(Node):          트리를 구성하는 각각의 요소를 나타냅니다. 노드는 데이터를 저장하고, 부모-자식 관계를 가지며, 다른 노드와 연결됩니다.        루트(Root) 노드:          트리의 시작점으로, 다른 모든 노드의 조상입니다. 모든 경로는 루트 노드에서 시작합니다.        부모(Parent) 노드:          자식 노드를 가지는 노드를 부모 노드라고 합니다. 한 노드는 여러 개의 자식을 가질 수 있지만, 부모는 오직 하나의 노드만을 가집니다.        자식(Child) 노드:          부모 노드에 연결된 노드를 자식 노드라고 합니다. 각 부모 노드는 여러 개의 자식 노드를 가질 수 있습니다.        리프(Leaf) 노드:          자식이 없는 노드를 리프 노드라고 합니다. 즉, 리프 노드는 트리의 가장 끝에 위치한 노드입니다.      트리는 계층 구조를 표현하는 데 유용하며, 데이터의 저장, 검색, 정렬, 계층적 구조의 표현 등 다양한 애플리케이션에서 사용됩니다. 예를 들어, 파일 시스템의 디렉토리 구조, 조직의 조직도, 컴퓨터 네트워크의 계층 구조 등에서 트리 자료구조가 활용됩니다.2. 이진 트리(Binary Tree)2-1. 개념이진 트리(Binary Tree)는 각 노드가 최대 두 개의 자식 노드를 가지는 트리 구조입니다. 이진 트리는 노드들로 구성되며, 각 노드는 최대 두 개의 자식 노드를 가질 수 있습니다. 왼쪽 자식 노드와 오른족 자식 노드로 구성되며, 빈 자식 노드일 경우 Null 값을 가집니다.2-2. 특징  루트(Root)          이진 트리의 최상위 노드를 의미합니다. 모든 경로는 루트 노드에서 시작됩니다.        내부 노드(Internal Node)          최소한 하나의 자식 노드를 가지는 노드를 의미합니다.        외부 노드(Leaf Node)          자식 노드를 가지지 않는 노드로, 트리의 가장 끝에 위치합니다.        균형 트리(Balanced Tree)          좌우의 서브 트리의 높이 차이가 최대 하나인 트리를 의미합니다. 균형 트리는 검색과 같은 연산에서 빠른 속도를 보장합니다.        이진 탐색 트리(Binary Search Tree)          이진 트리의 한 종류로, 왼쪽 서브 트리의 모든 노드는 현재 노드보다 작은 값을 가지고, 오른쪽 서브 트리의 모든 노드는 현재 노드보다 큰 값을 가집니다. 이를 통해 효율적인 탐색과 정렬이 가능합니다.      2-3. 장점  데이터의 검색, 삽입, 삭제 등의 연산을 효율적으로 수행할 수 있습니다.  이진 탐색 트리는 데이터를 정렬된 상태로 유지하므로, 특정 값을 탐색하는데 유용합니다.  이진 트리는 다양한 알고리즘과 데이터 구조의 기반이 되어 유용하게 활용될 수 있습니다.2-4. 단점  이진 트리는 정렬된 데이터를 삽입하는 경우에도 최악의 경우에는 트리가 한 쪽으로 치우칠 수 있습니다. 이러한 경우 트리의 높이가 증가하여 연산의 성능이 저하될 수 있습니다.  일반적으로 트리의 구현은 포인터나 연결 리스트로 이루어지기 때문에 추가적인 메모리 공간이 필요합니다.3. AVL 트리(AVL Tree)3-1. 개념AVL 트리는 균형 이진 트리(Balanced Binary Tree)의 한 종류로, 모든 노드의 왼쪽 서브 트리와 오른쪽 서브 트리의 높이 차이가 최대 1인 트리입니다. AVL 트리는 이진 탐색 트리(Binary Search Tree)의 단점인 트리의 불균형을 해결하기 위해 고안되었습니다.3-2. 특징  균형 조건          모든 노드의 왼쪽 서브 트리와 오른쪽 서브 트리의 높이 차이가 최대 1로 유지됩니다.        자가 균형          AVL 트리는 삽입 또는 삭제 연산 수행 시, 자동으로 균형을 유지하기 위해 회전 연산을 수행합니다.        빠른 탐색          AVL 트리는 이진 탐색 트리의 특성을 가지므로 탐색 연산의 시간 복잡도가 O(log n)입니다.        삽입, 삭제의 균형 조정          AVL 트리는 삽입 또는 삭제 연산 수행 시, 회전 연산을 통해 균형을 유지합니다. 이를 통해 트리의 불균형을 방지하고 효율적인 연산을 수행합니다.      3-3. 장점  탐색, 삽입, 삭제 연산의 시간 복잡도가 O(log n)으로 매우 효율적입니다.  AVL 트리는 불균형한 상태를 자동으로 균형을 맞추는 회전 연산을 수행하여 항상 균형을 유지합니다.  이진 탐색 트리의 특성을 그대로 가지므로 탐색과 관련된 작업에 효율적입니다.3-4. 단점  AVL 트리는 노드를 삽입 또는 삭제할 때마다 균형을 맞추기 위해 회전 연산을 수행해야 하므로 일반 이진 탐색 트리에 비해 삽입, 삭제 연산이 더 복잡합니다.  AVL 트리는 균형을 유지하기위해 추가적인 메모리 공간을 필요로 합니다.4. RB 트리(RB Tree)4-1. 개념RB(Red-Black) 트리는 이진 탐색 트리의 일종으로 각 노드에 “color”라는 추가적인 속성을 가지고 있어서 균형을 유지하는 자기 균형 이진 탐색 트리입니다.4-2. 특징  색 속성: 각 노드는 빨강 또는 검정 중 하나의 색을 가지고 있습니다.  규칙 1: 루트 노드는 검정입니다.  규칙 2: 모든 리브 노드(NIL 노드)는 검정입니다.  규칙 3: 빨강 노드의 두 자식은 모두 검정입니다.  규칙 4: 어떤 노드로부터 시작되어 리프 노드에 도달하는 모든 경로에는 동일한 개수의 검은색 노드가 있어야합니다. 이를 “black height”라고도 합니다.4-3. 장점  탐색, 삽입, 삭제 연산의 최악의 경우 시간 복잡도가 O(log n)으로 보장됩니다.  균형을 유지하면서 데이터를 저장하기 때문에 최악의 경우에도 트리의 높이가 작아서 효율적인 탐색이 가능합니다.  데이터의 삽입, 삭제가 자주 일어나는 경우에도 효율적인 연산이 가능합니다.4-4. 단점  AVL 트리에 비해 상대적으로 구현이 복잡합니다. 삽입, 삭제 연산에 대한 로테이션 및 리컬러링이 필요합니다.  RB 트리는 AVL 트리보다 상대적으로 더 많은 메모리를 사용합니다. 각 노드에 색상을 나타내는 비트가 추가로 필요하기 때문입니다.5. B 트리(B Tree)5-1. 개념B 트리는 데이터를 저장하고 검색하는 데 사용되는 자료 구조로, 데이터베이스와 파일 시스템에서 널리 활용됩니다. B 트리는 다양한 특징과 장점을 가지고 있습니다. B 트리는 균형 이진 검색 트리의 일종으로, 각 노드가 여러 개의 키와 자식 노드를 가질 수 있습니다. 트리의 모든 리프 노드는 동일한 레벨에 있어야 하며, 각 노드는 최소한 t-1개의 키를 가지고 있어야 합니다. B 트리는 자주 사용되는 데이터베이스 연산인 검색, 삽입, 삭제 등을 효율적으로 수행할 수 있도록 설계되었습니다.B 트리는 대용량 데이터 처리와 동시 액세스를 효율적으로 다루기 위한 자료 구조로 널리 사용됩니다. 데이터베이스 관리 시스템, 파일 시스템, 캐시 구현 등에서 활용되며, 데이터의 검색과 변경 작업을 효율적으로 처리하는 데 큰 역할을 합니다.5-2. 특징  B 트리는 균형을 유지하여 검색, 삽입, 삭제 연산을 O(log n) 시간에 수행합니다. 이는 대용량 데이터 처리에 매우 효율적입니다.  B 트리는 삽입, 삭제 시에도 트리의 구조를 재조정하여 균형을 유지합니다. 이를 통해 트리의 높이를 최소한으로 유지할 수 있습니다.  B 트리는 효율적인 디스크 액세스를 위해 세분화된 블록 단위로 데이터를 저장하므로, 데이터베이스와 파일 시스템에서 널리 사용됩니다.  B 트리는 다양한 운영체제와 파일 시스템에서 지원되며, 여러 클라이언트의 동시 액세스를 효과적으로 처리할 수 있습니다.5-3. 장점  대용량 데이터 처리에 효율적입니다.  검색, 삽입, 삭제 연산을 효율적으로 수행합니다.  디스크 액세스를 최소화하여 성능을 향상시킵니다.  여러 클라이언트의 동시 액세스를 지원합니다.5-4. 단점  구현이 복잡하고 상대적으로 높은 메모리 요구사항이 있습니다.  데이터의 순차 접근에 대해서는 다른 자료 구조들보다 성능이 떨어질 수 있습니다.6. 힙(Heap)6-1. 개념트리에서의 “힙”은 특정한 규칙을 가지는 이진 트리입니다. 힙은 주로 우선순위 큐와 관련된 작업에 사용되며, 데이터를 정렬된 상태로 유지하고 효율적인 삽입 및 삭제 연산을 제공합니다. 힙은 완전 이진 트리(Complete Binary Tree)로서, 부모 노드와 자식 노드 간에 일정한 순서를 유지하는 이진 트리입니다. 대부분의 경우, 힙은 최대 힙(Max Heap) 또는 최소 힙(Min Heap)으로 구성되며, 이는 부모 노드와 자식 노드 간의 순서 관계를 정의합니다.힙은 주로 우선순위 큐를 구현하는 데 사용되며, 데이터의 우선순위에 따라 정렬된 상태를 유지하는 빠른 삽입 및 삭제 연산을 제공합니다. 이를 통해 효율적인 작업 스케줄링, 이벤트 처리, 데이터 정렬 등에 활용될 수 있습니다.6-2. 특징  최대 힙(Max Heap)은 부모 노드가 항상 자식 노드보다 크거나 같은 값을 가지는 힙입니다. 최소 힙(Min Heap)은 부모 노드가 항상 자식 노드보다 작거나 같은 값을 가지는 힙입니다.  힙은 우선순위 큐를 구현하는 데 매우 유용합니다. 최대 힙은 가장 큰 요소에 빠르게 접근할 수 있으며, 최소 힙은 가장 작은 요소에 빠르게 접근할 수 있습니다.  힙은 삽입 및 삭제 연산을 O(log n) 시간에 수행할 수 있습니다. 이는 효율적인 우선순위 큐 구현을 가능하게 합니다.6-3. 장점  힙은 우선순위 큐와 관련된 작업에 매우 효율적입니다.  데이터를 정렬된 상태로 유지하므로, 가장 크거나 작은 값에 빠르게 접근할 수 있습니다.  삽입 및 삭제 연산을 효율적으로 수행할 수 있습니다.6-4. 단점  임의의 요소에 접근하는 데에는 비효율적일 수 있습니다. 힙은 순차 접근이 아닌 우선순위에 따라 접근하는 데에 최적화되어 있습니다.",
        "url": "/tree-data-structure"
    }
    ,
    
    "linear-data-structure": {
        "title": "[알고리즘] 선형 데이터",
            "author": "jjaemin0224",
            "category": "",
            "content": "1. 배열(Array)1-1. 개념연속된 메모리 공간에 동일한 데이터 타입의 원소를 순서대로 저장하는 자료구조입니다. 각 원소는 인덱스를 통해 접근할 수 있습니다.1-2. 특징  장점                  빠른 인덱스 기반 접근이 가능합니다.        연속된 메모리 공간에 저장되어 캐시 효율성이 좋습니다.              단점                  크기가 고정되어 있어 크기 변경이 어려울 수 있습니다.        삽입과 삭제가 비효율적입니다.            1-3. 예시int[] array = new int[5]; // 크기가 5인 배열 생성array[0] = 10;array[1] = 20;array[2] = 30;int element = array[1]; // 인덱스를 통한 접근System.out.println(element); // 출력: 202. 리스트(List)2-1. 개념데이터의 논리적인 순서를 유지하며, 각 원소는 다음 원소를 가리키는 링크를 가지고 있습니다. 리스트는 배열과 달리 크기가 동적으로 조정될 수 있습니다.2-2. 특징  장점                  크기가 동적으로 조정될 수 있습니다.        데이터의 삽입과 삭제가 유연하게 이루어집니다.              단점                  원소에 접근하기 위해서는 순차적으로 탐색해야 합니다.            2-3. 예시List&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.add(10);list.add(20);list.add(30);int element = list.get(1); // 인덱스를 통한 접근System.out.println(element) // 출력: 203. 연결 리스트(Linked List)3-1. 개념각 원소가 데이터와 다음 원소를 가리키는 링크로 구성된 자료구조입니다. 각 원소는 메모리의 어느 위치에든 저장될 수 있으며, 링크를 통해 순서를 유지합니다.3-2. 특징  장점                  삽입과 삭제가 상수 시간에 이루어집니다.        동적인 크기 조정이 가능합니다.              단점                  접근 시간이 느리며, 순차적인 탐색이 필요합니다.            3-3. 예시LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;&gt;();linkedList.add(10);linkedList.add(20);linkedList.add(30);int element = linkedList.get(1); // 인덱스를 통한 접근System.out.println(element); // 출력: 204. 스택(Stack)4-1. 개념후입선출(LIFO, Last-In-First-Out)의 원리를 따르는 자료구조입니다. 데이터의 삽입과 삭제는 항상 스택의 상단에서 이루어집니다.4-2. 특징  장점                  후입선출(LIFO)의 원리를 따르며, 간단하고 빠른 구현이 가능합니다.        삽입과 삭제가 상수 시간에 이루어집니다.              단점                  크기에 제한이 있어 오버플로우가 발생할 수 있습니다.        중간에 있는 원소에 직접 접근할 수 없습니다.            4-3. 예시Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();stack.push(10);stack.push(20);stack.push(30);int element = stack.pop(); // 삭제System.out.println(element); // 출력: 305. 큐(Queue)5-1. 개념선입선출(FIFO, First-In-First-Out)의 원리를 따르는 자료구조입니다. 데이터의 삽입은 큐의 뒤(rear)에서 이루어지고, 삭제는 큐의 앞(front)에서 이루어집니다.5-2. 특징  장점                  선입선출(FIFO)의 원리를 따르며, 간단하고 빠른 구현이 가능합니다.        삽입과 삭제가 상수 시간에 이루어집니다.              단점                  크기에 제한이 있어 오버플로우가 발생할 수 있습니다.        중간에 있는 원소에 직접 접근할 수 없습니다.            5-3. 예시Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();queue.add(10);queue.add(20);queue.add(30);int element = queue.remove(); // 삭제System.out.println(element); // 출력: 106. 덱(Deque)6-1. 개념Double-Ended Queue의 줄임말로, 큐의 양쪽 끝에서 삽입과 삭제가 모두 가능한 자료구조입니다.6-2. 특징  장점                  큐와 스택의 특징을 모두 갖춘 자료구조입니다.        양쪽 끝에서 삽입과 삭제가 모두 가능합니다.              단점                  구현이 복잡할 수 있습니다.        메모리 사용량이 크기 때문에 공간 효율성이 떨어질 수 있습니다.            6-3. 예시Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();deque.addFirst(10); // 앞에 삽입deque.addLast(20); // 뒤에 삽입int firstElement = deque.removeFirst(); // 앞에서 삭제int lastElement = deque.removeLast(); // 뒤에서 삭제System.out.println(firstElement); // 출력: 10System.out.println(lastElement); // 출력: 207. 배열 리스트(ArrayList)7-1. 개념배열과 리스트의 특징을 결합한 자료구조로, 내부적으로 배열을 사용하여 리스트를 구현합니다. 동적인 크기 조정이 가능하며, 빠른 임의 접근과 삽입/삭제 연산을 제공합니다.7-2. 특징  장점                  내부적으로 배열을 사용하여 리스트를 구현합니다.        빠른 임의 접근이 가능합니다.              단점                  크기가 가변적이기 때문에 삽입과 삭제 시 재할당 및 복사가 필요할 수 있습니다.        중간에 원소를 삽입 또는 삭제하는 경우에는 시간 복잡도가 높아질 수 있습니다.            7-3. 예시ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();arrayList.add(10);arrayList.add(20);arrayList.add(30);int element = arrayList.get(1); // 인덱스를 통한 접근System.out.println(element); // 출력: 20",
        "url": "/linear-data-structure"
    }
    ,
    
    "b2480": {
        "title": "[백준] 2480번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "주사위 세개문제  1에서부터 6까지의 눈을 가진 3개의 주사위를 던져서 다음과 같은 규칙에 따라 상금을 받는 게임이 있다.  같은 눈이 3개가 나오면 10,000원+(같은 눈)×1,000원의 상금을 받게 된다.  같은 눈이 2개만 나오는 경우에는 1,000원+(같은 눈)×100원의 상금을 받게 된다.  모두 다른 눈이 나오는 경우에는 (그 중 가장 큰 눈)×100원의 상금을 받게 된다.      예를 들어, 3개의 눈 3, 3, 6이 주어지면 상금은 1,000+3×100으로 계산되어 1,300원을 받게 된다. 또 3개의 눈이 2, 2, 2로 주어지면 10,000+2×1,000 으로 계산되어 12,000원을 받게 된다. 3개의 눈이 6, 2, 5로 주어지면 그중 가장 큰 값이 6이므로 6×100으로 계산되어 600원을 상금으로 받게 된다.        3개 주사위의 나온 눈이 주어질 때, 상금을 계산하는 프로그램을 작성 하시오.  입력  첫째 줄에 3개의 눈이 빈칸을 사이에 두고 각각 주어진다.출력  첫째 줄에 게임의 상금을 출력 한다.풀이import java.util.Scanner;public class Main {\t\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\t\t\tint A = sc.nextInt();\t\tint B = sc.nextInt();\t\tint C = sc.nextInt();\t\t\t\tsc.close();\t\t\t\tint max = A;\t\tif(B &gt; A &amp;&amp; B &gt; C) {\t\t\tmax = B;\t\t}\t\telse if (C &gt; A &amp;&amp; C &gt; B) {\t\t\tmax = C;\t\t}\t\t\t\tif (A == B &amp;&amp; A == C) {\t\t\tSystem.out.println(10000 + A*1000);\t\t}\t\telse if (A == B) {\t\t\tSystem.out.println(1000 + A*100);\t\t}\t\telse if (B == C) {\t\t\tSystem.out.println(1000 + B*100);\t\t}\t\telse if (C == A) {\t\t\tSystem.out.println(1000 + C*100);\t\t}\t\telse {\t\t\tSystem.out.println(max*100);\t\t}\t\t\t}}",
        "url": "/b2480"
    }
    ,
    
    "b2525": {
        "title": "[백준] 2525번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "오븐 시계문제  KOI 전자에서는 건강에 좋고 맛있는 훈제오리구이 요리를 간편하게 만드는 인공지능 오븐을 개발하려고 한다. 인공지능 오븐을 사용하는 방법은 적당한 양의 오리 훈제 재료를 인공지능 오븐에 넣으면 된다. 그러면 인공지능 오븐은 오븐구이가 끝나는 시간을 분 단위로 자동적으로 계산한다.      또한, KOI 전자의 인공지능 오븐 앞면에는 사용자에게 훈제오리구이 요리가 끝나는 시각을 알려 주는 디지털 시계가 있다.    훈제오리구이를 시작하는 시각과 오븐구이를 하는 데 필요한 시간이 분단위로 주어졌을 때, 오븐구이가 끝나는 시각을 계산하는 프로그램을 작성하시오.입력  첫째 줄에는 현재 시각이 나온다. 현재 시각은 시 A (0 ≤ A ≤ 23) 와 분 B (0 ≤ B ≤ 59)가 정수로 빈칸을 사이에 두고 순서대로 주어진다. 두 번째 줄에는 요리하는 데 필요한 시간 C (0 ≤ C ≤ 1,000)가 분 단위로 주어진다.출력  첫째 줄에 종료되는 시각의 시와 분을 공백을 사이에 두고 출력한다. (단, 시는 0부터 23까지의 정수, 분은 0부터 59까지의 정수이다. 디지털 시계는 23시 59분에서 1분이 지나면 0시 0분이 된다.)풀이import java.util.Scanner;public class Main {\t\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\t\t\tint A = sc.nextInt();\t\tint B = sc.nextInt();\t\tint C = sc.nextInt();\t\t\t\tsc.close();\t\t\t\t//모든 시간을 분으로 바꾼다!!!!!!!!\t\t\t\tint totalM = A*60 + B + C;\t\tint H = totalM/60;\t\tint M = totalM%60;\t\t\t\tif (H &lt; 24) {\t\t\tSystem.out.println(H + \" \" + M);\t\t}\t\telse if (H &gt;= 24 &amp;&amp; H &lt; 48) {\t\t\tH = H - 24;\t\t\tSystem.out.println(H + \" \" + M);\t\t}\t\telse {\t\t\tH = H - 48;\t\t\tSystem.out.println(H + \" \" + M);\t\t}\t\t\t\t\t}}",
        "url": "/b2525"
    }
    ,
    
    "b2884": {
        "title": "[백준] 2884번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "알람 시계문제  상근이는 매일 아침 알람을 듣고 일어난다. 알람을 듣고 바로 일어나면 다행이겠지만, 항상 조금만 더 자려는 마음 때문에 매일 학교를 지각하고 있다. 상근이는 모든 방법을 동원해보았지만, 조금만 더 자려는 마음은 그 어떤 것도 없앨 수가 없었다. 이런 상근이를 불쌍하게 보던 창영이는 자신이 사용하는 방법을 추천해 주었다. 바로 “45분 일찍 알람 설정하기”이다. 이 방법은 단순하다. 원래 설정되어 있는 알람을 45분 앞서는 시간으로 바꾸는 것이다. 어차피 알람 소리를 들으면, 알람을 끄고 조금 더 잘 것이기 때문이다. 이 방법을 사용하면, 매일 아침 더 잤다는 기분을 느낄 수 있고, 학교도 지각하지 않게 된다.   현재 상근이가 설정한 알람 시각이 주어졌을 때, 창영이의 방법을 사용한다면, 이를 언제로 고쳐야 하는지 구하는 프로그램을 작성하시오.입력      첫째 줄에 두 정수 H와 M이 주어진다. (0 ≤ H ≤ 23, 0 ≤ M ≤ 59) 그리고 이것은 현재 상근이가 설정한 놓은 알람 시간 H시 M분을 의미한다.        입력 시간은 24시간 표현을 사용한다. 24시간 표현에서 하루의 시작은 0:0(자정)이고, 끝은 23:59(다음날 자정 1분 전)이다. 시간을 나타낼 때, 불필요한 0은 사용하지 않는다.  출력  첫째 줄에 상근이가 창영이의 방법을 사용할 때, 설정해야 하는 알람 시간을 출력한다. (입력과 같은 형태로 출력하면 된다.)풀이import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main {\t\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tStringTokenizer st = new StringTokenizer(br.readLine(), \" \");\t\tint H = Integer.parseInt(st.nextToken());\t\tint M = Integer.parseInt(st.nextToken());\t\t\t\tif (M &gt;= 45) {\t\t\tSystem.out.println(H + \" \" + (M - 45));\t\t}\t\telse {\t\t\tif (H == 0) {\t\t\t\tSystem.out.println(23 + \" \" + (60 + M - 45));\t\t\t}\t\t\telse {\t\t\t\tSystem.out.println((H - 1) + \" \" + (60 + M - 45));\t\t\t}\t\t}\t\t\t}}",
        "url": "/b2884"
    }
    ,
    
    "b14681": {
        "title": "[백준] 14681번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "사분면 고르기문제      흔한 수학 문제 중 하나는 주어진 점이 어느 사분면에 속하는지 알아내는 것이다. 사분면은 아래 그림처럼 1부터 4까지 번호를 갖는다. “Quadrant n”은 “제n사분면”이라는 뜻이다.        예를 들어, 좌표가 (12, 5)인 점 A는 x좌표와 y좌표가 모두 양수이므로 제1사분면에 속한다. 점 B는 x좌표가 음수이고 y좌표가 양수이므로 제2사분면에 속한다.        점의 좌표를 입력받아 그 점이 어느 사분면에 속하는지 알아내는 프로그램을 작성하시오. 단, x좌표와 y좌표는 모두 양수나 음수라고 가정한다.  입력  첫 줄에는 정수 x가 주어진다. (−1000 ≤ x ≤ 1000; x ≠ 0) 다음 줄에는 정수 y가 주어진다. (−1000 ≤ y ≤ 1000; y ≠ 0)출력  점 (x, y)의 사분면 번호(1, 2, 3, 4 중 하나)를 출력한다.풀이import java.util.Scanner;public class Main {\tpublic static void main(String[] args) {\t\tScanner sc = new Scanner(System.in);\t\tint x = sc.nextInt();\t\tint y = sc.nextInt();\t\tif(x&gt;0 &amp;&amp; y&gt;0)\t\t\tSystem.out.println(1);\t\telse if(x&lt;0 &amp;&amp; y&gt;0)\t\t\tSystem.out.println(2);\t\telse if(x&lt;0 &amp;&amp; y&lt;0)\t\t\tSystem.out.println(3);\t\telse \t\t\tSystem.out.println(4);\t\t\t}// end main} //end class",
        "url": "/b14681"
    }
    ,
    
    "b2753": {
        "title": "[백준] 2753번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "윤년문제  연도가 주어졌을 때, 윤년이면 1, 아니면 0을 출력하는 프로그램을 작성하시오.윤년은 연도가 4의 배수이면서, 100의 배수가 아닐 때 또는 400의 배수일 때이다.예를 들어, 2012년은 4의 배수이면서 100의 배수가 아니라서 윤년이다. 1900년은 100의 배수이고 400의 배수는 아니기 때문에 윤년이 아니다. 하지만, 2000년은 400의 배수이기 때문에 윤년이다.입력  첫째 줄에 연도가 주어진다. 연도는 1보다 크거나 같고, 4000보다 작거나 같은 자연수이다.출력첫째 줄에 윤년이면 1, 아니면 0을 출력한다.풀이import java.util.Scanner;public class Main {\tpublic static void main(String[] args) {\t\tScanner sc = new Scanner(System.in);\t\tint x = sc.nextInt();\t\tif ((x%4 == 0 &amp;&amp; x%100 !=0) || x%400 == 0) {\t\t\tSystem.out.println(1);\t\t} else {\t\t\tSystem.out.println(0);\t\t}\t} // end main} //end class",
        "url": "/b2753"
    }
    ,
    
    "b9498": {
        "title": "[백준] 9498번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "시험 성적문제  시험 점수를 입력받아 90 ~ 100점은 A, 80 ~ 89점은 B, 70 ~ 79점은 C, 60 ~ 69점은 D, 나머지 점수는 F를 출력하는 프로그램을 작성하시오.입력  첫째 줄에 시험 점수가 주어진다. 시험 점수는 0보다 크거나 같고, 100보다 작거나 같은 정수이다.출력시험 성적을 출력한다.풀이public class Main {\t\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\tint score = sc.nextInt();\t\tString result = \"\";\t\tsc.close();\t\t\t\tswitch (score/10) {\t\tcase 10 : case 9 :\t\t\tresult = \"A\";\t\t\tbreak;\t\tcase 8 :\t\t\tresult = \"B\";\t\t\tbreak;\t\tcase 7 :\t\t\tresult = \"C\";\t\t\tbreak;\t\tcase 6 :\t\t\tresult = \"D\";\t\t\tbreak;\t\tdefault :\t\t\tresult = \"F\";\t\t\tbreak;\t\t}\t\t\t\tSystem.out.println(result);\t}\t}",
        "url": "/b9498"
    }
    ,
    
    "b1330": {
        "title": "[백준] 1330번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "두 수 비교하기문제  두 정수 A와 B가 주어졌을 때, A와 B를 비교하는 프로그램을 작성하시오.입력  첫째 줄에 A와 B가 주어진다. A와 B는 공백 한 칸으로 구분되어져 있다.출력  첫째 줄에 다음 세 가지 중 하나를 출력한다.  A가 B보다 큰 경우에는 ‘&gt;’를 출력한다.  A가 B보다 작은 경우에는 ‘&lt;’를 출력한다.  A와 B가 같은 경우에는 ‘==’를 출력한다.풀이import java.util.Scanner;public class Main {\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\tint A = sc.nextInt();\t\tint B = sc.nextInt();\t\t\t\tif (A &gt; B) System.out.println(\"&gt;\");\t\telse if (A &lt; B) System.out.println(\"&lt;\");\t\telse System.out.println(\"==\");\t}}",
        "url": "/b1330"
    }
    ,
    
    "recursion-and-iteration": {
        "title": "[알고리즘] 재귀(Recursion)와 반복(Iteration)",
            "author": "jjaemin0224",
            "category": "",
            "content": "1. 재귀(Recursion)1-1. 개념재귀는 함수나 알고리즘 내에서 자기 자신을 호출하는 것을 의미합니다. 재귀는 주어진 문제를 작은 부분 문제로 나누고, 작은 부분 문제를 해결하기 위해 동일한 함수를 다시 호출하여 해결하는 방식입니다. 재귀 함수는 보통 재귀 호출을 멈출 수 있는 종료 조건(base case)을 포함하고 있어야 합니다.1-2. 특징  문제를 더 작은 부분 문제로 분할하여 해결합니다.  종료 조건을 명시하여 재귀 호출을 멈출 수 있습니다.  코드가 간결하고 가독성이 높을 수 있습니다.  일부 경우에는 반복문에 비해 성능 면에서 효율적일 수 있습니다.  하지만 재귀는 호출 스택을 사용하기 때문에 깊은 재귀 호출이 발생하면 스택 오버플로우(Stact Overflow) 문제가 발생할 수 있습니다.1-3. 예제 (python)def factorial(n):    if n == 0:        return 1    else:        return n * factorial(n - 1)2. 반복(Iteration)2-1. 개념반복은 루프(loop)를 사용하여 동일한 작업을 여러 번 수행하는 방식입니다. 반복은 초기 조건과 종료 조건을 설정하여 반복할 범위를 제어하며, 반복 구조 내에서 작업이 반복적으로 실행됩니다. 대부분의 프로그래밍 언어는 반복을 위한 다양한 종류의 루프 구문(예:for문, while문)을 제공합니다.2-2. 특징  초기 조건과 종료 조건을 명시하여 반복 범위를 제어합니다.  명시적으로 반복 구조를 작성해야 하기 때문에 코드가 길어질 수 있습니다.  스택 오버플로우 문제를 발생시키지 않습니다.  일반적으로 반복문은 재귀에 비해 성능 면에서 더 효율적일 수 있습니다.2-3. 예제 (python)def factorial(n):    result = 1    for i in range(1, n + 1):        result *= i    return result3. 재귀 활용def fibonacci(n):    if n &lt;= 1:        return n    else:        return fibonacci(n - 1) + fibonacci(n - 2)result = fibonacci(6)print(result)  # 출력: 8위의 예제에서 fibonacci 함수는 피보나치 수열의 n번째 값을 재귀적으로 계산합니다. 함수가 자기 자신을 호출하면서 n-1과 n-2의 값을 재귀적으로 계산하여 최종 결과를 반환합니다.",
        "url": "/Recursion-and-Iteration"
    }
    ,
    
    "algorithm-category": {
        "title": "[알고리즘] 알고리즘 유형",
            "author": "jjaemin0224",
            "category": "",
            "content": "1. 분할 정복 알고리즘(Divide and Conquer Algorithm)1-1. 개념분할 정복 알고리즘은 주어진 문제를 더 작은 부분 문제로 분할하고, 각 부분 문제를 독립적으로 해결한 뒤 이를 결합하여 원래 문제의 해답을 얻는 방법입니다. 분할 정복 알고리즘은 재귀적인 접근을 사용하며, 대부분의 경우 문제를 절반으로 나누는 방식으로 작동합니다.      분할(Divide) : 주어진 문제를 더 작은 부분 문제로 분할합니다. 이 단계에서는 문제를 잘게 쪼개기 위한 기준이 필요합니다.    정복(Conquer) : 분할된 작은 부분 문제를 재귀적으로 해결합니다. 부분 문제가 충분히 작아질 때까지 이 과정을 반복합니다.    결합(Combine) : 작은 부분 문제의 해답을 조합하여 원래 문제의 해답을 얻습니다. 이 단계에서 작은 부분 문제의 해답을 적절히 조합하여 전체 문제의 해답을 도출합니다.  1-2. 과정 (python)def divide_conquer(problem) :    # 기저 사례(base case) 처리    if problem is small enough :        return solve(problem)    # 문제를 작은 부분 문제로 분할    subproblems = divide(problem)    # 작은 부분 문제들을 재귀적으로 해결    solution = []    for subproblem in subproblems :        solutions.append(divide_conquer(subproblem))    # 작은 부분 문제의 해답을 결합하여 원래 문제의 해답 도출    result = combine(solutions)    return result1-3. 예제 (python)병합 정렬(Merge Sort)def merge_sort(arr) :    # 기저 사례 : 배열이 하나 이하의 원소를 가지면 정렬된 것으로 간주하고 반환    if len(arr) &lt;= 1 :        return arr    # 배열을 반으로 나누기    mid = len(arr) // 2    left = arr[:mid]    right = arr[mid:]    # 각 부분 배열을 재귀적으로 정렬    left = merge_sort(left)    right = merge_sort(right)    # 정렬된 부분 배열들을 병합    return merge(left, right)def merge(left, right):    merged = []    left_idx, right_idx = 0, 0    # 왼쪽과 오른쪽 부분 배열을 비교하며 병합    while left_idx &lt; len(left) and right_idx &lt; len(right):        if left[left_idx] &lt;= right[right_idx]:            merged.append(left[left_idx])            left_idx += 1        else:            merged.append(right[right_idx])            right_idx += 1    # 남은 원소들을 추가    merged.extend(left[left_idx:])    merged.extend(right[right_idx:])    return merged2. 탐욕 알고리즘(Greedy Algorithm)2-1. 개념탐욕 알고리즘(Greedy Algorithm)은 각 단계에서 가장 최적인 선택을 하는 것을 기반으로 문제를 해결하는 알고리즘입니다. 각 단계에서의 최적해를 선택하여 전체적인 최적해를 얻을 수 있다는 보장은 없지만, 많은 경우에 유용하고 간결한 해답을 제공합니다.      선택(Selection) : 각 단계에서 가능한 선택지 중에서 가장 최적인 선택을 합니다. 이 선택은 현재 상황에서 가장 이익이 크거나 비용이 작은 선택을 의미합니다.    탐색(Exploration): 선택한 해를 고려하여 다음 단계로 이동합니다. 이 때, 선택한 해에 따른 제약 조건이나 변경된 상황을 고려하여 다음 선택을 합니다.    종료(Termination): 모든 단계가 완료되면 알고리즘을 종료하고 최종 결과를 반환합니다.  2-2. 특징  탐욕 선택 속성(Greedy-choice property): 각 단계에서의 선택은 전체적인 최적해에 기여하는 것으로 가정합니다.  최적 부분 구조(Optimal substructure): 각 단계에서의 선택이 최적이면, 전체적인 문제에 대한 최적해를 구할 수 있습니다.2-3. 예제def give_change(amount, coins):    coins.sort(reverse=True)  # 동전의 크기를 내림차순으로 정렬    change = []    for coin in coins:        while amount &gt;= coin:            change.append(coin)            amount -= coin    return change위의 코드는 ‘give_change’ 함수를 통해 거스름돈을 계산하는 탐욕 알고리즘의 구현입니다. ‘amount’ 변수는 거슬러 줘야 할 금액이며, ‘coins’ 리스트는 사용 가능한 동전의 종류를 나타냅니다. 알고리즘은 가장 큰 동전부터 사용하여 거스름돈을 계산하며, 해당 동전이 사용 가능한 경우에만 사용합니다. 최적의 해는 보장되지 않지만, 가장 큰 동전부터 사용하여 거스름돈을 주는 것은 대부분의 경우에서 적은 동전을 사용하게 해줍니다.3. 동적 프로그래밍(Dynamic Programming)3-1. 개념동적 프로그래밍(Dynamic Programming)은 큰 문제를 작은 하위 문제로 나누어 해결하고, 중복되는 하위 문제의 결과를 저장하며, 최적해를 구하는 알고리즘입니다. 동적 프로그래밍은 하위 문제의 결과를 메모이제이션(Memoization)하여 중복 계산을 피하고, 효율적인 해결 방법을 제공합니다.      작은 하위 문제로 나눕니다.    하위 문제를 재귀적으로 해결합니다.    해결한 하위 문제의 결과를 저장하고 활용하여 중복 계산을 피합니다.    큰 문제의 최적해를 도출합니다.  3-2. 특징  최적 부분 구조(Optimal substructure): 큰 문제의 최적해는 작은 하위 문제의 최적해로부터 구성됩니다. 작은 문제의 최적해를 구한 후, 이를 조합하여 전체적인 최적해를 얻습니다.  중복되는 하위 문제(Overlapping subproblems): 작은 하위 문제들은 중복되는 경향이 있습니다. 동적 프로그래밍은 하위 문제의 해답을 저장하고 재사용하여 중복 계산을 피합니다.3-3. 예제 (python)def fibonacci(n):    # 기저 사례 처리    if n &lt;= 1:        return n    # 이미 계산한 결과가 있으면 그 값을 반환    if memo[n] != -1:        return memo[n]    # 아직 계산하지 않은 경우, 작은 문제로 나누어 해결    memo[n] = fibonacci(n - 1) + fibonacci(n - 2)    return memo[n]위의 코드는 ‘fibonacci’ 함수를 통해 피보나치 수열을 계산하는 동적 프로그래밍의 구현입니다. n번째 피보나치 수를 계산하기 위해 이전에 계산한 결과를 저장하는 ‘memo’ 배열을 활용합니다. 이미 계산한 결과가 있다면 그 값을 반환하고, 계산하지 않은 경우 작은 문제로 나누어 해결한 후 결과를 저장합니다. 이렇게 하면 중복 계산을 피할 수 있고, 효율적인 계산이 가능합니다.",
        "url": "/algorithm-category"
    }
    ,
    
    "function": {
        "title": "[개념] Function(함수)",
            "author": "jjaemin0224",
            "category": "",
            "content": "1. Function(함수)1-1. 개념함수는 독립적으로 실행 가능한 코드 블록으로, 입력 값을 받아 처리한 뒤 결과 값을 반환하는 작업을 수행합니다. 함수는 일련의 명령문으로 구성되며, 입력 파라미터를 받아들이고 결과를 반환하는 특징을 가지고 있습니다. 함수는 재사용 가능하고 모듈화된 코드를 작성하는 데 사용됩니다. 많은 프로그래밍 언어에서 함수는 값을 반환하는 경우에 사용되며, 함수의 호출 결과를 변수에 저장하거나 다른 표현식에서 사용할 수 있습니다.1-2. 예제 (java)public int add(int a, int b) {    return a + b;}int result = add(3, 4);System.out.println(result); // 출력: 72. Method(메소드)2-1. 개념메소드는 객체 지향 프로그래밍(OOP)에서 클래스나 객체에 속한 함수로서, 클래스의 특정 동작을 정의합니다. 메소드는 클래스 내부에 정의되며, 해당 클래스의 인스턴스(객체)에 의해 호출됩니다. 메소드는 클래스의 속성에 접근하고 조작하는 작업을 수행할 수 있으며, 객체의 특정 상태와 관련된 동작을 정의합니다.2-2. 예제 (java)public class Circle {    private double radius;        public double calculateArea() {        return Math.PI * radius * radius;    }}Circle myCircle = new Circle();myCircle.radius = 5.0;double area = myCircle.calculateArea();System.out.println(area); // 출력: 78.53981633974483‘Circle’ 클래스 내부에 ‘calculateArea’ 메서드가 정의되어 있습니다. 이 메서드는 원의 반지름을 기반으로 원의 넓이를 계산하고 반환합니다. ‘myCircle’ 객체를 생성한 후 반지름 값을 설정하고, ‘calculateArea’ 메서드를 호출하여 원의 넓이를 계산합니다.3. Procedure(프로시저)3-1. 개념프로시저는 일련의 작업을 수행하는 코드 블록으로, 특정한 결과 값을 반환하지 않는 절차적인 코드입니다. 프로시저는 함수와 유사하게 동작하지만, 결과 값을 반환하지 않는다는 점에서 차이가 있습니다. 프로시저는 보통 어떤 작업을 수행하고 그 결과를 호출한 쪽에 전달하기 위해 사용됩니다. 몇몇 프로그래밍 언어에서는 프로시저와 함수를 구분하지 않고 사용하기도 합니다.3-2. 예제 (python)def print_hello(name):    print(\"Hello, \" + name + \"!\")print_hello(\"John\")  # 출력: Hello, John!‘print_hello’ 프로시저는 인자로 받은 이름을 사용하여 “Hello, [name]!”과 같은 인사말을 출력하는 작업을 수행합니다. print_hello(“John”)과 같이 호출하면 “Hello, John!”이 출력됩니다.4. Subroutine(서브루틴)4-1. 개념서브루틴은 프로그램 내에서 다른 부분에 의해 호출되어 실행되는 일련의 작업을 수행하는 코드 조각입니다. 서브루틴은 보통 프로그램의 여러 곳에서 재사용되는 작업을 모듈화하기 위해 사용됩니다. 서브루틴은 일반적으로 호출되면서 어떤 값을 전달받고, 필요한 작업을 수행한 뒤 결과를 반환하지 않습니다. 함수와 메소드를 포함하여 프로시저도 서브루틴에 속하는 개념입니다.4-2. 예제 (javascript)function greet() {    console.log(\"Hello!\");}function welcome() {    console.log(\"Welcome!\");}function performGreeting() {    greet();    welcome();}performGreeting();‘greet’와 ‘welcome’은 각각 인사 메시지를 출력하는 서브루틴입니다.",
        "url": "/Function"
    }
    ,
    
    "b10172": {
        "title": "[백준] 10172번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "문제  아래 예제와 같이 개를 출력하시오.입력|\\_/||q p|   /}( 0 )\"\"\"\\|\"^\"`    |||_/=\\\\__|출력  개를 출력한다.풀이public class Main {\tpublic static void main(String[] args) {\t\tSystem.out.println(\"|\\\\_/|\");\t\tSystem.out.println(\"|q p|   /}\");\t\tSystem.out.println(\"( 0 )\\\"\\\"\\\"\\\\\");\t\tSystem.out.println(\"|\\\"^\\\"`    |\");\t\tSystem.out.println(\"||_/=\\\\\\\\__|\");\t\t\t}}",
        "url": "/b10172"
    }
    ,
    
    "b10171": {
        "title": "[백준] 10171번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "문제  아래 예제와 같이 고양이를 출력하시오.입력\\    /\\ )  ( ')(  /  ) \\(__)|출력  고양이를 출력한다.풀이class Main{    public static void main(String[] args){        System.out.println(\"\\\\    /\\\\\");\t    System.out.println(\" )  ( ')\");\t\tSystem.out.println(\"(  /  )\");\t\tSystem.out.println(\" \\\\(__)|\");    }}",
        "url": "/b10171"
    }
    ,
    
    "b11382": {
        "title": "[백준] 11382번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "문제  꼬마 정민이는 이제 A + B 정도는 쉽게 계산할 수 있다. 이제 A + B + C를 계산할 차례이다!입력  첫 번째 줄에 A, B, C (1 ≤ A, B, C ≤ 1012)이 공백을 사이에 두고 주어진다.출력  A+B+C의 값을 출력한다.풀이import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main {\tpublic static void main(String[] args) throws IOException {\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\t\t\tStringTokenizer st = new StringTokenizer(br.readLine(), \" \");\t\t\t\tlong A = Long.parseLong(st.nextToken());\t\tlong B = Long.parseLong(st.nextToken());\t\tlong C = Long.parseLong(st.nextToken());\t\t\t\tSystem.out.println(A + B + C);\t}\t}",
        "url": "/b11382"
    }
    ,
    
    "b2588": {
        "title": "[백준] 2588번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "문제  (세 자리 수) × (세 자리 수)는 다음과 같은 과정을 통하여 이루어진다.  (1)과 (2)위치에 들어갈 세 자리 자연수가 주어질 때 (3), (4), (5), (6)위치에 들어갈 값을 구하는 프로그램을 작성하시오.입력  첫째 줄에 (1)의 위치에 들어갈 세 자리 자연수가, 둘째 줄에 (2)의 위치에 들어갈 세자리 자연수가 주어진다.출력  첫째 줄부터 넷째 줄까지 차례대로 (3), (4), (5), (6)에 들어갈 값을 출력한다.풀이import java.util.Scanner;public class Main {\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\tint x = sc.nextInt();\t\tint y = sc.nextInt();\t\tint y3 = y/100;\t\tint y2 = (y%100)/10;\t\tint y1 = ((y%100)%10);\t\tint x3 = x*y3;\t\tint x2 = x*y2;\t\tint x1 = x*y1;\t\tSystem.out.println(x*y1);\t\tSystem.out.println(x*y2);\t\tSystem.out.println(x*y3);\t\tSystem.out.println(x3*100 + x2*10 + x1);\t}\t}",
        "url": "/b2588"
    }
    ,
    
    "b10430": {
        "title": "[백준] 10430번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "문제      (A+B)%C는 ((A%C) + (B%C))%C 와 같을까?        (A×B)%C는 ((A%C) × (B%C))%C 와 같을까?        세 수 A, B, C가 주어졌을 때, 위의 네 가지 값을 구하는 프로그램을 작성하시오.  입력  첫째 줄에 A, B, C가 순서대로 주어진다. (2 ≤ A, B, C ≤ 10000)출력  첫째 줄에 (A+B)%C, 둘째 줄에 ((A%C) + (B%C))%C, 셋째 줄에 (A×B)%C, 넷째 줄에 ((A%C) × (B%C))%C를 출력한다.풀이import java.util.Scanner;public class Main {\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\tint a = sc.nextInt();\t\tint b = sc.nextInt();\t\tint c = sc.nextInt();\t\tSystem.out.println((a+b)%c);\t\tSystem.out.println(((a%c) + (b%c))%c);\t\tSystem.out.println((a*b)%c);\t\tSystem.out.println(((a%c) * (b%c))%c);\t}\t}",
        "url": "/b10430"
    }
    ,
    
    "b18108": {
        "title": "[백준] 18108번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "문제  ICPC Bangkok Regional에 참가하기 위해 수완나품 국제공항에 막 도착한 팀 레드시프트 일행은 눈을 믿을 수 없었다. 공항의 대형 스크린에 올해가 2562년이라고 적혀 있던 것이었다.불교 국가인 태국은 불멸기원(佛滅紀元), 즉 석가모니가 열반한 해를 기준으로 연도를 세는 불기를 사용한다. 반면, 우리나라는 서기 연도를 사용하고 있다. 불기 연도가 주어질 때 이를 서기 연도로 바꿔 주는 프로그램을 작성하시오.입력  서기 연도를 알아보고 싶은 불기 연도 y가 주어진다. (1000 ≤ y ≤ 3000)출력  불기 연도를 서기 연도로 변환한 결과를 출력한다.풀이import java.util.Scanner;public class Main {\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\tint y = sc.nextInt();\t\tSystem.out.println(y - 543);\t}\t}",
        "url": "/b18108"
    }
    ,
    
    "b10926": {
        "title": "[백준] 10926번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "문제  준하는 사이트에 회원가입을 하다가 joonas라는 아이디가 이미 존재하는 것을 보고 놀랐다. 준하는 놀람을 ??!로 표현한다. 준하가 가입하려고 하는 사이트에 이미 존재하는 아이디가 주어졌을 때, 놀람을 표현하는 프로그램을 작성하시오.입력  첫째 줄에 준하가 가입하려고 하는 사이트에 이미 존재하는 아이디가 주어진다. 아이디는 알파벳 소문자로만 이루어져 있으며, 길이는 50자를 넘지 않는다.출력  첫째 줄에 준하의 놀람을 출력한다. 놀람은 아이디 뒤에 ??!를 붙여서 나타낸다.풀이import java.util.Scanner;public class Main {\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\tString str = sc.next();\t\tSystem.out.println(str + \"??!\");\t}\t}",
        "url": "/b10926"
    }
    ,
    
    "b10869": {
        "title": "[백준] 10869번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "문제  두 자연수 A와 B가 주어진다. 이때, A+B, A-B, A*B, A/B(몫), A%B(나머지)를 출력하는 프로그램을 작성하시오.입력  두 자연수 A와 B가 주어진다. (1 ≤ A, B ≤ 10,000)출력  첫째 줄에 A+B, 둘째 줄에 A-B, 셋째 줄에 A*B, 넷째 줄에 A/B, 다섯째 줄에 A%B를 출력한다.풀이import java.util.Scanner;public class Main {\tpublic static void main(String[] args) {\t\tScanner sc = new Scanner(System.in);\t\tint A = sc.nextInt();\t\tint B = sc.nextInt();\t\tsc.close();\t\t\t\tSystem.out.println(A+B);\t\tSystem.out.println(A-B);\t\tSystem.out.println(A*B);\t\tSystem.out.println(A/B);\t\tSystem.out.println(A%B);\t}}",
        "url": "/b10869"
    }
    ,
    
    "b1008": {
        "title": "[백준] 1008번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "문제  두 정수 A와 B를 입력받은 다음, A/B를 출력하는 프로그램을 작성하시오.입력  첫째 줄에 A와 B가 주어진다. (0 &lt; A, B &lt; 10)출력  첫째 줄에 A/B를 출력한다. 실제 정답과 출력값의 절대오차 또는 상대오차가 10-9 이하이면 정답이다.풀이import java.util.Scanner;public class Main {\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\tint a = sc.nextInt();\t\tint b = sc.nextInt();\t\tSystem.out.println((double)a/b);\t\t\t}\t}",
        "url": "/b1008"
    }
    ,
    
    "b10998": {
        "title": "[백준] 10998번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "문제  두 정수 A와 B를 입력받은 다음, A×B를 출력하는 프로그램을 작성하시오.입력  첫째 줄에 A와 B가 주어진다. (0 &lt; A, B &lt; 10)출력  첫째 줄에 A×B를 출력한다.풀이import java.util.Scanner;public class Main {\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\tint a = sc.nextInt();\t\tint b = sc.nextInt();\t\tSystem.out.println(a*b);\t\t\t}\t}",
        "url": "/b10998"
    }
    ,
    
    "b1001": {
        "title": "[백준] 1001번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "문제  두 정수 A와 B를 입력받은 다음, A-B를 출력하는 프로그램을 작성하시오.입력  첫째 줄에 A와 B가 주어진다. (0 &lt; A, B &lt; 10)출력  첫째 줄에 A-B를 출력한다.풀이import java.util.Scanner;public class Main {\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\tint a = sc.nextInt();\t\tint b = sc.nextInt();\t\tSystem.out.println(a-b);\t\t\t}\t}",
        "url": "/b1001"
    }
    ,
    
    "b1000": {
        "title": "[백준] 1000번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "문제  두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.입력  첫째 줄에 A와 B가 주어진다. (0 &lt; A, B &lt; 10)출력  첫째 줄에 A+B를 출력한다.풀이import java.util.Scanner;public class Main {\tpublic static void main(String[] args) {\t\t\t\tScanner sc = new Scanner(System.in);\t\tint a = sc.nextInt();\t\tint b = sc.nextInt();\t\tSystem.out.println(a+b);\t\t\t}\t}",
        "url": "/b1000"
    }
    ,
    
    "b2557": {
        "title": "[백준] 2557번(java)",
            "author": "jjaemin0224",
            "category": "",
            "content": "풀이public class Main {  \tpublic static void main(String[] args) {  \t\tSystem.out.println(\"Hello World!\");  \t}  }  ",
        "url": "/b2557"
    }
    ,
    
    "ioc": {
        "title": "[스프링] IOC(Inversion of Control)",
            "author": "jjaemin0224",
            "category": "",
            "content": "1. IOC(Inversion of Control)IOC(Inversion of Control)는 스프링(Spring) 프레임워크에서 사용되는 핵심 개념 중 하나입니다. IOC는 제어의 역전이라고도 불리며, 객체의 생성과 관리를 개발자가 아닌 프레임워크가 담당하는 것을 의미합니다.기존의 프로그래밍 모델에서는 개발자가 객체의 생성과 의존성 관리를 직접 수행했습니다. 하지만 IOC를 사용하는 경우, 개발자는 객체를 직접 생성하고 관리하지 않으며, 스프링 컨테이너가 객체의 생명주기와 의존성 주입을 담당합니다. 이를 통해 개발자는 비즈니스 로직에 집중할 수 있으며, 객체 간의 의존성과 관리를 외부로 위임할 수 있습니다.IOC는 스프링의 핵심 개념으로, 애플리케이션의 구조와 유연성을 개선하고 개발 생산성을 향상시킵니다. 의존성 주입을 통해 객체 간의 결합도를 낮추고, 스프링 컨테이너가 객체의 생명주기와 의존성 관리를 자동으로 처리함으로써 개발자는 핵심 비즈니스2. IOC의 핵심 원리2-1. 의존성 주입(Dependency Injection:DI)IOC는 의존성 주입을 통해 객체 간의 의존성을 관리합니다. 개발자가 객체를 생성하는 대신, 스프링 컨테이너가 객체를 생성하고 필요한 의존성을 주입합니다. 이를 통해 객체 간의 결합도를 낮출 수 있고, 유연하고 재사용 가능한 구조를 유지할 수 있습니다.2-2. 스프링 컨테이너스프링은 IOC를 구현하기 위해 컨테이너를 제공합니다. 스프링 컨테이너는 객체의 생명주기를 관리하고, 객체를 생성하고 의존성을 주입합니다. 개발자는 스프링 컨테이너를 설정하고 필요한 객체를 요청하는 방식으로 개발을 진행합니다.2-3. 설정 파일 또는 어노테이션IOC를 사용하기 위해서는 객체와 의존성을 정의하는 방법이 필요합니다. 스프링에서는 XML 설정 파일이나 어노테이션을 사용하여 객체와 의존성을 정의할 수 있습니다. 이를 통해 스프링 컨테이너가 필요한 객체를 인식하고 관리할 수 있습니다.",
        "url": "/ioc"
    }
    ,
    
    "spring-annotation": {
        "title": "[스프링] 주요 Annotation",
            "author": "jjaemin0224",
            "category": "",
            "content": "1. @Service‘@Service’ 어노테이션은 비즈니스 로직을 처리하는 서비스(Service) 클래스에 적용됩니다. 주로 비즈니스 로직을 수행하고, 트랜잭션 관리, 데이터 가공, 외부 시스템과의 통합 등을 담당합니다. ‘@Service’ 어노테이션이 지정된 클래스는 스프링의 컴포넌트 스캔에 의해 스프링 컨테이너에 빈(Bean)으로 등록됩니다. 이를 통해 해당 클래스의 인스턴스는 스프링에서 관리되며, 의존성 주입(DI)을 받을 수 있습니다.2. @Controller‘@Controller’ 어노테이션은 스프링 MVC에서 웹 요청을 처리하는 컨트롤러(Controller) 클래스에 적용됩니다. 컨트롤러는 클라이언트의 요청을 처리하고, 비즈니스 로직의 호출과 결과를 반환하는 역할을 담당합니다. ‘@Controller’ 어노테이션이 지정된 클래스는 스프링의 컴포넌트 스캔에 의해 스프링 컨테이너에 빈으로 등록되며, 스프링 MVC에서 요청을 처리하기 위해 사용됩니다. 주로 웹 애플리케이션 개발에서 사용됩니다.3. @Repository‘@Repository’ 어노테이션은 데이터 액세스 계층에서 데이터에 접근하는 리포지토리(Repository) 클래스에 적용됩니다. 리포지토리 클래스는 데이터베이스나 다른 영속성 저장소와의 상호 작용을 처리합니다. ‘@Repository’ 어노테이션이 지정된 클래스는 스프링의 컴포넌트 스캔에 의해 스프링 컨테이너에 빈으로 등록되며, 데이터 액세스를 담당하는 다양한 기능과 예외 변환 등을 제공합니다.4. Comment이 세 가지 어노테이션은 모두 스프링의 컴포넌트 스캔에 의해 스프링 컨테이너에 빈으로 등록되는 역할을 수행하며, 의존성 주입(Dependency Injection)을 받을 수 있습니다. 주로 역할과 책임에 따라 클래스를 구분하고, 관심사의 분리를 위해 사용됩니다. 그러나 어노테이션의 이름 자체에는 특별한 의미가 없으며, 스프링에서는 어노테이션의 이름을 통해 특정 기능이 자동으로 활성화되지는 않습니다.",
        "url": "/spring_annotation"
    }
    ,
    
    "di": {
        "title": "[스프링] DI(Dependency Injection)",
            "author": "jjaemin0224",
            "category": "",
            "content": "1. DI(Dependency Injection)DI(Dependency Injection)는 객체 지향 프로그래밍에서 사용되는 설계 원칙 중 하나입니다. DI는 객체 간의 의존성을 외부에서 주입하는 방식으로, 객체를 생성하거나 관리하지 않고, 의존성을 외부에서 받아와 사용하는 것을 의미합니다.DI는 스프링(Spring)과 같은 프레임워크에서 많이 사용되는 개념으로, 의존성 주입을 자동으로 처리해주는 컨테이너를 제공합니다. 이를 통해 개발자는 의존성 주입에 집중하지 않고도 객체를 개발하고 관리할 수 있습니다. 스프링은 DI를 통해 애플리케이션의 유연성과 확장성을 향상시키며, 객체의 생명주기와 의존성 관리를 자동화하는 기능을 제공합니다.2. DI의 장점2-1. 느슨한 결합(Loose Coupling)DI를 사용하면 객체 간의 결합도가 낮아집니다. 의존성을 주입받는 방식으로 객체를 생성하므로, 객체 간의 의존성이 명시적으로 드러나게 되며, 객체 간의 결합도가 감소합니다. 이로써 변경이 필요한 부분에 대해 영향 범위가 줄어들어 유지보수가 용이해집니다.2-2. 테스트 용이성DI를 통해 의존성을 주입받는 경우, 테스트 시에 모의 객체(Mock Object)를 주입하여 의존성 있는 코드를 테스트할 수 있습니다. 이는 의존하는 객체를 직접 생성하지 않고 외부에서 주입받기 때문에 테스트 환경에서 유연성을 제공합니다.2-3. 의존성의 중앙 관리DI를 사용하면 의존성을 관리하기 쉽습니다. 의존성을 주입받는 객체는 의존하는 객체를 직접 생성하거나 관리하지 않으므로, 의존성의 생성과 관리를 중앙화할 수 있습니다. 이를 통해 객체의 생명주기와 의존성 관리를 외부에서 담당할 수 있습니다.",
        "url": "/di"
    }
    ,
    
    "lambda": {
        "title": "[자바] 람다(Lambda)",
            "author": "jjaemin0224",
            "category": "",
            "content": "1. 람다 (Lambda)자바에서 람다식은 함수형 프로그래밍 스타일을 지원하기 위해 JDK 8부터 도입된 기능입니다. 람다식은 익명 함수(Anonymous Function)를 간결하게 표현하는 방법입니다.람다식은 일반적으로 함수형 인터페이스(Functional Interface)를 구현하는데 사용됩니다. 함수형 인터페이스는 단 하나의 추상 메서드를 가진 인터페이스를 말하며, 이 추상 메서드는 람다식으로 표현될 수 있습니다. 람다식은 함수형 인터페이스의 추상 메서드를 구현한 익명 객체를 생성하는 방식으로 사용됩니다.2. 활용 1  문자열 리스트에서 길이가 5이상인 문자열만 필터링~~~javaimport java.util.ArrayList;import java.util.Arrays;import java.util.List;public class Main {public static void main(String[] args) {    List&lt;String&gt; strings = Arrays.asList(\"apple\", \"banana\", \"kiwi\", \"orange\", \"grape\");    List&lt;String&gt; filteredStrings = filterStrings(strings, s -&gt; s.length() &gt;= 5);    System.out.println(filteredStrings);     // 출력: [apple, banana, orange, grape]}public static List&lt;String&gt; filterStrings(List&lt;String&gt; strings, StringFilter filter) {    List&lt;String&gt; filteredList = new ArrayList&lt;&gt;();    for (String s : Strings) {        if (filter.test(s)) {            filteredList.add(s)        }    }    return filteredList;}public interface StringFilter {    boolean test(String s);}}위 예시에서는 'filterStrings' 메서드를 사용하여 문자열 리스트를 필터링하는 기능을 구현하였습니다. 'StringFilter'라는 함수형 인터페이스를 정의하고, 이 인터페이스의 'test'메서드를 통해 문자열을 필터링합니다.람다식은 'filterStrings' 메서드의 두 번째 매개변수로 전달되어 필터링 조건을 정의합니다. 이를 통해 길이가 5이상인 문자열만 필터링하여 결과 리스트에 추가합니다.'main'메서드에서는 예시로 주어진 문자열 리스트에서 길이가 5이상인 문자열을 필터링한 결과를 출력합니다.이 예시에서 람다식을 사용하여 인터페이스를 구현함으로써, 필터링 조건을 유연하게 전달할 수 있습니다. 이러한 접근 방식은 코드의 재사용성과 가독성을 높이는데 도움을 줍니다. 또한, 함수형 프로그래밍 스타일을 적용하여 데이터를 변형하거나 처리하는 작업에 유용하게 사용할 수 있습니다.---## 3. 활용 2- 가격에 따라 정렬~~~javaimport java.util.ArrayList;import java.util.Collections;import java.util.List;public class Main {    public static void main(String[] args) {        List&lt;Product&gt; products = new ArrayList&lt;&gt;();        products.add(new Product(\"Apple\", 1000)):        products.add(new Product(\"Banana\", 500)):        products.add(new Product(\"Orange\", 1500)):        products.add(new Product(\"Grape\", 2000)):        System.out.println(\"정렬 전:\");        printProducts(products);        // 가격에 따라 오름차순으로 정렬        Collections.sort(products, (p1, p2) -&gt; p1.getPrice() - p2.getPrice());        System.out.println(\"가격 오름차순 정렬 후:\")        printProducts(products);    }    public static void printProducts(List&lt;Product&gt; products) {        for (Product product : products) {            System.out.println(product);        }        System.out.println();    }    public static class Product {        private String name;        private int price;        public Product(String name, int price) {            this.name = name;            this.price = price;        }    }    public String getName() {        return name;    }    public int getPrice() {        return price;    }    @Override    public String toString() {        return \"Product\" +                \"name='\" + name + '\\'' +               \", price=\" + price +               '}';    }}위 예시에서는 ‘Product’ 클래스를 정의하고, 이를 이용하여 물건의 이름과 가격을 담고 있는 ‘products’ 리스트를 생성합니다. 그리고 람다식을 사용하여 ‘Collections.sort()’ 메서드를 호출하여 가격에 따라 오름차순으로 ‘products’ 리스트를 정렬합니다.‘Product’ 클래스는 물건의 이름과 가격을 담는 데이터를 표현하기 위한 클래스입니다. ‘printProducts’ 메서드는 ‘products’ 리스트의 내용을 출력하는 역할을 합니다.‘main’ 메서드에서는 ‘products’ 리스트를 생성하고, 정렬 전과 정렬 후의 결과를 출력합니다. 람다식을 사용하여 ‘Collections.sort()’ 메서드에 정렬 조건을 전달하고 있습니다.이 예시에서는 람다식을 사용하여 정렬 기준을 유연하게 변경할 수 있습니다. 가격에 따라 오름차순 정렬을 하고 있지만, 람다식을 조금 변경하여 내림차순 정렬이나 다른 정렬 조건을 적용할 수도 있습니다. 또한, 람다식을 사용하면 정렬 로직을 구현할 수 있어서 기존의 정렬 기능을 확장하거나 다른 객체나 데이터 유형에 대해서도 적용할 수 있습니다.정렬 전:Product{name='Apple', price=1000}Product{name='Banana', price=500}Product{name='Orange', price=1500}Product{name='Grape', price=2000}가격 오름차순 정렬 후:Product{name='Banana', price=500}Product{name='Apple', price=1000}Product{name='Orange', price=1500}Product{name='Grape', price=2000}",
        "url": "/lambda"
    }
    ,
    
    "interface": {
        "title": "[자바] 인터페이스(Interface)",
            "author": "jjaemin0224",
            "category": "",
            "content": "1. 인터페이스 (Interface)인터페이스는 추상화된 타입을 정의하는 역할을 합니다. 인터페이스는 메서드 시그니처(메서드의 이름, 매개변수, 변환 타입)를 선언하고, 구현체 클래스에서 이러한 메서드를 구현하도록 요구합니다.인터페이스는 클래스와 클래스 간의 계약(contract)을 정의하며, 다형성(polymorphism)을 지원합니다. 인터페이스를 구현한 클래스들은 동일한 인터페이스 타입으로 다룰 수 있고, 이를 통해 유연하고 확장 가능한 코드를 작성할 수 있습니다. 또한, 인터페이스를 이용하여 의존성을 낮추고 모듈화된 시스템을 구축할 수 있습니다.2. 장점2-1. 다형성과 추상화인터페이스는 다형성을 지원하고, 추상화된 타입을 정의할 수 있습니다. 인터페이스를 구현한 다양한 클래스들을 동일한 인터페이스 타입으로 다룰 수 있으며, 이를 통해 유연하고 확장 가능한 코드를 작성할 수 있습니다. 인터페이스는 클래스와 클래스 간의 계약을 정의하고, 이를 통해 코드의 의도로 명확하게 전달할 수 있습니다.2-2. 계약과 규약인터페이스는 클래스가 어떤 메서드를 반드시 구현해야 하는지를 명시적으로 정의합니다. 이를 통해 인터페이스를 구현한 클래스들은 동일한 메서드를 가지고 있음이 보장됩니다. 인터페이스는 계약(Contract)을 정의하며, 이는 클래스 간의 상호작용을 원활하게 합니다.2-3. 코드의 유연성과 재사용성인터페이스를 사용하면 클래스의 구현과 인터페이스의 정의를 분리할 수 있습니다. 이는 ㅋ도의 유연성과 재사용성을 높이는데 도움을 줍니다. 인터페이스는 구현한 다른 클래스를 사용하거나 새로운 클래스를 작성하여 인터페이스를 구현할 수 있으므로, 코드의 변경이나 확장이 용이해집니다.2-4. 팁 작업과 코드 유지 보수인터페이스는 여러 개발자들이 동일한 인터페이스를 기준으로 작업할 수 있게 합니다. 인터페이스를 정의하여 필요한 기능과 규칙을 명확히 전달할 수 있으며, 이는 팀의 협업과 코드의 유지 보수를 용이하게 합니다.2-5. 라이브러리와 프레임워크의 기반많은 자바 라이브러리와 프레임워크는 인터페이스를 활용하여 구현되어 있습니다. 인터페이스는 라이브러리나 프레임워크의 핵심 기능을 정의하고, 사용자가 해당 인터페이스를 구현하여 원하는 기능을 추가할 수 있도록 합니다.인터페이스는 자바에서 객체 지향 프로그래밍의 핵심 원칙인 추상화, 다형성, 계약 등을 구현하는 데 중요한 도구입니다. 이를 적절히 활용하여 유연하고 확장 가능한 코드를 작성할 수 있습니다.3. 활용 예시3-1. 코드 예시// 동물 인터페이스public interface Animal {    void makeSound();}// 강아지 클래스public class Dog implements Animal {    @Override    public void makeSound() {        System.out.println(\"멍멍!\")    }}// 고양이 클래스public class Cat implements Animal {    @Override    public void makeSound() {        System.out.println(\"야옹~\")    }}// 메인 클래스public class Main {    public static void main(String[] args) {        Animal dog = new Dog();        Animal cat = new Cat();        dog.makeSound(); // 멍멍! 출력        cat.makeSound(); // 야옹~ 출력    }}이 예시에서는 ‘Animal’ 인터페이스를 정의하고, ‘Dog’와 ‘Cat’클래스가 이 인터페이스를 구현합니다. ‘Animal’ 인터페이스는 ‘makeSound’라는 추상 메서드를 가지고 있습니다. 각각의 구현 클래스는 이 메서드를 재정의하여 동물의 소리를 출력합니다.메인 클래스에서는 ‘Dog’와 ‘Cat’ 객체를 생성하고, ‘makeSound’ 메서드를 호출하여 각각의 동물 소리를 출력합니다. 이를 통해 인터페이스를 사용하여 다양한 동물 클래스를 동일한 인터페이스 타입으로 다룰 수 있으며, 동적으로 동물 객체를 바꿔가며 소리를 출력할 수 있습니다.이 예시는 인터페이스를 통해 다형성을 구현하고, 코드의 확장성과 유연성을 높이는 좋은 예시입니다. 인터페이스를 활용하면 코드를 더 추상화하고 재사용성을 높을 수 있으며, 객체 간의 결합도를 낮추어 유지 보수성을 향상시킬 수 있습니다.3-2. 클래스 대신 인터페이스를 사용한 이유  다중 상속의 제약  자바는 단일 상속만을 지원합니다. 클래스로 정의할 경우 ‘Dog’나 ‘Cat’클래스가 이미 다른 클래스를 상속하고 있다면 ‘Animal’ 클래스를 상속받을 수 없게 됩니다. 하지만 인터페이스는 다중 상속을 지원하므로 ‘Dog’나 ‘Cat’클래스가 이미 다른 클래스를 상속하고 있더라도 ‘Animal’인터페이스를 구현할 수 있습니다.  유현한 구현 변경  ‘Animal’ 인터페이스를 사용하면 ‘Dog’클래스 대신 다른 동물 클래스를 구현하여 ‘Aniaml’ 인터페이스를 사용할 수 있습니다. 예를 들어 ‘Bird’클래스를 구현하고 ‘makeSound’ 메서드를 재정하면 새의 소리를 출력할 수 있습니다. 이렇게 인터페이스를 사용하면 기존 코드의 변경 없이 새로운 동물 클래스를 추가하거나 교체할 수 있습니다.  계약의 강제  인터페이스는 클래스가 반드시 구현해야 하는 메서드를 정의하므로 계약(Contract)의 역할을 수행합니다. ‘Animal’ 인터페이스에서 ‘makeSound’메서드를 선언하면 해당 인터페이스를 구현하는 클래스는 ‘makeSound’메서드를 반드시 구현해야 합니다. 이를 통해 코드의 일관성과 안정성을 높일 수 있습니다.결론적으로, 인터페이스를 사용하면 다중 상속의 제약을 피하고 유연한 구현 변경을 가능케 하며, 계약의 강제를 통해 코드의 일관성을 유지할 수 있습니다.4. 활용 시 주의해야 할 점4-1. 추가 작업의 필요성인터페이스를 사용하면 클래스에 구현해야 하는 메서드를 정의해야 합니다. 따라서 인터페이스를 사용하면 클래스를 작성할 때 추가 작업이 필요합니다. 인터페이스의 메서드를 구현해야 하기 때문에 개발자는 구현에 필요한 코드를 작성해야 합니다. 이는 일부 개발자들에게 번거로울 수 있습니다.4-2. 설계 복잡성인터페이스를 적절하게 설계하는 것은 중요한 과정입니다. 인터페이스의 메서드를 올바르게 정의하고 계약을 명확히 전달해야 합니다. 잘못된 인터페이스 설계는 코드의 복잡성을 증가시킬 수 있고, 유지 보수가 어려워질 수 있습니다.4-3. 업데이트 관리터페이스는 변경 가능성이 있는 코드 요소입니다. 인터페이스에 새로운 메서드를 추가하거나 기존 메서드를 수정하는 경우, 해당 인터페이스를 구현한 모든 클래스에 변경 사항을 반영해야 합니다. 이는 업데이트 관리에 번거로움을 초래할 수 있습니다.4-4. 과도한 인터페이스 사용너무 많은 인터페이스를 사용하면 코드의 가독성과 이해도가 떨어질 수 있습니다. 인터페이스를 과도하게 사용하면 클래스 간의 관계를 이해하기 어려울 수 있으며, 코드의 복잡성이 증가할 수 있습니다.4-5. 한정적인 접근 제어인터페이스에서 선언한 메서드는 기본적으로 ‘public’으로 선언됩니다. 따라서 인터페이스를 구현하는 클래스는 해당 메서드를 ‘public’으로 구현해야 합니다. 이는 메서드의 접근 범위를 제한하는데 어려움을 줄 수 있습니다.",
        "url": "/interface"
    }
    ,
    
    "thread": {
        "title": "[자바] Thread(쓰레드)",
            "author": "jjaemin0224",
            "category": "",
            "content": "1. Thread쓰레드(Thread)는 프로세스 내에서 실행되는 독립적인 실행 단위로, 프로그램의 흐름을 제어하는 기본적인 개념입니다. 즉, 쓰레드는 프로세스 안에서 작업을 수행하는 단위로서, 하나의 프로세스에느 여러 개의 쓰레드가 동시에 실행될 수 있습니다.쓰레드는 프로세스의 자원을 공유하면서 각각 독립적인 실행 경로를 가지며, 동시에 여러 작업을 수행할 수 있습니다. 이는 병렬 처리와 동시성을 구현하는 데에 유용하며, 작업의 응답성을 향상시키고 자원을 효율적으로 활용할 수 있게 합니다.자바에서는 쓰레드를 생성하고 제어하기 위해 ‘java.lang.Thread’ 클래스를 사용합니다. ‘Thread’클래스는 쓰레드를 생성하고 실행하기 위한 다양한 메서드와 기능을 제공합니다. 일반적으로 쓰레드를 사용하기 위해서는 ‘Thread’클래스를 상속받아 새로운 클래스를 작성하고, ‘run()’메서드를 오버라이딩하며 원하는 작업을 정의합니다. 그리고 ‘start()’ 메서드를 호출하여 쓰레드를 시작합니다.쓰레드의 실행은 JVM(Java Virtual Machine)에 의해 스케줄되며, 쓰레드 스케줄링 알고리즘에 따라 실행 순서가 결정됩니다. 각각의 쓰레드는 독립적으로 실행되기 때문에 서로 다른 실행 경로를 가지고 작업을 수행합니다. 이러한 특성으로 인해 쓰레드는 동시성 프로그래밍에서 중요한 역할을 수행하며, 병렬 처리와 이벤트 처리 등에 널리 사용됩니다.쓰레드는 복잡한 작업의 분할과 동시 실행, 작업의 우선순위 설정, 동기화와 잠금, 쓰레드 간의 통신 등 다양한 기능을 제공합니다. 그러나 쓰레드를 사용할 때에는 공유 자원의 동기화, 교착 상태(deadlock) 및 경쟁 조건(race condition) 등에 주의해야 합니다. 안전하고 효율적인 쓰레드 프로그래밍을 위해서는 동기화 기법과 쓰레든 간의 상호작용에 대한 이해가 필요합니다.2. Thread를 고려하지 않았을 때 문제점  경쟁 상태(Race Condition)  여러 개의 쓰레드가 동시에 공유 자원에 접근하고 수정하는 경우, 예측할 수 없는 결과가 발생할 수 있습니다. 예를 들어, 두 개의 쓰레드가 동시에 동일한 변수를 증가시킨다면, 예상치 못한 값을 얻을 수 있습니다.  교착 상태(Deadlock)  여러 개의 쓰레드가 서로가 가지고 있는 자원을 기다리면서 무한히 대기하는 상태입니다. 이는 프로그램이 멈추게 되며, 데드락 상태를 해결하기 위해서는 적적한 동기화 기법과 교착 상태를 예방하는 방법을 사용해야 합니다.  쓰레드 안정성 문제(Thread Safety)  여러 개의 쓰레드가 동시에 공유 자원을 수정하려는 경우, 쓰레드 간의 충돌이 발생하여 잘못된 결과가 발생할 수 있습니다. 이를 해결하기 위해서는 쓰레드 간의 동기화를 통해 접근을 조절하고, 임계 구역(Cretical Section)에 대한 동기화를 구현해야 합니다.  성능 저하  쓰레드를 너무 많이 생성하거나 관리하지 않을 경우, 쓰레드 간의 컨텍스트 스위칭 비용이 증가하여 성능 저하가 발생할 수 있습니다. 또한, 적절한 쓰레드 풀 관리가 이루어지지 않으면 쓰레드 생성 및 소멸에 따른 오버헤드가 발생하여 성능이 저하될 수 있습니다.  안정성 문제  쓰레드를 올바르게 사용하지 않으면, 예외 처리가 제대로 이루어지지 않을 수 있고, 메모리 누수 등의 문제가 발생할 수 있습니다.따라서 쓰레드를 사용할 때에는 동시성과 관련된 문제들을 인식하고, 적절한 동기환 기법과 예외 처리 방법을 사용하여 안전하고 효율적인 쓰레드 프로그래밍을 해야 합니다.3. Thread 장점  동시성(Concurrency)  쓰레드를 사용하면 여러 작업을 동시에 실행할 수 있습니다. 예를 들어, 여러 개의 작업을 병렬로 처리하거나, 사용자 인터페이스의 응답성을 향상시키는 등의 동시성을 구현할 수 있습니다.  자원 공유(Resource Sharing)  쓰레드는 같은 프로세스 내에서 자원을 공유할 수 있습니다. 여러 쓰레드가 같은 데이터나 객체에 접근하여 작업을 수행할 수 있습니다. 이를 통해 효율적인 자원 활용과 데이터 일관성을 유지할 수 있습니다.  응답성(Responsiveness)  쓰레드를 사용하면 여러 작업을 동시에 처리할 수 있으므로, 사용자에게 더 빠른 응답성을 제공할 수 있습니다. 예를 들어, 사용자 인터페이스 쓰레드와 백그라운드 작업 쓰레드를 분리하여 사용자 애플리케이션에 대한 입력에 신속하게 반응할 수 있도록 할 수 있습니다.  병렬 처리(Parallel Procession)  쓰레드를 사용하면 병렬처리를 구현할 수 있습니다. 여러 쓰레드가 동시에 작업을 수행하여 전체 작업을 더 빠르게 처리할 수 있습니다. 이는 멀티코어 프로세서에서 특히 유용하며, 병렬 알고리즘 및 병렬 컴퓨팅을 활용하는 분야에서 중요합니다.  비동기 처리(Asynchronous Processing)  쓰레드를 사용하면 비동기 처리를 구현할 수 있습니다. 비동기 작업은 작업을 시작한 후 다른 작업을 수행하면서 결과를 기다리지 않고, 작업이 완료되면 결과를 처리할 수 있도록 합니다. 이를 통해 응답성을 향상시키고, 작업의 순차적인 실행에 의한 대기 시간을 줄일 수 있습니다.4. Thread 생성자바에서 쓰레드를 사용하기 위해서는 ‘java.lang.Thread’ 클래스를 사용해야 합니다. 쓰레드를 생성하려면 ‘Thread’ 클래스를 상속받아 새로운 클래스를 작성하거나, ‘Runnable’ 인터페이스를 구현한 클래스를 생성해야 합니다. 이후에는 다음과 같은 단계를 따라 쓰레드를 활용할 수 있습니다.3.1 Thread Classpublic class MyThread extends Thread {    @Override    public void run() {        // 실행할 작업 정의    }}‘Thread’ 클래스를 상속받은 클래스를 정의하고, ‘run()’ 메서드를 오버라이딩합니다. ‘run()’ 메서드 안에는 쓰레드가 실행할 작업을 정의합니다.MyThread myThread = new MyThread();myThread.start()‘Mythread’ 클래스의 인스턴스를 생성하고, ‘start()’ 메서드를 호출하여 쓰레드를 시작합니다. ‘start()’ 메서드는 새로운 쓰레드를 생성하고 ‘run()’ 메서드를 실행하는 역할을 합니다.‘start()’ 메서드를 호출하면 JVM은 새로운 쓰레드를 생성하고 ‘run()’ 메서드를 실행합니다. 각 쓰레드는 독립적으로 실행되며, ‘run()’ 메서드의 코드 블록이 실행됩니다.3-2. Runnable Interfacepublic class MyRunnable implements Runnable {    @Override    public void run() {        // 실행할 작업 정의    }}‘Runnable’ 인터페이스는 ‘run()’ 메서드를 정의하고 있으며, 쓰레드의 실행 작업을 정의하는 데에 사용됩니다.MyRunnable myRunnable = new MyRunnable();Thread thread = new Thread(myRunnable);thread.start();‘Runnable’ 인터페이스를 구현한 클래스의 인스턴스를 생성하고, ‘Thread’ 클래스의 생성자에 전달하여 쓰레드를 생성할 수 있습니다.5. Thread Execution Control(실행 제어)쓰레드의 실행을 제어하기 위해 자바에서는 ‘join()’ 메서드를 사용할 수 있습니다. ‘join()’ 메서는 호출한 쓰레드가 해당 쓰레드의 작업이 끝날 때까지 기다리도록 합니다. 두 개의 쓰레드를 생성하고, 첫 번째 쓰레드의 작업이 끝날 때 까지 두 번째 쓰레드가 기다리도록 하는 방법을 예시로 들겠습니다.class MyThread extends Thread {    private String name;    public MyThread(String name) {        this.name = name;    }    public void run() {        for (int i = 0; i &lt; 5; i++) {            System.out.println(name + \": \" + i);            try {                Thread.sleep(1000);            } catch (InterruptedException e) {                e.printStactTrace();            }        }    }}public class Main {    public static void main(String[] args) throws InterruptedException {        MyThread thread1 = new MyThread(\"Thread 1\");        MyThread thread2 = new MyThread(\"Thread 2\");        thread1.start();        thread1.join(); // 첫 번째 쓰레드의 작업이 끝날 때까지 가디립니다.        thread2.start();    }}위의 예시에서 ‘Mythread’클래스는 주어진 이름을 가지고 일정 횟수만큼 반복하면서 실행되는 쓰레드입니다. ‘Main’클래스에서는 두 개의 ‘MyThread’객체를 생성하고 각각 실행한 후, 첫 번째 쓰레드의 작업이 끝날 때까지 ‘join()’메서드를 호출하여 두 번째 쓰레드가 기다리도록 합니다. 이를 통해 첫 번째 쓰레드의 실행을 먼저 완료한 후, 두 번째 쓰레드가 실행되도록 제어할 수 있습니다.Thread 1: 0Thread 1: 1Thread 1: 2Thread 1: 3Thread 1: 4Thread 2: 0Thread 2: 1Thread 2: 2Thread 2: 3Thread 2: 46. Thread Synchronization(동기화)동기화(Synchronization)는 여러 쓰레드가 공유 자원에 접근할 때 원자적인 동작을 보장하고, 경쟁 상태와 같은 문제를 방지하기 위해 사용됩니다. 공유 변수에 접근하는 두 개의 쓰레드를 동기화하여 안전한 실행을 보장하는 방법을 예시로 들겠습니다.class Counter {    private int count = 0;    public synchronized void increment() {        count++;    }    public int getCount() {        return count;    }}class IncrementThread extends Thread {    private Counter counter;    public IncrementThread(Counter counter) {        this.counter = counter;    }    public void run() {        for (int i = 0; i &lt; 1000; i++) {            counter.increment();        }    }}public class Main {    public static void main(String[] args) throws InterruptedException {        Counter counter = new Counter();        IncrementThread thread1 = new IncrementThread(counter);        IncrementThread thread2 = new IncrementThread(counter);        thread1.start();        thread2.start();        thread1.join();        thread2.join();        System.out.println(\"Final count: \" + counter.getCount());    }}위의 예시에서 ‘Counter’ 클래스는 공유 변수인 ‘count’를 갖고 있습니다. ‘increment()’ 메서드는 동기화된 메서드로 선언되어 있어 여러 쓰레드가 동시에 ‘count’값을 증가시키는 경우에도 안전하게 실행됩니다. ‘IncrementThread’ 클래스는 ‘Counter’ 객체를 받아와 ‘increment()’ 메서드를 호출하여 ‘count’값을 증가시키는 작업을 수행합니다. ‘Main’클래스에서는 두 개의 쓰레드를 생성하고 실행한 후, ‘counter’객체의 최종 ‘count’값을 출력합니다. 동기화를 통해 여러 쓰레드가 안전하게 ‘count’값을 증가시킬 수 있습니다.Final count: 20007. Thread Deadlock(교착 상태)Deadlock(교착 상태)는 두 개 이상의 쓰레드가 서로 상대방이 소유한 자원을 기다리며 무한히 대기하는 상태를 말합니다. 이는 다음과 같은 조건들이 동시에 성립할 때 발생합니다.  상호 배제(Mutual Exclusion) : 자원은 동시에 하나의 쓰레드만이 사용할 수 있어야 합니다.  점유와 대기(Hold and Wait) : 적어도 하나의 자원을 점유한 상태에서 다른 자원을 기다리고 있어야 합니다.  비선점(No Preemption) : 쓰레드는 다른 쓰레드가 점유한 자원을 강제로 빼앗을 수 없습니다.  순환 대기(Circular Wait) : 쓰레드들 사이에 자원을 기다리는 순환 형태의 대기 관계가 존재해야 합니다.public class DeadlockExample {    public static void main(String[] args) {        // 공유 자원        final Object resource1 = new Object();        final Object resource2 = new Object();        // 첫 번째 쓰레드        Thread thread1 = new Thread(() -&gt; {            synchronized (resource1) {                System.out.println(\"Thread 1: Locked resource 1\")                try {                    Thread.sleep(1000);                } catch (InterruptedException e) {                    e.printStackTrace();                }                synchronized (resource2) {                    System.out.println(\"Thread 1: Locked resouce 2\")                }            }        });        // 두 번째 쓰레드        Thread thread2 = new Thread(() -&gt; {            synchronized (resource2) {                System.out.println(\"Thread 2: Locked resource 2\");                try {                    Thread.sleep(1000);                } catch (InterruptedException e) {                    e.printStackTrace();                }                synchronized (resource1) {                    System.out.println(\"Thread 2: Locked resource 1\");                }            }        });        // 쓰레드 시작        thread1.start();        thread2.start();    }}위의 예시에서는 두 개의 쓰레드가 서로 다른 순서로 두 개의 자원(resource1과 resource2)을 점유하려고 시도합니다. 첫 번째 쓰레드는 resource1을 점유한 후 resource2를 얻으려고 하고, 두 번째 쓰레드는 resource2를 점유한 후 resource1를 얻으려고 합니다. 이 때, 두 쓰레드 모두 상대방이 점유한 자원을 기다리기 때문에 서로가 끝나지 않고 무한히 대기하게 되어 교착 상태가 발생합니다.교착상태를 방지하기 위해 동기화 기법, 자원 할당 순서 변경, 상호 배제 제거 등의 방법을 사용할 수 있습니다.",
        "url": "/thread"
    }
    ,
    
    "accessmodifiers-keyword": {
        "title": "[자바] 접근 지정자와 키워드",
            "author": "jjaemin0224",
            "category": "",
            "content": "1. 접근 지정자 (Access Modifiers)접근 지정자(Access Modifiers)는 클래스의 멤버(변수, 메서드, 생성자)에 대한 접근 권한을 제어하는 키워드입니다.  private  ‘private’으로 지정된 멤버는 동일한 클래스 내에서만 접근할 수 있습니다. 즉, 해당 멤버는 외부 클래스나 다른 패키지의 클래스에서 직접 접근할 수 없습니다. ‘private’ 접근 지정자는 정보 은닉(Encapsulation)을 위해 사용되며, 외부로부터의 직접 접근을 제한하여 데이터의 무결성과 보안을 유지하는 데 도움을 줍니다.  public  ‘public’으로 지정된 멤버는 어떤 클래스에서든 접근할 수 있습니다. 다른 클래스나 패키지에서도 직접 접근이 가능합니다. ‘public’ 접근 지정자는 멤버의 외부로의 공개적인 접근을 제공하며, 다른 클래스들과의 상호작용을 위해 사용합니다.  protected’  ‘protected’로 지정된 멤버는 동일한 패키지 내의 클래스와 상속 관계에 있는 하위 클래스에서 접근할 수 있습니다. 즉, 패키지가 다른 다른 클래스나 하위 클래스가 아닌 경우 직접 접근할 수 없습니다. ‘protected’ 접근 지정자는 상속 관계에서 멤버의 상속과 재사용을 지원하는 데 사용됩니다.  default(생략 가능)  접근 지정자를 명시적으로 지정하지 않은 경우, 해당 멤버는 동일한 패키지 내의 클래스에서만 접근할 수 있습니다. 다른 패키지의 클래스에서는 직접 접근할 수 없습니다. 이는 패키지 내에서의 모듈화와 캡슐화를 위해 사용됩니다.접근 지정자를 적절하게 사용하여 클래스의 멤버에 대한 접근을 제어함으로써, 코드의 유연성과 가독성을 높일 수 있습니다. 또한 정보 은닉, 캡슐화, 상속 등의 개념을 구현할 수 있어 객체지향 프로그래밍의 원칙을 준수하는 데 도움을 줍니다.2. 키워드  static  해당 멤버(변수 또는 메서드)가 클래스 수준의 멤버임을 나타냅니다. 클래스의 인스턴스가 생성되지 않아도 사용할 수 있습니다. 클래스 변수와 클래스 메서드에 ‘static’ 키워드를 사용할 수 있습니다.  final  해당 멤버(변수, 메서드, 클래스)가 최종적인 값을 가지거나, 변경할 수 없음을 나타냅니다. ‘final’ 변수는 상수로 취급되며, ‘final’메서드는 하위 클래스에서 오버라이딩할 수 없습니다.  abstract  해당 클래스나 메서드가 추상적인 성격을 가지고 있음을 나타냅니다. 추상 클래스는 객체를 직접 생성할 수 없으며, 추상 메서드는 구현이 없는 메서드로 하위 클래스에서 반드시 구현해야 합니다.  interface  ‘interface’키워드는 인터페이스를 정의할 때 사용됩니다. 인터페이스는 추상메서드와 상수 필드만을 가지며, 클래스가 여러 인터페이스를 구현할 수 있도록 합니다. 인터페이스는 다형성을 지원하고, 클래스 간의 계약을 정의하는 역할을 합니다.  synchronized  멀티쓰레드 환경에서 동기화를 위해 사용되는 키워드입니다. ‘synchronized’키워드가 붙은 블록이나 메서드는 한 번에 한 쓰레드만이 접근할 수 있도록 제어합니다.  volatile  멀티쓰레드 환경에서 변수의 가시성과 순서를 보장하기 위해 사용되는 키워드입니다. ‘volatile’변수는 항상 주 메모리에서 읽고 쓰여집니다.",
        "url": "/accessmodifiers-keyword"
    }
    ,
    
    "overloading-overriding": {
        "title": "[자바] Overloading 과 Overriding",
            "author": "jjaemin0224",
            "category": "",
            "content": "1. OverloadingOverloading은 동일한 이름을 가진 메서드나 생성자를 여러 개 정의하는 것을 말한다. 오버로딩은 다양한 매개변수 조합에 대해 메서드의 동작을 정의하고 유연성을 제공하는데 사용된다.오버로딩은 다음과 같은 규치을 따른다.  메서드의 이름은 동일해야 한다.  메서드의 매개변수의 개수 또는 타입이 달라야 한다.  반환 타입은 오버로딩에 영향을 주지 않는다.예를 들어, 다음과 같이 ‘add’라는 이름을 가진 메서드를 오버로딩할 수 있다.public int add(int a, int b) {    return a + b;}public double add(double a, double b) {    return a + b;}public int add(int a, int b, int c) {    return a + b + c;}위의 예제에서 ‘add’ 메서드는 이름은 동일하지만 매개변수의 개수나 타입이 다른 세 가지 버전으로 오버로딩되었다. 이렇게 오버로딩된 메서드들은 다양한 상황에서 필요한 매개변수에 따라 호출될 수 있다.오버로딩은 코드의 가독성과 재사용성을 향상시키는 데 도움을 준다. 메서드의 이름을 일관적으로 사용하면서도 다양한 매개변수 조합에 대한 유연하게 대응할 수 있다. 다만, 오버로딩을 사용할 때에는 메서드의 동작이 명확하고 혼동을 일으키지 않도록 주의해야 한다.2. OverridingOverriding은 자바에서 상속 관계에 있는 클래스들 간에 부모 클래스의 메서드를 자식 클래스에서 재정의하는 것을 말한다. 부모 클래스의 메서드를 자식 클래서에서 동일한 시그니처(메서드 이름, 매개변수 타입, 반환 타입)로 구현하여 덮었는 개념이다.오버라이딩을 하려면 다음 규칙을 따라야 한다.  상속 관계에 있는 클래스에서만 오버라이딩이 가능하다.  오버라이딩할 메서드는 부모 클래스에서 상속되어야 한다.  오버라이딩할 메서드의 시그니처(이름, 매개변수 타입, 반환 타입)는 동일해야 한다.  접근 제어자는 부모 클래스의 메서드보다 더 좁은 범위로 변경할 수 없다. (예: 부모 클래스의 메서드가 ‘public’이면 오버라이딩된 메서드는 ‘public’ 또는 ‘protected’로 변경 가능)오버라이딩을 통해 자식 클래스는 부모 클래스의 동작을 재정의할 수 있다. 이를 통해 다형성(Polymorphism)의 개념을 실현하며, 상위 클래스에서 정의한 메서드를 하위 클래스에서 특화된 동작으로 변경할 수 있다.아래는 오버라이딩의 예시다.class Animal {    public void makeSound() {        System.out.println(\"Animal makes a sound\");    }}class Cat extends Animal {    @Override    public void makeSound() {        System.out.println(\"Cat meows\");    }}class Dog extends Animal {    @Override    public void makeSound() {        System.out.println(\"Dog barks\");    }}위의 예시에서 ‘Animal’ 클래스의 ‘makeSound’ 메서드를 ‘Cat’과 ‘Dog’ 클래스에서 오버라이딩 하였다. 각 클래스의 ‘makeSound’ 메서드는 부모 클래스의 동작을 재정의하여 다른 동작을 수행하게 된다.오버라이딩은 상속을 통해 클래스 간에 기능을 재활용하면서 다양한 동작을 구현하는데 유용하다. 상위 클래스의 메서드를 오버라이딩할 때에는 메서드의 의도를 유지하면서 필요한 동작을 구현하는 것이 중요하다.",
        "url": "/overloading-overriding"
    }
    ,
    
    "stringbuilder-stringbuffer": {
        "title": "[자바] StringBuilder 와 StringBuffer",
            "author": "jjaemin0224",
            "category": "",
            "content": "1. StringBuilderStringBuilder는 Java에서 문자열을 동적으로 변경하기 위한 클래스다. 문자열 연결이나 변경 작업이 필요한 경우, 일반적으로 문자열 직접 변경하면 새로운 문자열을 생성해야 하기 때문에 성능상의 이슈가 발생할 수 있다. 이 때 StringBuilder를 사용하면 문자열을 효율적으로 조작할 수 있다.StringBuilder는 내부적으로 가변 크기의 문자열 버퍼를 유지하며, 문자열의 추가, 삭제, 수정 등의 작업을 수행할 수 있다. 기존 문자열에 문자열을 추가하거나, 특정 위치에서 문자를 삽입하거나, 문자열을 삭제하고 수정하는 등의 작업을 할 수 있다.일반적인 사용 방법은 다음과 같다.  StringBuilder 객체 생성 :    StringBuilder sb = new StringBuilder();        문자열 추가 :    sb.append(\"Hello\");        문자열 삽입 :    sb.insert(5, \" World\");        문자열 삭제 :    sb.delete(5, 11);        문자열 수정 :    sb.replace(0, 5, \"Hi\");        문자열 반환 :    String result = sb.toString();      StringBuilder를 사용하면 문자열을 직접 변경하면서도 새로운 문자열 객체를 생성하지 않아 메모리 사용량과 성능을 향상시킬 수 있다. 주로 문자열 연결, 반복적인 문자열 조작, 루프에서 문자열 누적 등에 활용된다.2. StringBufferStringBuffer는 Java에서 문자열을 동적으로 변경하기 위한 클래스다. StringBuilder와 마찬가지로 문자열 연결이나 변경 작업을 수행할 때 사용된다. StringBuffer는 StringBuilder와 유사한 기능을 제공하지만, 다른 점은 StringBuffer가 쓰레드 안전(thread-safe)하다는 것이다.StringBuffer는 여러 쓰레드에서 동시에 접근하고 변경할 수 있는 경우에 사용된다. 내부적으로 동기화된 메서드를 사용하여 여러 쓰레드 간에 데이터 일관성을 유지할 수 있도록 한다. 따라서 멀티쓰레드 환경에서 문자열 조작이 필요한 경우, StringBuilder 대신 StringBuffer를 사용하는 것이 안전하다.StringBuilder와 마찬가지로 StringBuffer를 사용하는 방법은 매우 유사하다. 일반적인 사용 방법은 다음과 같다.  StringBuffer 객체 생성 :    StringBuffer sb = new StringBuffer();        문자열 추가 :    sb.append(\"Hello\");        문자열 삽입 :    sb.insert(5, \" World\");        문자열 삭제 :    sb.delete(5, 11);        문자열 수정 :    sb.replace(0, 5, \"Hi\");        문자열 반환 :    String result = sb.toString();      StringBuffer는 StringBuilder와 동일한 API를 제공하므로 사용 방법은 거의 동일하다. 다만 멀티 쓰레드 환경에서 사용될 때 동기화를 지원하여 쓰레드 안전성을 보장한다. 단일 쓰레드 환경에서는 StringBuilder를 사용하는 것이 성능상 이점이 있을 수 있다.",
        "url": "/stringbuilder-stringbuffer"
    }
    ,
    
    "stream": {
        "title": "[자바] Stream",
            "author": "jjaemin0224",
            "category": "",
            "content": "1. Stream이란컴퓨터 과학 및 정보 기술에서 사용되는 용어로, 데이터의 연속적인 흐름이나 시퀀스를 가리킨다. 일반적으로 데이터 스트림은 네트워크 통신, 파일 입출력, 센서 데이터 등 다양한 소스에서 나온 데이터를 의미한다.스트림은 한방향으로 데이터를 전송하며, 데이터가 연속적으로 흐른다. 이러한 특성으로 인해 스트림은 대용량 데이터나 실시간 데이터 처리에 매우 유용하다. 스트림을 사용하면 데이터를 한 번에 모두 메모리에 저장하지 않고 조각조각으로 나눠서 처리할 수 있다. 이는 시스템 자원을 효율적으로 활용하고 처리 속도를 향상시킬 수 있다.예를 들어, 영상 스트리밍 서비스를 생각해보면, 사용자는 영상 데이터를 실시간으로 받아보면서 동영상을 시청할 수 있다. 이때 서버에서는 영상 데이터를 스트림으로 전송하여 사용자의 디바이스에서 조금씩 받아올 수 있다. 이렇게 데이터를 조금씩 받아오면서 스트리밍 서비스는 지연 시간을 최소화하고 고품질의 동영상을 제공할 수 있다.스트림은 다양한 프로그래밍 언어와 플랫폼에서 지원되며, 데이터 처리, 입출력 작업, 네트워크 통신 등 다양한 분야에서 활용된다.2. Stream APIJava 8에서 추가된 Stream은 데이터를 처리하고 조작하기 위한 새로운 개념과 API이다. Stream API는 함수형 프로그래밍의 개념과 스트림 연산을 이용하여 컬렉션, 배열, I/O 자원 등의 데이터를 효율적으로 처리할 수 있도록 지원한다.Stream은 데이터 요소들의 연속적인 흐름을 나타내며, 다양한 연산을 수행하여 데이터를 변환, 필터링, 그룹화, 정렬 등을 할 수 있다. Stream API를 사용하면 반복문을 사용하지 않고도 데이터를 처리할 수 있으며, 코드의 가독성과 유지보수성을 향상시킬 수 있다.3. Stream API의 주요 특징  스트림은 데이터 소스로부터 데이터를 읽어올 수 있다. 이 데이터 소스는 컬렉션, 배열, I/O 채널, 메소드 등 다양한 형태일 수 있다.  스트림은 중간 연산과 최종 연산으로 구성된다. 중간 연산은 데이터를 변환, 필터링, 정렬 등을 수행하며, 최종 연산은 최종 결과를 생성하거나 반환한다.  스트림은 내부 반복을 이용하여 데이터를 처리한다. 이는 개발자가 직접 반복문을 작성하지 않고도 데이터를 처리할 수 있다는 것을 의미한다.  스트림은 지연 연산을 지원한다. 중간 연산을 수행할 때에는 실제로 데이터가 처리되지 않고, 최종 연산이 호출될 때에만 데이터가 처리된다. 이는 성능 최적화에 도움을 줄 수 있다.  스트림은 병렬 처리를 지원한다. 멀티 코어 환경에서 데이터를 병렬로 처리하여 처리 속도를 향상시킬 수 있다.Java 8의 Stream API는 함수형 인터페이스, 람다 식, 메서드 참조 등의 기능과 함께 사용되어 많은 유용한 연산을 제공하며, 코드를 간결하고 효율적으로 작성할 수 있도록 도와준다.",
        "url": "/stream"
    }
    ,
    
    "lombok": {
        "title": "[자바] Lombok",
            "author": "jjaemin0224",
            "category": "",
            "content": "1. Lombok 이란롬복(Lombok)은 Java 개발자들이 일상적으로 작성해야 하는 반복적인 코드를 줄여주는 Java 라이브러리다. 롬복은 자바 어노테이션을 기반으로 동작하며, 컴파일 시점에서 소스 코드를 분석하여 자동으로 Getter, Setter, 생성자, toString 메서드 등을 생성해준다.롬복을 사용하면 일반적으로 작성해야 하는 Getter와 Setter 메서드를 어노테이션만으로 대체할 수 있다. 또한, equals(), hashCode(), toString() 메서드 등을 자동으로 생성해주어 객체의 비교나 문자열 표현을 간편하게 할 수 있다. 롬복은 이 외에도 불변 클래스 생성, 빌더 패턴 지원 등의 기능을 제공한다.롬복을 사용하면 코드의 양을 줄일 수 있으므로 개발자는 더 간결하고 가독성이 좋은 코드를 작성할 수 있다. 또한, 롬복이 자동으로 생성해주는 코드는 컴파일 단계에서 생성되기 때문에 런타임 오버헤드가 발생하지 않는다.롬복은 자바 개발 도구와 호환되며, 대부분의 인기 있는 IDE(통합 개발 환경)에서 지원한다. 롬복의 주요 어노테이션에는 ‘@Getter’, ‘@Setter’, ‘@NoArgsConstructor’, ‘@AllArgConstructor’, ‘@ToString’, ‘@EqualsAndHashCode’, ‘@Builder’ 등이 있다.롬복은 개발자의 생산성을 향상시키고 반복적인 작업을 최소화하는 데 도움을 주는 유용한 도구다.2. 롬복(Lombok)의 주요 어노테이션  ‘@Getter’, ‘@Setter’ : 필드에 적용하여 자동으로 Getter와 Setter 메서드를 생성한다. 해당 필드의 값을 가져오거나 설정하는 메서드를 자동으로 생성해주는 역할을 한다.  ‘@NoArgsConstructor’, ‘@AllArgConstructor’ : 클래스에 적용하여 매개변수가 없는 기본 생성자(‘@NoArgsConstructor’)와 모든 필드를 매개변수로 받는 생성자(‘@AllArgConstructor’)를 자동으로 생성한다.  ‘@ToString’ : 클래스에 적용하여 ‘toString()’ 메서드를 자동으로 생성한다. ‘toString()’ 메서드는 객체의 문자열 표현을 반환하는데 사용되며, 주로 디버깅이나 로깅 용도로 활용된다.  ‘@EqualsAndHashCode’ : 클래스에 적용하여 ‘equals()’와 ‘hashCode()’ 메서드를 자동으로 생성한다. 이 메서드들은 객체의 동등성 비교와 해시 코드 계산에 사용된다.  ‘@Builder’ : 클래스나 생성자에 적용하여 빌더 패턴을 자동으로 생성한다. 빌더 패턴은 객체 생성을 유연하고 가독성 있게 만들어주는 패턴으로, 복잡한 객체를 생성할 때 사용된다.",
        "url": "/lombok"
    }
    ,
    
    "jvm": {
        "title": "[자바] JVM",
            "author": "jjaemin0224",
            "category": "",
            "content": "1. JVM이란 무엇인가JAVA Virtual Machine(자바 가상 머신)의 약자로, 자바의 바이트 코드를 실행할 수 있는 주체이다. 자바 바이트 코드는 운영체제(OS)에 독립적이며 모든 JVM은 규격에 정의된 대로 자바 바이트 코드를 실행한다. 또한 JVM은 자바 애플리케이션을 클래스 로더를 통해 읽어 들여 자바 API와 함께 실행한다.2. JVM의 메모리 구조응용 프로그램이 실행되면, JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고 JVM은 이 메모리를 용도에 따라 여러 영역으로 나눈다.2-1. Class Loaderjava에서 소스를 작성하면 .java파일이 생성되며 이 소스를 컴파일하면 .class파일(ByteCode)이 생성된다. 이렇게 생성된 .class파일들을 엮어서 JVM이 운영체제로 할당 받은 메모리 영역인 Runtime Data Area로 적재(Loading)한다.2-2. Excution Engine메모리에 적재된 클래스(ByteCode)들을 기계어(BinaryCode)로 변경하여 명령어 단위로 실행하는 역할을 한다. 인터프리터(Interpreter)방식과 JIT(Just-In-Time) 컴파일러를 사용하는 두 가지 방식이 있다.  Interpreter : 명령어를 하나씩 실행하는 대화형식 컴파일. 파이썬이 대표적인 인터프리터 언어  JIT(Just-In-Time) Compiler : 적적한 시간에 전체 바이트 코드를 네이티브 코드로 변경해서 실행하므로 성능이 인터프리터보다 속도 면에서 성능이 좋다.    2-3. Garbage Collector    Garbage Collector(GC)는 Heap 메모리 영역에 적재된 객체들 중 참조되지 않는 객체들을 탐색(애플리케이션이 생성한 객체의 생존 여부) 후 제거하는 역할을 한다. GC가 역할을 수행하는 시간을 정확히 언제인지 알 수 없다. GC의 또 다른 특징으로는 GC가 수행되는 동안 GC를 수행하는 쓰레드가 아닌 다른 모든 쓰레드가 일시 정지된다.    2-4. Runtime Data Area    JVM의 메모리 영역으로 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역이다. 이 영역은 크게 Method Area, Heap Area, Stack Area, PC Register, Natice Method Stack으로 나눌 수 있다.  3. Runtime Data Area 영역 분류3-1. Method Area (메소드 영역)클래스 멤버 변수의 이름, 데이터 타입, 접근 제어자 정보 같은 field 정보들과 메소드의 이름, return 타입, 파라미터, 접근 제어자 정보 같은 method 정보들, type 정보, Constant Pool, static 변수, final class 변수 등이 생성되는 영역3-2. Stack Area (스택 영역)지역 변수, 파라미터, 리턴 값, 연산에 사용되는 임시 값, 메소드 호출 등 임시적인 데이터들이 생성되는 영역. 정적 메모리 할당이 이루어지는 장소로 Heap 영역에 동적 할당된 값에 대한 참조를 얻을 수 있다.ex. Person P = new Person(); 에서 Person P는 Stack 영역, new Person();은 Heap 영역에 할당3-3. PC Register쓰레드가 생성될 때마다 생성되는 영역으로 쓰레드마다 하나씩 존재한다. 현재 쓰레드가 실행되는 부분의 주소와 명령을 저장하고 있는 영역이다. 이것을 이용하여 쓰레드를 돌아가면서 수행할 수 있도록 한다.3-4. Native Method Stack자바 외의 언어로 작성된 Native 코드를 위한 메모리 영역. 보통 C/C++ 등의 코드를 수행하기 위한 Stack3-5. Meta Space애플리케이션의 클래스나 메서드 정보, 또는 static으로 정의된 멤버 변수가 저장된 영역. 이전 버전의 Permanent 영역에 해당함.3-6. Code CacheJIT(Just-In-Time) 컴파일러가 데이터를 저장하는 영역으로, 자주 접근하는 ‘컴파일된 코드 블록’이 저장된다. 이곳에 저장된 코드는 기계어로 이미 변환된 채 Cache되어 있어서 빠르게 실행할 수 있다.3-7. Shared Library애플리케이션에서 사용할 공유 라이브러리가 기계어로 변환된 채 저장된 영역. 해당 OS에서 프로세스당 한 번씩 로드된다.3-8. Heap Area (힙 영역)new 키워드로 생성된 객체와 배열이 생성되는 영역(즉, 인스턴스 변수(Instance Variable)가 생기는 영역)이다. 메소드 영역에 로드된 클래스만 생성이 가능하고, GC가 참조되지 않는 메모리를 확인하고 제거하게 된다.4. Heap 영역의 분류heap 영역은 현재 4개의 영역으로 나뉘는데 GC를 더욱 효율적으로 사용하기 위함이다.JDK 7 까지는 permanent 영역이 heap에 존재했지만 JDK 8 부터는 permanent 영역은 사라지고 일부가 “meta space” 영역으로 변경되어 native stack 영역에 포함되었다.GC는 Minor GC와 Major GC로 나뉜다.4-1. Minor GC : New 영역에서 일어나는 GC  최초로 객체가 생성되면 Eden 영역에 생성된다.  Eden 영역에 객체가 가득 차면 첫 번째 GC가 일어난다.  survivor1 영역에 Eden 영역의 메모리를 그대로 복사하고, 해당 영역을 제외한 다른 영역의 객체를 모두 제거한다.  Eden 영역의 메모리도 가득 차고 survivor1 영역의 메모리도 가득 차게 되면, Eden 영역에 생성된 객체와 survivor1 영역에 생성된 객체 중 참조되고 있는 객체가 있는지를 검사한다.  참조되고 있는 않은 객체를 제외한 참조되고 있는 객체만 survivor2 영역에 복사한다.  survivor2 영역을 제외한 다른 영역의 객체들을 제거한다.  위의 과정 중 일정 횟수 이상 참조되고 있는 객체들을 survivor2 영역에서 Old 영역으로 이동시킨다.    4-2. Major GC (Full GC) : Old 영역에서 일어나는 GC    Old 영역에 있는 모든 객체들을 검사하며 참조되고 있는지 확인한다.  참조되지 않은 객체들을 모아 한 번에 제거한다.(이 때 Minor GC보다 시간이 많이 걸리고 실행 중 GC를 제외한 모든 쓰레드는 중지된다.) Major GC가 일어나게 되면 Old 영역에 있는 참조가 없는 객체들을 표시하고 그 해당 객체들을 모두 제거하게 된다. 그 후 Heap 영역은 빈 공간이 생기는데 이 부분을 없애기 위해 재구성을 시행한다. 이 때 메모리를 옮기는데 다른 쓰레드가 메모리를 사용해버리면 안되므로 모든 쓰레드가 정지하게 되는 것이다.",
        "url": "/jvm"
    }
    ,
    
    "java-basic": {
        "title": "[자바] JAVA란?",
            "author": "jjaemin0224",
            "category": "",
            "content": "1. 자바(JAVA)란 무엇인가?썬 마이크로시스템즈에서 1995년에 개발한 객체 지향 프로그래밍 언어이다. 창시자는 제임스 고슬링이다. 처음에는 가전제품 내에 탑재해 동학하는 프로그램을 위해 개발했지만 현재는 웹 애플리케이션과 모바일 앱 개발에 가장 많이 사용하는 언어이다.2. 자바(JAVA)의 장점2-1. 독립적인 운영체제JVM에서 동작하기 때문에, 특정 운영체제에 종속되지 않는다.2-2. 객체 지향 언어객체지향적으로 프로그래밍 하기 위해 여러 언어적 지원을 하고 있다. (캡슐화, 상속, 추상화, 다형성 등)객체지향 패러다임의 특성상 비교적 이해하고 배우기 쉽다.2-3. 메모리 관리 자동JVM에서 Garbage Collector라고 불리는 Demon Thread에 의해 GC(Garbage Collection)가 일어난다. GC로 인해 별도의 메모리 관리가 필요 없으며, 비지니스 로직에 집중할 수 있다.2-4. 오픈 소스정확히 말하면 OpenJDK가 오픈소스다. 많은 Java 개발자가 존재하고 생태계가 잘 구축되어있다. 덕분에 오픈소스 라이브러리가 풍부하며 잘 활용한다면 짧은 개발시간내에 안정적인 애플리케이션을 쉽게 구현할 수 있다.2-5. 멀티 쓰레드자바는 쓰레드 생성 및 제어와 관련된 라이브러리 API를 제공하고 있기 때문에 실행되는 운영체제에 상관없이 멀티스레드를 쉽게 구현할 수 있다.2-6. 동적 로딩(Dynamic Loading)애플리케이션이 실행될 때 모든 객체가 생성되지 않고, 각 객체가 필요한 시점에 클래스를 동적 로딩해서 생성한다. 또한 유지보수 시 해당 클래스만 수정하면 되기 때문에 전체 애플리케이션을 다시 컴파일할 필요가 없다. 따라서 유지보수가 쉽고 빠르다.3. 자바(JAVA)의 단점3-1. 비교적 느린 속도자바는 한 번의 컴파일링으로 실행 가능한 기계어가 만들어지지 않고 JVM에 의해 기계어로 번역되고 실행하는 과정을 거치기 때문에 C나 C++의 컴파일 단계에서 만들어지는 완전한 기계어보다 속도가 느리다. 그러나 하드웨어의 성능 향상과 바이트 코드를 기계어로 변환해주는 JIT 컴파일러 같은 기술 적용으로 JVM의 기능이 향상되어 속도의 격차가 많이 줄어들었다.3-2. 예외처리프로그래머 검사가 필요한 예외가 등장한다면 무조건 프로그래머가 선언을 해줘야 한다.",
        "url": "/java_basic"
    }
    ,
    
    "python-control-statement": {
        "title": "Python Posting 테스트2입니다.",
            "author": "jjaemin0224",
            "category": "",
            "content": "python 테스트2입니다.",
        "url": "/python_control_statement"
    }
    ,
    
    "python-basic": {
        "title": "Python Posting 테스트입니다.",
            "author": "jjaemin0224",
            "category": "",
            "content": "python 테스트입니다.",
        "url": "/python_basic"
    }
    
    
    };
</script>
<script src="assets/js/lunr.js"></script>
<script src="assets/js/search.js"></script>
            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://jjaemin0224.github.io/">Jaemin's BLOG</a> &copy; 2023</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyllt/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
        <div id="subscribe" class="subscribe-overlay">
            <a class="subscribe-overlay-close" href="#"></a>
            <div class="subscribe-overlay-content">
                
                <h1 class="subscribe-overlay-title">Search to Jaemin's BLOG</h1>
                <p class="subscribe-overlay-description">게시물 제목을 검색하세요!</p>
                <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  />
    <input class="location" type="hidden" name="location"  />
    <input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()" 
               id="searchtext" type="text" name="searchtext"  
               placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>

            </div>
        </div>
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', '', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
