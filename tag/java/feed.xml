<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://jjaemin0224.github.io/tag/java/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://jjaemin0224.github.io/" rel="alternate" type="text/html" />
  <updated>2023-07-06T20:40:56+09:00</updated>
  <id>https://jjaemin0224.github.io/tag/java/feed.xml</id>

  
  
  

  
    <title type="html">Jaemin’s BLOG | </title>
  

  
    <subtitle>The only limit is your mind.</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">[자바] Queue</title>
      <link href="https://jjaemin0224.github.io/queue" rel="alternate" type="text/html" title="[자바] Queue" />
      <published>2023-06-28T12:30:00+09:00</published>
      <updated>2023-06-28T12:30:00+09:00</updated>
      <id>https://jjaemin0224.github.io/queue</id>
      <content type="html" xml:base="https://jjaemin0224.github.io/queue">&lt;hr /&gt;
&lt;h2 id=&quot;1-queue&quot;&gt;1. Queue&lt;/h2&gt;
&lt;p&gt;자바에서 Queue는 자료 구조의 한 종류로, 선입선출(FIFO, First-In-First-Out) 원칙을 따르는 컬렉션입니다. 큐는 요소들을 순서대로 저장하고, 새로운 요소는 큐의 끝에 추가되며, 요소들은 큐의 앞에서 제거됩니다.&lt;/p&gt;

&lt;p&gt;자바에서 Queue 인터페이스는 java.util 패키지에 정의되어 있으며, 다양한 구현체들이 제공됩니다. Queue 인터페이스는 다음과 같은 주요 메서드를 포함하고 있습니다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;boolean add(E element): 큐의 끝에 요소를 추가합니다. 큐에 공간이 부족한 경우 예외를 발생시킵니다.&lt;/li&gt;
  &lt;li&gt;boolean offer(E element): 큐의 끝에 요소를 추가합니다. 큐에 공간이 부족한 경우 false를 반환합니다.&lt;/li&gt;
  &lt;li&gt;E remove(): 큐의 앞에서 요소를 제거하고 반환합니다. 큐가 비어있는 경우 예외를 발생시킵니다.&lt;/li&gt;
  &lt;li&gt;E poll(): 큐의 앞에서 요소를 제거하고 반환합니다. 큐가 비어있는 경우 null을 반환합니다.&lt;/li&gt;
  &lt;li&gt;E element(): 큐의 앞에 있는 요소를 반환합니다. 큐가 비어있는 경우 예외를 발생시킵니다.&lt;/li&gt;
  &lt;li&gt;E peek(): 큐의 앞에 있는 요소를 반환합니다. 큐가 비어있는 경우 null을 반환합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;일반적으로 LinkedList나 ArrayDeque 등이 Queue 인터페이스를 구현한 클래스로 사용됩니다. Queue는 대기열 관리, 이벤트 처리, 작업 스케줄링 등 다양한 상황에서 유용하게 활용될 수 있습니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;2-queue-활용&quot;&gt;2. Queue 활용&lt;/h2&gt;
&lt;p&gt;Queue는 다양한 상황에서 사용될 수 있습니다. 몇 가지 대표적인 Queue 사용 예시를 살펴보겠습니다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;대기열 관리: Queue는 대기열을 관리하는 데 사용될 수 있습니다. 예를 들어, 고객 서비스 대기열, 작업 큐 등에서 사용됩니다. 새로운 요청이 도착하면 큐에 추가되고, 처리할 준비가 된 요소는 큐에서 제거되어 처리됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이벤트 처리: 이벤트 기반 시스템에서는 이벤트가 발생한 순서대로 처리해야 할 때 Queue가 유용합니다. 이벤트가 발생하면 해당 이벤트를 큐에 추가하고, 이벤트 처리기가 큐에서 이벤트를 하나씩 가져와 처리합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;멀티스레드 환경: 큐는 멀티스레드 환경에서 작업을 조율하는 데 사용될 수 있습니다. 한 스레드에서 작업을 생성하고 큐에 추가하면, 다른 스레드에서는 큐에서 작업을 가져와 처리할 수 있습니다. 이를 통해 스레드 간의 작업 분배와 동기화를 쉽게 구현할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;네트워크 통신: 네트워크 프로그래밍에서는 요청을 받아들이고 처리하기 위해 큐를 사용할 수 있습니다. 클라이언트 요청을 큐에 추가하고, 서버에서는 큐에서 요청을 가져와 처리합니다. 이를 통해 요청의 동시 처리와 순서 보장을 할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 외에도 데이터 버퍼링, 탐색 알고리즘 등 다양한 상황에서 Queue를 활용할 수 있습니다. 실제로는 Queue 인터페이스를 구현한 클래스 중 하나를 선택하여 해당 상황에 맞게 활용하게 됩니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;3-queue-예시&quot;&gt;3. Queue 예시&lt;/h2&gt;

&lt;h4 id=&quot;코드&quot;&gt;코드&lt;/h4&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.LinkedList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.Queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Main&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LinkedList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 요소 추가&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;offer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;A&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;offer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;B&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;offer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;C&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 큐의 첫 번째 요소 확인&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;firstElement&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;peek&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;첫 번째 요소: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;firstElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 큐의 첫 번째 요소 제고&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;removeElement&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;poll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;제거된 요소: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;removeElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 큐의 크기 확인&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;큐의 크기: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 큐가 비어있는지 확인&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isEmpty&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isEmpty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;큐가 비어있는가? &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isEmpty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;실행결과&quot;&gt;실행결과&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;첫 번째 요소: A
제거된 요소: A
큐의 크기: 2
큐가 비어있는가? false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;offer(element): 큐의 끝에 요소를 추가합니다.&lt;/li&gt;
  &lt;li&gt;peek(): 큐의 첫 번째 요소를 확인합니다. 큐가 비어있을 경우 null을 반환합니다.&lt;/li&gt;
  &lt;li&gt;poll(): 큐의 첫 번째 요소를 제거하고 반환합니다. 큐가 비어있을 경우 null을 반환합니다.&lt;/li&gt;
  &lt;li&gt;size(): 큐의 크기를 반환합니다.&lt;/li&gt;
  &lt;li&gt;isEmpty(): 큐가 비어있는지 여부를 확인합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;4-queue-장점&quot;&gt;4. Queue 장점&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;데이터의 순서를 보장 &lt;br /&gt;
 Queue는 데이터를 순서대로 저장하고 처리하는 자료구조입니다. 데이터가 들어온 순서대로 처리해야 하는 경우, Queue를 사용하여 순서를 보장할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;대기열 관리 &lt;br /&gt;
 Queue는 대기열을 관리하는 데에 적합합니다. 작업이 도착한 순서대로 처리해야 하는 상황에서 Queue를 사용하면, 작업을 대기열에 추가하고 순차적으로 처리할 수 있습니다. 예를 들어, 작업 큐나 이벤트 큐 등을 구현할 때 Queue를 활용합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;비동기 처리 &lt;br /&gt;
 Queue는 비동기적인 작업 처리에 유용합니다. 비동기 작업을 수행할 때, 작업을 Queue에 추가하고 다른 작업을 계속 처리할 수 있습니다. Queue에서 작업을 꺼내어 처리하는 동안 다른 작업이 도착하면 대기열에 추가됩니다. 이를 통해 비동기적인 작업 흐름을 관리하고 조절할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;자원 공유와 동기화 &lt;br /&gt;
 Queue는 다중 스레드 환경에서의 자원 공유와 동기화에 사용될 수 있습니다. 여러 스레드가 공유 자원에 접근해야 할 때, Queue를 사용하여 스레드 간 작업을 조율하고 동기화할 수 있습니다. 스레드 간의 작업 순서를 보장하고 상호간의 안전한 통신을 위해 Queue를 활용합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;알고리즘 및 데이터 구조 구현 &lt;br /&gt;
 Queue는 다양한 알고리즘과 데이터 구조를 구현하는 데에 사용됩니다. 예를 들어, 너비 우선 탐색(BFS) 알고리즘, 캐시 구현, 버퍼 관리, 라운드 로빈 스케줄링 등에서 Queue를 활용합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Queue는 위와 같은 이유로 다양한 상황에서 사용되며, 데이터의 순서를 관리하고 작업을 조율하는 데에 유용한 자료구조입니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>jjaemin0224</name>
        
        
      </author>

      

      
        <category term="java" />
      

      
        <summary type="html">1. Queue 자바에서 Queue는 자료 구조의 한 종류로, 선입선출(FIFO, First-In-First-Out) 원칙을 따르는 컬렉션입니다. 큐는 요소들을 순서대로 저장하고, 새로운 요소는 큐의 끝에 추가되며, 요소들은 큐의 앞에서 제거됩니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">[자바] 인터페이스(Interface)</title>
      <link href="https://jjaemin0224.github.io/interface" rel="alternate" type="text/html" title="[자바] 인터페이스(Interface)" />
      <published>2023-03-20T12:30:00+09:00</published>
      <updated>2023-03-20T12:30:00+09:00</updated>
      <id>https://jjaemin0224.github.io/interface</id>
      <content type="html" xml:base="https://jjaemin0224.github.io/interface">&lt;hr /&gt;
&lt;h2 id=&quot;1-인터페이스-interface&quot;&gt;1. 인터페이스 (Interface)&lt;/h2&gt;
&lt;p&gt;인터페이스는 추상화된 타입을 정의하는 역할을 합니다. 인터페이스는 메서드 시그니처(메서드의 이름, 매개변수, 변환 타입)를 선언하고, 구현체 클래스에서 이러한 메서드를 구현하도록 요구합니다.&lt;/p&gt;

&lt;p&gt;인터페이스는 클래스와 클래스 간의 계약(contract)을 정의하며, 다형성(polymorphism)을 지원합니다. 인터페이스를 구현한 클래스들은 동일한 인터페이스 타입으로 다룰 수 있고, 이를 통해 유연하고 확장 가능한 코드를 작성할 수 있습니다. 또한, 인터페이스를 이용하여 의존성을 낮추고 모듈화된 시스템을 구축할 수 있습니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;2-장점&quot;&gt;2. 장점&lt;/h2&gt;
&lt;h4 id=&quot;2-1-다형성과-추상화&quot;&gt;2-1. 다형성과 추상화&lt;/h4&gt;
&lt;p&gt;인터페이스는 다형성을 지원하고, 추상화된 타입을 정의할 수 있습니다. 인터페이스를 구현한 다양한 클래스들을 동일한 인터페이스 타입으로 다룰 수 있으며, 이를 통해 유연하고 확장 가능한 코드를 작성할 수 있습니다. 인터페이스는 클래스와 클래스 간의 계약을 정의하고, 이를 통해 코드의 의도로 명확하게 전달할 수 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;2-2-계약과-규약&quot;&gt;2-2. 계약과 규약&lt;/h4&gt;
&lt;p&gt;인터페이스는 클래스가 어떤 메서드를 반드시 구현해야 하는지를 명시적으로 정의합니다. 이를 통해 인터페이스를 구현한 클래스들은 동일한 메서드를 가지고 있음이 보장됩니다. 인터페이스는 계약(Contract)을 정의하며, 이는 클래스 간의 상호작용을 원활하게 합니다.&lt;/p&gt;

&lt;h4 id=&quot;2-3-코드의-유연성과-재사용성&quot;&gt;2-3. 코드의 유연성과 재사용성&lt;/h4&gt;
&lt;p&gt;인터페이스를 사용하면 클래스의 구현과 인터페이스의 정의를 분리할 수 있습니다. 이는 ㅋ도의 유연성과 재사용성을 높이는데 도움을 줍니다. 인터페이스는 구현한 다른 클래스를 사용하거나 새로운 클래스를 작성하여 인터페이스를 구현할 수 있으므로, 코드의 변경이나 확장이 용이해집니다.&lt;/p&gt;

&lt;h4 id=&quot;2-4-팁-작업과-코드-유지-보수&quot;&gt;2-4. 팁 작업과 코드 유지 보수&lt;/h4&gt;
&lt;p&gt;인터페이스는 여러 개발자들이 동일한 인터페이스를 기준으로 작업할 수 있게 합니다. 인터페이스를 정의하여 필요한 기능과 규칙을 명확히 전달할 수 있으며, 이는 팀의 협업과 코드의 유지 보수를 용이하게 합니다.&lt;/p&gt;

&lt;h4 id=&quot;2-5-라이브러리와-프레임워크의-기반&quot;&gt;2-5. 라이브러리와 프레임워크의 기반&lt;/h4&gt;
&lt;p&gt;많은 자바 라이브러리와 프레임워크는 인터페이스를 활용하여 구현되어 있습니다. 인터페이스는 라이브러리나 프레임워크의 핵심 기능을 정의하고, 사용자가 해당 인터페이스를 구현하여 원하는 기능을 추가할 수 있도록 합니다.&lt;/p&gt;

&lt;p&gt;인터페이스는 자바에서 객체 지향 프로그래밍의 핵심 원칙인 추상화, 다형성, 계약 등을 구현하는 데 중요한 도구입니다. 이를 적절히 활용하여 유연하고 확장 가능한 코드를 작성할 수 있습니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;3-활용-예시&quot;&gt;3. 활용 예시&lt;/h2&gt;
&lt;h4 id=&quot;3-1-코드-예시&quot;&gt;3-1. 코드 예시&lt;/h4&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 동물 인터페이스&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Animal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;makeSound&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 강아지 클래스&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Dog&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Animal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;makeSound&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;멍멍!&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 고양이 클래스&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Cat&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Animal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;makeSound&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;야옹~&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 메인 클래스&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Main&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Animal&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dog&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Dog&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Animal&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Cat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;dog&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;makeSound&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 멍멍! 출력&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;makeSound&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 야옹~ 출력&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 예시에서는 ‘Animal’ 인터페이스를 정의하고, ‘Dog’와 ‘Cat’클래스가 이 인터페이스를 구현합니다. ‘Animal’ 인터페이스는 ‘makeSound’라는 추상 메서드를 가지고 있습니다. 각각의 구현 클래스는 이 메서드를 재정의하여 동물의 소리를 출력합니다.&lt;/p&gt;

&lt;p&gt;메인 클래스에서는 ‘Dog’와 ‘Cat’ 객체를 생성하고, ‘makeSound’ 메서드를 호출하여 각각의 동물 소리를 출력합니다. 이를 통해 인터페이스를 사용하여 다양한 동물 클래스를 동일한 인터페이스 타입으로 다룰 수 있으며, 동적으로 동물 객체를 바꿔가며 소리를 출력할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이 예시는 인터페이스를 통해 다형성을 구현하고, 코드의 확장성과 유연성을 높이는 좋은 예시입니다. 인터페이스를 활용하면 코드를 더 추상화하고 재사용성을 높을 수 있으며, 객체 간의 결합도를 낮추어 유지 보수성을 향상시킬 수 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;3-2-클래스-대신-인터페이스를-사용한-이유&quot;&gt;3-2. 클래스 대신 인터페이스를 사용한 이유&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;다중 상속의 제약 &lt;br /&gt;
 자바는 단일 상속만을 지원합니다. 클래스로 정의할 경우 ‘Dog’나 ‘Cat’클래스가 이미 다른 클래스를 상속하고 있다면 ‘Animal’ 클래스를 상속받을 수 없게 됩니다. 하지만 인터페이스는 다중 상속을 지원하므로 ‘Dog’나 ‘Cat’클래스가 이미 다른 클래스를 상속하고 있더라도 ‘Animal’인터페이스를 구현할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;유현한 구현 변경 &lt;br /&gt;
 ‘Animal’ 인터페이스를 사용하면 ‘Dog’클래스 대신 다른 동물 클래스를 구현하여 ‘Aniaml’ 인터페이스를 사용할 수 있습니다. 예를 들어 ‘Bird’클래스를 구현하고 ‘makeSound’ 메서드를 재정하면 새의 소리를 출력할 수 있습니다. 이렇게 인터페이스를 사용하면 기존 코드의 변경 없이 새로운 동물 클래스를 추가하거나 교체할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;계약의 강제 &lt;br /&gt;
 인터페이스는 클래스가 반드시 구현해야 하는 메서드를 정의하므로 계약(Contract)의 역할을 수행합니다. ‘Animal’ 인터페이스에서 ‘makeSound’메서드를 선언하면 해당 인터페이스를 구현하는 클래스는 ‘makeSound’메서드를 반드시 구현해야 합니다. 이를 통해 코드의 일관성과 안정성을 높일 수 있습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;결론적으로, 인터페이스를 사용하면 다중 상속의 제약을 피하고 유연한 구현 변경을 가능케 하며, 계약의 강제를 통해 코드의 일관성을 유지할 수 있습니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;4-활용-시-주의해야-할-점&quot;&gt;4. 활용 시 주의해야 할 점&lt;/h2&gt;

&lt;h4 id=&quot;4-1-추가-작업의-필요성&quot;&gt;4-1. 추가 작업의 필요성&lt;/h4&gt;
&lt;p&gt;인터페이스를 사용하면 클래스에 구현해야 하는 메서드를 정의해야 합니다. 따라서 인터페이스를 사용하면 클래스를 작성할 때 추가 작업이 필요합니다. 인터페이스의 메서드를 구현해야 하기 때문에 개발자는 구현에 필요한 코드를 작성해야 합니다. 이는 일부 개발자들에게 번거로울 수 있습니다.&lt;/p&gt;
&lt;h4 id=&quot;4-2-설계-복잡성&quot;&gt;4-2. 설계 복잡성&lt;/h4&gt;
&lt;p&gt;인터페이스를 적절하게 설계하는 것은 중요한 과정입니다. 인터페이스의 메서드를 올바르게 정의하고 계약을 명확히 전달해야 합니다. 잘못된 인터페이스 설계는 코드의 복잡성을 증가시킬 수 있고, 유지 보수가 어려워질 수 있습니다.&lt;/p&gt;
&lt;h4 id=&quot;4-3-업데이트-관리&quot;&gt;4-3. 업데이트 관리&lt;/h4&gt;
&lt;p&gt;터페이스는 변경 가능성이 있는 코드 요소입니다. 인터페이스에 새로운 메서드를 추가하거나 기존 메서드를 수정하는 경우, 해당 인터페이스를 구현한 모든 클래스에 변경 사항을 반영해야 합니다. 이는 업데이트 관리에 번거로움을 초래할 수 있습니다.&lt;/p&gt;
&lt;h4 id=&quot;4-4-과도한-인터페이스-사용&quot;&gt;4-4. 과도한 인터페이스 사용&lt;/h4&gt;
&lt;p&gt;너무 많은 인터페이스를 사용하면 코드의 가독성과 이해도가 떨어질 수 있습니다. 인터페이스를 과도하게 사용하면 클래스 간의 관계를 이해하기 어려울 수 있으며, 코드의 복잡성이 증가할 수 있습니다.&lt;/p&gt;
&lt;h4 id=&quot;4-5-한정적인-접근-제어&quot;&gt;4-5. 한정적인 접근 제어&lt;/h4&gt;
&lt;p&gt;인터페이스에서 선언한 메서드는 기본적으로 ‘public’으로 선언됩니다. 따라서 인터페이스를 구현하는 클래스는 해당 메서드를 ‘public’으로 구현해야 합니다. 이는 메서드의 접근 범위를 제한하는데 어려움을 줄 수 있습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>jjaemin0224</name>
        
        
      </author>

      

      
        <category term="java" />
      

      
        <summary type="html">1. 인터페이스 (Interface) 인터페이스는 추상화된 타입을 정의하는 역할을 합니다. 인터페이스는 메서드 시그니처(메서드의 이름, 매개변수, 변환 타입)를 선언하고, 구현체 클래스에서 이러한 메서드를 구현하도록 요구합니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">[자바] 람다(Lambda)</title>
      <link href="https://jjaemin0224.github.io/lambda" rel="alternate" type="text/html" title="[자바] 람다(Lambda)" />
      <published>2023-03-20T12:30:00+09:00</published>
      <updated>2023-03-20T12:30:00+09:00</updated>
      <id>https://jjaemin0224.github.io/lambda</id>
      <content type="html" xml:base="https://jjaemin0224.github.io/lambda">&lt;hr /&gt;
&lt;h2 id=&quot;1-람다-lambda&quot;&gt;1. 람다 (Lambda)&lt;/h2&gt;
&lt;p&gt;자바에서 람다식은 함수형 프로그래밍 스타일을 지원하기 위해 JDK 8부터 도입된 기능입니다. 람다식은 익명 함수(Anonymous Function)를 간결하게 표현하는 방법입니다.&lt;/p&gt;

&lt;p&gt;람다식은 일반적으로 함수형 인터페이스(Functional Interface)를 구현하는데 사용됩니다. 함수형 인터페이스는 단 하나의 추상 메서드를 가진 인터페이스를 말하며, 이 추상 메서드는 람다식으로 표현될 수 있습니다. 람다식은 함수형 인터페이스의 추상 메서드를 구현한 익명 객체를 생성하는 방식으로 사용됩니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;2-활용-1&quot;&gt;2. 활용 1&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;문자열 리스트에서 길이가 5이상인 문자열만 필터링
~~~java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;public class Main {&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main(String[] args) {
    List&amp;lt;String&amp;gt; strings = Arrays.asList(&quot;apple&quot;, &quot;banana&quot;, &quot;kiwi&quot;, &quot;orange&quot;, &quot;grape&quot;);

    List&amp;lt;String&amp;gt; filteredStrings = filterStrings(strings, s -&amp;gt; s.length() &amp;gt;= 5);

    System.out.println(filteredStrings); 
    // 출력: [apple, banana, orange, grape]
}

public static List&amp;lt;String&amp;gt; filterStrings(List&amp;lt;String&amp;gt; strings, StringFilter filter) {
    List&amp;lt;String&amp;gt; filteredList = new ArrayList&amp;lt;&amp;gt;();

    for (String s : Strings) {
        if (filter.test(s)) {
            filteredList.add(s)
        }
    }

    return filteredList;
}

public interface StringFilter {
    boolean test(String s);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;}&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
위 예시에서는 &apos;filterStrings&apos; 메서드를 사용하여 문자열 리스트를 필터링하는 기능을 구현하였습니다. &apos;StringFilter&apos;라는 함수형 인터페이스를 정의하고, 이 인터페이스의 &apos;test&apos;메서드를 통해 문자열을 필터링합니다.

람다식은 &apos;filterStrings&apos; 메서드의 두 번째 매개변수로 전달되어 필터링 조건을 정의합니다. 이를 통해 길이가 5이상인 문자열만 필터링하여 결과 리스트에 추가합니다.

&apos;main&apos;메서드에서는 예시로 주어진 문자열 리스트에서 길이가 5이상인 문자열을 필터링한 결과를 출력합니다.

이 예시에서 람다식을 사용하여 인터페이스를 구현함으로써, 필터링 조건을 유연하게 전달할 수 있습니다. 이러한 접근 방식은 코드의 재사용성과 가독성을 높이는데 도움을 줍니다. 또한, 함수형 프로그래밍 스타일을 적용하여 데이터를 변형하거나 처리하는 작업에 유용하게 사용할 수 있습니다.

---
## 3. 활용 2
- 가격에 따라 정렬
~~~java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List&amp;lt;Product&amp;gt; products = new ArrayList&amp;lt;&amp;gt;();
        products.add(new Product(&quot;Apple&quot;, 1000)):
        products.add(new Product(&quot;Banana&quot;, 500)):
        products.add(new Product(&quot;Orange&quot;, 1500)):
        products.add(new Product(&quot;Grape&quot;, 2000)):

        System.out.println(&quot;정렬 전:&quot;);
        printProducts(products);

        // 가격에 따라 오름차순으로 정렬
        Collections.sort(products, (p1, p2) -&amp;gt; p1.getPrice() - p2.getPrice());

        System.out.println(&quot;가격 오름차순 정렬 후:&quot;)
        printProducts(products);

    }

    public static void printProducts(List&amp;lt;Product&amp;gt; products) {
        for (Product product : products) {
            System.out.println(product);
        }
        System.out.println();
    }

    public static class Product {
        private String name;
        private int price;

        public Product(String name, int price) {
            this.name = name;
            this.price = price;
        }
    }

    public String getName() {
        return name;
    }

    public int getPrice() {
        return price;
    }

    @Override
    public String toString() {
        return &quot;Product&quot; + 
               &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +
               &quot;, price=&quot; + price +
               &apos;}&apos;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 예시에서는 ‘Product’ 클래스를 정의하고, 이를 이용하여 물건의 이름과 가격을 담고 있는 ‘products’ 리스트를 생성합니다. 그리고 람다식을 사용하여 ‘Collections.sort()’ 메서드를 호출하여 가격에 따라 오름차순으로 ‘products’ 리스트를 정렬합니다.&lt;/p&gt;

&lt;p&gt;‘Product’ 클래스는 물건의 이름과 가격을 담는 데이터를 표현하기 위한 클래스입니다. ‘printProducts’ 메서드는 ‘products’ 리스트의 내용을 출력하는 역할을 합니다.&lt;/p&gt;

&lt;p&gt;‘main’ 메서드에서는 ‘products’ 리스트를 생성하고, 정렬 전과 정렬 후의 결과를 출력합니다. 람다식을 사용하여 ‘Collections.sort()’ 메서드에 정렬 조건을 전달하고 있습니다.&lt;/p&gt;

&lt;p&gt;이 예시에서는 람다식을 사용하여 정렬 기준을 유연하게 변경할 수 있습니다. 가격에 따라 오름차순 정렬을 하고 있지만, 람다식을 조금 변경하여 내림차순 정렬이나 다른 정렬 조건을 적용할 수도 있습니다. 또한, 람다식을 사용하면 정렬 로직을 구현할 수 있어서 기존의 정렬 기능을 확장하거나 다른 객체나 데이터 유형에 대해서도 적용할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;정렬 전&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;Product{name=&apos;Apple&apos;, price=1000}&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;Product{name=&apos;Banana&apos;, price=500}&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;Product{name=&apos;Orange&apos;, price=1500}&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;Product{name=&apos;Grape&apos;, price=2000}&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;가격 오름차순 정렬 후&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;Product{name=&apos;Banana&apos;, price=500}&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;Product{name=&apos;Apple&apos;, price=1000}&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;Product{name=&apos;Orange&apos;, price=1500}&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;Product{name=&apos;Grape&apos;, price=2000}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>jjaemin0224</name>
        
        
      </author>

      

      
        <category term="java" />
      

      
        <summary type="html">1. 람다 (Lambda) 자바에서 람다식은 함수형 프로그래밍 스타일을 지원하기 위해 JDK 8부터 도입된 기능입니다. 람다식은 익명 함수(Anonymous Function)를 간결하게 표현하는 방법입니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">[자바] 접근 지정자와 키워드</title>
      <link href="https://jjaemin0224.github.io/accessmodifiers-keyword" rel="alternate" type="text/html" title="[자바] 접근 지정자와 키워드" />
      <published>2023-03-15T12:30:00+09:00</published>
      <updated>2023-03-15T12:30:00+09:00</updated>
      <id>https://jjaemin0224.github.io/accessmodifiers%20keyword</id>
      <content type="html" xml:base="https://jjaemin0224.github.io/accessmodifiers-keyword">&lt;hr /&gt;
&lt;h2 id=&quot;1-접근-지정자-access-modifiers&quot;&gt;1. 접근 지정자 (Access Modifiers)&lt;/h2&gt;
&lt;p&gt;접근 지정자(Access Modifiers)는 클래스의 멤버(변수, 메서드, 생성자)에 대한 접근 권한을 제어하는 키워드입니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;private&lt;/strong&gt; &lt;br /&gt;
 ‘private’으로 지정된 멤버는 동일한 클래스 내에서만 접근할 수 있습니다. 즉, 해당 멤버는 외부 클래스나 다른 패키지의 클래스에서 직접 접근할 수 없습니다. ‘private’ 접근 지정자는 정보 은닉(Encapsulation)을 위해 사용되며, 외부로부터의 직접 접근을 제한하여 데이터의 무결성과 보안을 유지하는 데 도움을 줍니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;public&lt;/strong&gt; &lt;br /&gt;
 ‘public’으로 지정된 멤버는 어떤 클래스에서든 접근할 수 있습니다. 다른 클래스나 패키지에서도 직접 접근이 가능합니다. ‘public’ 접근 지정자는 멤버의 외부로의 공개적인 접근을 제공하며, 다른 클래스들과의 상호작용을 위해 사용합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;protected’&lt;/strong&gt; &lt;br /&gt;
 ‘protected’로 지정된 멤버는 동일한 패키지 내의 클래스와 상속 관계에 있는 하위 클래스에서 접근할 수 있습니다. 즉, 패키지가 다른 다른 클래스나 하위 클래스가 아닌 경우 직접 접근할 수 없습니다. ‘protected’ 접근 지정자는 상속 관계에서 멤버의 상속과 재사용을 지원하는 데 사용됩니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;default(생략 가능)&lt;/strong&gt; &lt;br /&gt;
 접근 지정자를 명시적으로 지정하지 않은 경우, 해당 멤버는 동일한 패키지 내의 클래스에서만 접근할 수 있습니다. 다른 패키지의 클래스에서는 직접 접근할 수 없습니다. 이는 패키지 내에서의 모듈화와 캡슐화를 위해 사용됩니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;접근 지정자를 적절하게 사용하여 클래스의 멤버에 대한 접근을 제어함으로써, 코드의 유연성과 가독성을 높일 수 있습니다. 또한 정보 은닉, 캡슐화, 상속 등의 개념을 구현할 수 있어 객체지향 프로그래밍의 원칙을 준수하는 데 도움을 줍니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;2-키워드&quot;&gt;2. 키워드&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;static&lt;/strong&gt; &lt;br /&gt;
 해당 멤버(변수 또는 메서드)가 클래스 수준의 멤버임을 나타냅니다. 클래스의 인스턴스가 생성되지 않아도 사용할 수 있습니다. 클래스 변수와 클래스 메서드에 ‘static’ 키워드를 사용할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;final&lt;/strong&gt; &lt;br /&gt;
 해당 멤버(변수, 메서드, 클래스)가 최종적인 값을 가지거나, 변경할 수 없음을 나타냅니다. ‘final’ 변수는 상수로 취급되며, ‘final’메서드는 하위 클래스에서 오버라이딩할 수 없습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;abstract&lt;/strong&gt; &lt;br /&gt;
 해당 클래스나 메서드가 추상적인 성격을 가지고 있음을 나타냅니다. 추상 클래스는 객체를 직접 생성할 수 없으며, 추상 메서드는 구현이 없는 메서드로 하위 클래스에서 반드시 구현해야 합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;interface&lt;/strong&gt; &lt;br /&gt;
 ‘interface’키워드는 인터페이스를 정의할 때 사용됩니다. 인터페이스는 추상메서드와 상수 필드만을 가지며, 클래스가 여러 인터페이스를 구현할 수 있도록 합니다. 인터페이스는 다형성을 지원하고, 클래스 간의 계약을 정의하는 역할을 합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;synchronized&lt;/strong&gt; &lt;br /&gt;
 멀티쓰레드 환경에서 동기화를 위해 사용되는 키워드입니다. ‘synchronized’키워드가 붙은 블록이나 메서드는 한 번에 한 쓰레드만이 접근할 수 있도록 제어합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;volatile&lt;/strong&gt; &lt;br /&gt;
 멀티쓰레드 환경에서 변수의 가시성과 순서를 보장하기 위해 사용되는 키워드입니다. ‘volatile’변수는 항상 주 메모리에서 읽고 쓰여집니다.&lt;/li&gt;
&lt;/ol&gt;</content>

      
      
      
      
      

      <author>
          <name>jjaemin0224</name>
        
        
      </author>

      

      
        <category term="java" />
      

      
        <summary type="html">1. 접근 지정자 (Access Modifiers) 접근 지정자(Access Modifiers)는 클래스의 멤버(변수, 메서드, 생성자)에 대한 접근 권한을 제어하는 키워드입니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">[자바] Thread(쓰레드)</title>
      <link href="https://jjaemin0224.github.io/thread" rel="alternate" type="text/html" title="[자바] Thread(쓰레드)" />
      <published>2023-03-15T12:30:00+09:00</published>
      <updated>2023-03-15T12:30:00+09:00</updated>
      <id>https://jjaemin0224.github.io/thread</id>
      <content type="html" xml:base="https://jjaemin0224.github.io/thread">&lt;hr /&gt;
&lt;h2 id=&quot;1-thread&quot;&gt;1. Thread&lt;/h2&gt;
&lt;p&gt;쓰레드(Thread)는 프로세스 내에서 실행되는 독립적인 실행 단위로, 프로그램의 흐름을 제어하는 기본적인 개념입니다. 즉, 쓰레드는 프로세스 안에서 작업을 수행하는 단위로서, 하나의 프로세스에느 여러 개의 쓰레드가 동시에 실행될 수 있습니다.&lt;/p&gt;

&lt;p&gt;쓰레드는 프로세스의 자원을 공유하면서 각각 독립적인 실행 경로를 가지며, 동시에 여러 작업을 수행할 수 있습니다. 이는 병렬 처리와 동시성을 구현하는 데에 유용하며, 작업의 응답성을 향상시키고 자원을 효율적으로 활용할 수 있게 합니다.&lt;/p&gt;

&lt;p&gt;자바에서는 쓰레드를 생성하고 제어하기 위해 ‘java.lang.Thread’ 클래스를 사용합니다. ‘Thread’클래스는 쓰레드를 생성하고 실행하기 위한 다양한 메서드와 기능을 제공합니다. 일반적으로 쓰레드를 사용하기 위해서는 ‘Thread’클래스를 상속받아 새로운 클래스를 작성하고, ‘run()’메서드를 오버라이딩하며 원하는 작업을 정의합니다. 그리고 ‘start()’ 메서드를 호출하여 쓰레드를 시작합니다.&lt;/p&gt;

&lt;p&gt;쓰레드의 실행은 JVM(Java Virtual Machine)에 의해 스케줄되며, 쓰레드 스케줄링 알고리즘에 따라 실행 순서가 결정됩니다. 각각의 쓰레드는 독립적으로 실행되기 때문에 서로 다른 실행 경로를 가지고 작업을 수행합니다. 이러한 특성으로 인해 쓰레드는 동시성 프로그래밍에서 중요한 역할을 수행하며, 병렬 처리와 이벤트 처리 등에 널리 사용됩니다.&lt;/p&gt;

&lt;p&gt;쓰레드는 복잡한 작업의 분할과 동시 실행, 작업의 우선순위 설정, 동기화와 잠금, 쓰레드 간의 통신 등 다양한 기능을 제공합니다. 그러나 쓰레드를 사용할 때에는 공유 자원의 동기화, 교착 상태(deadlock) 및 경쟁 조건(race condition) 등에 주의해야 합니다. 안전하고 효율적인 쓰레드 프로그래밍을 위해서는 동기화 기법과 쓰레든 간의 상호작용에 대한 이해가 필요합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/java/thread1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;2-thread를-고려하지-않았을-때-문제점&quot;&gt;2. Thread를 고려하지 않았을 때 문제점&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;경쟁 상태&lt;/strong&gt;(Race Condition) &lt;br /&gt;
 여러 개의 쓰레드가 동시에 공유 자원에 접근하고 수정하는 경우, 예측할 수 없는 결과가 발생할 수 있습니다. 예를 들어, 두 개의 쓰레드가 동시에 동일한 변수를 증가시킨다면, 예상치 못한 값을 얻을 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;교착 상태&lt;/strong&gt;(Deadlock) &lt;br /&gt;
 여러 개의 쓰레드가 서로가 가지고 있는 자원을 기다리면서 무한히 대기하는 상태입니다. 이는 프로그램이 멈추게 되며, 데드락 상태를 해결하기 위해서는 적적한 동기화 기법과 교착 상태를 예방하는 방법을 사용해야 합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;쓰레드 안정성 문제&lt;/strong&gt;(Thread Safety) &lt;br /&gt;
 여러 개의 쓰레드가 동시에 공유 자원을 수정하려는 경우, 쓰레드 간의 충돌이 발생하여 잘못된 결과가 발생할 수 있습니다. 이를 해결하기 위해서는 쓰레드 간의 동기화를 통해 접근을 조절하고, 임계 구역(Cretical Section)에 대한 동기화를 구현해야 합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;성능 저하&lt;/strong&gt; &lt;br /&gt;
 쓰레드를 너무 많이 생성하거나 관리하지 않을 경우, 쓰레드 간의 컨텍스트 스위칭 비용이 증가하여 성능 저하가 발생할 수 있습니다. 또한, 적절한 쓰레드 풀 관리가 이루어지지 않으면 쓰레드 생성 및 소멸에 따른 오버헤드가 발생하여 성능이 저하될 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;안정성 문제&lt;/strong&gt; &lt;br /&gt;
 쓰레드를 올바르게 사용하지 않으면, 예외 처리가 제대로 이루어지지 않을 수 있고, 메모리 누수 등의 문제가 발생할 수 있습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;따라서 쓰레드를 사용할 때에는 동시성과 관련된 문제들을 인식하고, 적절한 동기환 기법과 예외 처리 방법을 사용하여 안전하고 효율적인 쓰레드 프로그래밍을 해야 합니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;3-thread-장점&quot;&gt;3. Thread 장점&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;동시성(Concurrency)&lt;/strong&gt; &lt;br /&gt;
 쓰레드를 사용하면 여러 작업을 동시에 실행할 수 있습니다. 예를 들어, 여러 개의 작업을 병렬로 처리하거나, 사용자 인터페이스의 응답성을 향상시키는 등의 동시성을 구현할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;자원 공유(Resource Sharing)&lt;/strong&gt; &lt;br /&gt;
 쓰레드는 같은 프로세스 내에서 자원을 공유할 수 있습니다. 여러 쓰레드가 같은 데이터나 객체에 접근하여 작업을 수행할 수 있습니다. 이를 통해 효율적인 자원 활용과 데이터 일관성을 유지할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;응답성(Responsiveness)&lt;/strong&gt; &lt;br /&gt;
 쓰레드를 사용하면 여러 작업을 동시에 처리할 수 있으므로, 사용자에게 더 빠른 응답성을 제공할 수 있습니다. 예를 들어, 사용자 인터페이스 쓰레드와 백그라운드 작업 쓰레드를 분리하여 사용자 애플리케이션에 대한 입력에 신속하게 반응할 수 있도록 할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;병렬 처리(Parallel Procession)&lt;/strong&gt; &lt;br /&gt;
 쓰레드를 사용하면 병렬처리를 구현할 수 있습니다. 여러 쓰레드가 동시에 작업을 수행하여 전체 작업을 더 빠르게 처리할 수 있습니다. 이는 멀티코어 프로세서에서 특히 유용하며, 병렬 알고리즘 및 병렬 컴퓨팅을 활용하는 분야에서 중요합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;비동기 처리(Asynchronous Processing)&lt;/strong&gt; &lt;br /&gt;
 쓰레드를 사용하면 비동기 처리를 구현할 수 있습니다. 비동기 작업은 작업을 시작한 후 다른 작업을 수행하면서 결과를 기다리지 않고, 작업이 완료되면 결과를 처리할 수 있도록 합니다. 이를 통해 응답성을 향상시키고, 작업의 순차적인 실행에 의한 대기 시간을 줄일 수 있습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;4-thread-생성&quot;&gt;4. Thread 생성&lt;/h2&gt;
&lt;p&gt;자바에서 쓰레드를 사용하기 위해서는 ‘java.lang.Thread’ 클래스를 사용해야 합니다. 쓰레드를 생성하려면 ‘Thread’ 클래스를 상속받아 새로운 클래스를 작성하거나, ‘Runnable’ 인터페이스를 구현한 클래스를 생성해야 합니다. 이후에는 다음과 같은 단계를 따라 쓰레드를 활용할 수 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;31-thread-class&quot;&gt;3.1 Thread Class&lt;/h4&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyThread&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 실행할 작업 정의&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;‘Thread’ 클래스를 상속받은 클래스를 정의하고, ‘run()’ 메서드를 오버라이딩합니다. ‘run()’ 메서드 안에는 쓰레드가 실행할 작업을 정의합니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;MyThread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myThread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;myThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;‘Mythread’ 클래스의 인스턴스를 생성하고, ‘start()’ 메서드를 호출하여 쓰레드를 시작합니다. ‘start()’ 메서드는 새로운 쓰레드를 생성하고 ‘run()’ 메서드를 실행하는 역할을 합니다.&lt;/p&gt;

&lt;p&gt;‘start()’ 메서드를 호출하면 JVM은 새로운 쓰레드를 생성하고 ‘run()’ 메서드를 실행합니다. 각 쓰레드는 독립적으로 실행되며, ‘run()’ 메서드의 코드 블록이 실행됩니다.&lt;/p&gt;

&lt;h4 id=&quot;3-2-runnable-interface&quot;&gt;3-2. Runnable Interface&lt;/h4&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyRunnable&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 실행할 작업 정의&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;‘Runnable’ 인터페이스는 ‘run()’ 메서드를 정의하고 있으며, 쓰레드의 실행 작업을 정의하는 데에 사용됩니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;MyRunnable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myRunnable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyRunnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myRunnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;‘Runnable’ 인터페이스를 구현한 클래스의 인스턴스를 생성하고, ‘Thread’ 클래스의 생성자에 전달하여 쓰레드를 생성할 수 있습니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;5-thread-execution-control실행-제어&quot;&gt;5. Thread Execution Control(실행 제어)&lt;/h2&gt;
&lt;p&gt;쓰레드의 실행을 제어하기 위해 자바에서는 ‘join()’ 메서드를 사용할 수 있습니다. ‘join()’ 메서는 호출한 쓰레드가 해당 쓰레드의 작업이 끝날 때까지 기다리도록 합니다. 두 개의 쓰레드를 생성하고, 첫 번째 쓰레드의 작업이 끝날 때 까지 두 번째 쓰레드가 기다리도록 하는 방법을 예시로 들겠습니다.&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyThread&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;MyThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printStactTrace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Main&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;MyThread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Thread 1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;MyThread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Thread 2&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;thread1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;thread1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 첫 번째 쓰레드의 작업이 끝날 때까지 가디립니다.&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;thread2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 예시에서 ‘Mythread’클래스는 주어진 이름을 가지고 일정 횟수만큼 반복하면서 실행되는 쓰레드입니다. ‘Main’클래스에서는 두 개의 ‘MyThread’객체를 생성하고 각각 실행한 후, 첫 번째 쓰레드의 작업이 끝날 때까지 ‘join()’메서드를 호출하여 두 번째 쓰레드가 기다리도록 합니다. 이를 통해 첫 번째 쓰레드의 실행을 먼저 완료한 후, 두 번째 쓰레드가 실행되도록 제어할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-mathematica highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;6-thread-synchronization동기화&quot;&gt;6. Thread Synchronization(동기화)&lt;/h2&gt;
&lt;p&gt;동기화(Synchronization)는 여러 쓰레드가 공유 자원에 접근할 때 원자적인 동작을 보장하고, 경쟁 상태와 같은 문제를 방지하기 위해 사용됩니다. 공유 변수에 접근하는 두 개의 쓰레드를 동기화하여 안전한 실행을 보장하는 방법을 예시로 들겠습니다.&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;increment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IncrementThread&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Counter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IncrementThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Counter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;increment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Main&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Counter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Counter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;nc&quot;&gt;IncrementThread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IncrementThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;IncrementThread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IncrementThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;thread1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;thread2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;thread1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;thread2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Final count: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 예시에서 ‘Counter’ 클래스는 공유 변수인 ‘count’를 갖고 있습니다. ‘increment()’ 메서드는 동기화된 메서드로 선언되어 있어 여러 쓰레드가 동시에 ‘count’값을 증가시키는 경우에도 안전하게 실행됩니다. ‘IncrementThread’ 클래스는 ‘Counter’ 객체를 받아와 ‘increment()’ 메서드를 호출하여 ‘count’값을 증가시키는 작업을 수행합니다. ‘Main’클래스에서는 두 개의 쓰레드를 생성하고 실행한 후, ‘counter’객체의 최종 ‘count’값을 출력합니다. 동기화를 통해 여러 쓰레드가 안전하게 ‘count’값을 증가시킬 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;Final count&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2000&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;7-thread-deadlock교착-상태&quot;&gt;7. Thread Deadlock(교착 상태)&lt;/h2&gt;
&lt;p&gt;Deadlock(교착 상태)는 두 개 이상의 쓰레드가 서로 상대방이 소유한 자원을 기다리며 무한히 대기하는 상태를 말합니다. 이는 다음과 같은 조건들이 동시에 성립할 때 발생합니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;상호 배제(Mutual Exclusion) : 자원은 동시에 하나의 쓰레드만이 사용할 수 있어야 합니다.&lt;/li&gt;
  &lt;li&gt;점유와 대기(Hold and Wait) : 적어도 하나의 자원을 점유한 상태에서 다른 자원을 기다리고 있어야 합니다.&lt;/li&gt;
  &lt;li&gt;비선점(No Preemption) : 쓰레드는 다른 쓰레드가 점유한 자원을 강제로 빼앗을 수 없습니다.&lt;/li&gt;
  &lt;li&gt;순환 대기(Circular Wait) : 쓰레드들 사이에 자원을 기다리는 순환 형태의 대기 관계가 존재해야 합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DeadlockExample&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 공유 자원&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resource1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resource2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 첫 번째 쓰레드&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resource1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Thread 1: Locked resource 1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

                &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printStackTrace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

                &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resource2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Thread 1: Locked resouce 2&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 두 번째 쓰레드&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resource2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Thread 2: Locked resource 2&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

                &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printStackTrace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

                &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resource1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Thread 2: Locked resource 1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 쓰레드 시작&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;thread1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;thread2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 예시에서는 두 개의 쓰레드가 서로 다른 순서로 두 개의 자원(resource1과 resource2)을 점유하려고 시도합니다. 첫 번째 쓰레드는 resource1을 점유한 후 resource2를 얻으려고 하고, 두 번째 쓰레드는 resource2를 점유한 후 resource1를 얻으려고 합니다. 이 때, 두 쓰레드 모두 상대방이 점유한 자원을 기다리기 때문에 서로가 끝나지 않고 무한히 대기하게 되어 교착 상태가 발생합니다.&lt;/p&gt;

&lt;p&gt;교착상태를 방지하기 위해 동기화 기법, 자원 할당 순서 변경, 상호 배제 제거 등의 방법을 사용할 수 있습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>jjaemin0224</name>
        
        
      </author>

      

      
        <category term="java" />
      

      
        <summary type="html">1. Thread 쓰레드(Thread)는 프로세스 내에서 실행되는 독립적인 실행 단위로, 프로그램의 흐름을 제어하는 기본적인 개념입니다. 즉, 쓰레드는 프로세스 안에서 작업을 수행하는 단위로서, 하나의 프로세스에느 여러 개의 쓰레드가 동시에 실행될 수 있습니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">[자바] Overloading 과 Overriding</title>
      <link href="https://jjaemin0224.github.io/overloading-overriding" rel="alternate" type="text/html" title="[자바] Overloading 과 Overriding" />
      <published>2023-03-12T12:30:00+09:00</published>
      <updated>2023-03-12T12:30:00+09:00</updated>
      <id>https://jjaemin0224.github.io/overloading%20overriding</id>
      <content type="html" xml:base="https://jjaemin0224.github.io/overloading-overriding">&lt;hr /&gt;
&lt;h2 id=&quot;1-overloading&quot;&gt;1. Overloading&lt;/h2&gt;
&lt;p&gt;Overloading은 동일한 이름을 가진 메서드나 생성자를 여러 개 정의하는 것을 말한다. 오버로딩은 다양한 매개변수 조합에 대해 메서드의 동작을 정의하고 유연성을 제공하는데 사용된다.&lt;/p&gt;

&lt;p&gt;오버로딩은 다음과 같은 규치을 따른다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;메서드의 이름은 동일해야 한다.&lt;/li&gt;
  &lt;li&gt;메서드의 매개변수의 개수 또는 타입이 달라야 한다.&lt;/li&gt;
  &lt;li&gt;반환 타입은 오버로딩에 영향을 주지 않는다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;예를 들어, 다음과 같이 ‘add’라는 이름을 가진 메서드를 오버로딩할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 예제에서 ‘add’ 메서드는 이름은 동일하지만 매개변수의 개수나 타입이 다른 세 가지 버전으로 오버로딩되었다. 이렇게 오버로딩된 메서드들은 다양한 상황에서 필요한 매개변수에 따라 호출될 수 있다.&lt;/p&gt;

&lt;p&gt;오버로딩은 코드의 가독성과 재사용성을 향상시키는 데 도움을 준다. 메서드의 이름을 일관적으로 사용하면서도 다양한 매개변수 조합에 대한 유연하게 대응할 수 있다. 다만, 오버로딩을 사용할 때에는 메서드의 동작이 명확하고 혼동을 일으키지 않도록 주의해야 한다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;2-overriding&quot;&gt;2. Overriding&lt;/h2&gt;
&lt;p&gt;Overriding은 자바에서 상속 관계에 있는 클래스들 간에 부모 클래스의 메서드를 자식 클래스에서 재정의하는 것을 말한다. 부모 클래스의 메서드를 자식 클래서에서 동일한 시그니처(메서드 이름, 매개변수 타입, 반환 타입)로 구현하여 덮었는 개념이다.&lt;/p&gt;

&lt;p&gt;오버라이딩을 하려면 다음 규칙을 따라야 한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;상속 관계에 있는 클래스에서만 오버라이딩이 가능하다.&lt;/li&gt;
  &lt;li&gt;오버라이딩할 메서드는 부모 클래스에서 상속되어야 한다.&lt;/li&gt;
  &lt;li&gt;오버라이딩할 메서드의 시그니처(이름, 매개변수 타입, 반환 타입)는 동일해야 한다.&lt;/li&gt;
  &lt;li&gt;접근 제어자는 부모 클래스의 메서드보다 더 좁은 범위로 변경할 수 없다. (예: 부모 클래스의 메서드가 ‘public’이면 오버라이딩된 메서드는 ‘public’ 또는 ‘protected’로 변경 가능)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;오버라이딩을 통해 자식 클래스는 부모 클래스의 동작을 재정의할 수 있다. 이를 통해 다형성(Polymorphism)의 개념을 실현하며, 상위 클래스에서 정의한 메서드를 하위 클래스에서 특화된 동작으로 변경할 수 있다.&lt;/p&gt;

&lt;p&gt;아래는 오버라이딩의 예시다.&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Animal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;makeSound&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Animal makes a sound&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Cat&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Animal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;makeSound&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Cat meows&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Dog&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Animal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;makeSound&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Dog barks&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 예시에서 ‘Animal’ 클래스의 ‘makeSound’ 메서드를 ‘Cat’과 ‘Dog’ 클래스에서 오버라이딩 하였다. 각 클래스의 ‘makeSound’ 메서드는 부모 클래스의 동작을 재정의하여 다른 동작을 수행하게 된다.&lt;/p&gt;

&lt;p&gt;오버라이딩은 상속을 통해 클래스 간에 기능을 재활용하면서 다양한 동작을 구현하는데 유용하다. 상위 클래스의 메서드를 오버라이딩할 때에는 메서드의 의도를 유지하면서 필요한 동작을 구현하는 것이 중요하다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>jjaemin0224</name>
        
        
      </author>

      

      
        <category term="java" />
      

      
        <summary type="html">1. Overloading Overloading은 동일한 이름을 가진 메서드나 생성자를 여러 개 정의하는 것을 말한다. 오버로딩은 다양한 매개변수 조합에 대해 메서드의 동작을 정의하고 유연성을 제공하는데 사용된다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">[자바] StringBuilder 와 StringBuffer</title>
      <link href="https://jjaemin0224.github.io/stringbuilder-stringbuffer" rel="alternate" type="text/html" title="[자바] StringBuilder 와 StringBuffer" />
      <published>2023-03-11T02:30:00+09:00</published>
      <updated>2023-03-11T02:30:00+09:00</updated>
      <id>https://jjaemin0224.github.io/stringbuilder%20stringbuffer</id>
      <content type="html" xml:base="https://jjaemin0224.github.io/stringbuilder-stringbuffer">&lt;hr /&gt;
&lt;h2 id=&quot;1-stringbuilder&quot;&gt;1. StringBuilder&lt;/h2&gt;
&lt;p&gt;StringBuilder는 Java에서 문자열을 동적으로 변경하기 위한 클래스다. 문자열 연결이나 변경 작업이 필요한 경우, 일반적으로 문자열 직접 변경하면 새로운 문자열을 생성해야 하기 때문에 성능상의 이슈가 발생할 수 있다. 이 때 StringBuilder를 사용하면 문자열을 효율적으로 조작할 수 있다.&lt;/p&gt;

&lt;p&gt;StringBuilder는 내부적으로 가변 크기의 문자열 버퍼를 유지하며, 문자열의 추가, 삭제, 수정 등의 작업을 수행할 수 있다. 기존 문자열에 문자열을 추가하거나, 특정 위치에서 문자를 삽입하거나, 문자열을 삭제하고 수정하는 등의 작업을 할 수 있다.&lt;/p&gt;

&lt;p&gt;일반적인 사용 방법은 다음과 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;StringBuilder 객체 생성 :
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;StringBuilder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StringBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;문자열 추가 :
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;문자열 삽입 :
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; World&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;문자열 삭제 :
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;문자열 수정 :
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;replace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hi&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;문자열 반환 :
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;StringBuilder를 사용하면 문자열을 직접 변경하면서도 새로운 문자열 객체를 생성하지 않아 메모리 사용량과 성능을 향상시킬 수 있다. 주로 문자열 연결, 반복적인 문자열 조작, 루프에서 문자열 누적 등에 활용된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;2-stringbuffer&quot;&gt;2. StringBuffer&lt;/h2&gt;
&lt;p&gt;StringBuffer는 Java에서 문자열을 동적으로 변경하기 위한 클래스다. StringBuilder와 마찬가지로 문자열 연결이나 변경 작업을 수행할 때 사용된다. StringBuffer는 StringBuilder와 유사한 기능을 제공하지만, 다른 점은 StringBuffer가 쓰레드 안전(thread-safe)하다는 것이다.&lt;/p&gt;

&lt;p&gt;StringBuffer는 여러 쓰레드에서 동시에 접근하고 변경할 수 있는 경우에 사용된다. 내부적으로 동기화된 메서드를 사용하여 여러 쓰레드 간에 데이터 일관성을 유지할 수 있도록 한다. 따라서 멀티쓰레드 환경에서 문자열 조작이 필요한 경우, StringBuilder 대신 StringBuffer를 사용하는 것이 안전하다.&lt;/p&gt;

&lt;p&gt;StringBuilder와 마찬가지로 StringBuffer를 사용하는 방법은 매우 유사하다. 일반적인 사용 방법은 다음과 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;StringBuffer 객체 생성 :
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;StringBuffer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StringBuffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;문자열 추가 :
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;문자열 삽입 :
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; World&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;문자열 삭제 :
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;문자열 수정 :
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;replace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hi&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;문자열 반환 :
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;StringBuffer는 StringBuilder와 동일한 API를 제공하므로 사용 방법은 거의 동일하다. 다만 멀티 쓰레드 환경에서 사용될 때 동기화를 지원하여 쓰레드 안전성을 보장한다. 단일 쓰레드 환경에서는 StringBuilder를 사용하는 것이 성능상 이점이 있을 수 있다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>jjaemin0224</name>
        
        
      </author>

      

      
        <category term="java" />
      

      
        <summary type="html">1. StringBuilder StringBuilder는 Java에서 문자열을 동적으로 변경하기 위한 클래스다. 문자열 연결이나 변경 작업이 필요한 경우, 일반적으로 문자열 직접 변경하면 새로운 문자열을 생성해야 하기 때문에 성능상의 이슈가 발생할 수 있다. 이 때 StringBuilder를 사용하면 문자열을 효율적으로 조작할 수 있다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">[자바] Stream</title>
      <link href="https://jjaemin0224.github.io/stream" rel="alternate" type="text/html" title="[자바] Stream" />
      <published>2023-03-10T02:30:00+09:00</published>
      <updated>2023-03-10T02:30:00+09:00</updated>
      <id>https://jjaemin0224.github.io/stream</id>
      <content type="html" xml:base="https://jjaemin0224.github.io/stream">&lt;hr /&gt;
&lt;h2 id=&quot;1-stream이란&quot;&gt;1. Stream이란&lt;/h2&gt;
&lt;p&gt;컴퓨터 과학 및 정보 기술에서 사용되는 용어로, 데이터의 연속적인 흐름이나 시퀀스를 가리킨다. 일반적으로 데이터 스트림은 네트워크 통신, 파일 입출력, 센서 데이터 등 다양한 소스에서 나온 데이터를 의미한다.&lt;/p&gt;

&lt;p&gt;스트림은 한방향으로 데이터를 전송하며, 데이터가 연속적으로 흐른다. 이러한 특성으로 인해 스트림은 대용량 데이터나 실시간 데이터 처리에 매우 유용하다. 스트림을 사용하면 데이터를 한 번에 모두 메모리에 저장하지 않고 조각조각으로 나눠서 처리할 수 있다. 이는 시스템 자원을 효율적으로 활용하고 처리 속도를 향상시킬 수 있다.&lt;/p&gt;

&lt;p&gt;예를 들어, 영상 스트리밍 서비스를 생각해보면, 사용자는 영상 데이터를 실시간으로 받아보면서 동영상을 시청할 수 있다. 이때 서버에서는 영상 데이터를 스트림으로 전송하여 사용자의 디바이스에서 조금씩 받아올 수 있다. 이렇게 데이터를 조금씩 받아오면서 스트리밍 서비스는 지연 시간을 최소화하고 고품질의 동영상을 제공할 수 있다.&lt;/p&gt;

&lt;p&gt;스트림은 다양한 프로그래밍 언어와 플랫폼에서 지원되며, 데이터 처리, 입출력 작업, 네트워크 통신 등 다양한 분야에서 활용된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;2-stream-api&quot;&gt;2. Stream API&lt;/h2&gt;
&lt;p&gt;Java 8에서 추가된 Stream은 데이터를 처리하고 조작하기 위한 새로운 개념과 API이다. Stream API는 함수형 프로그래밍의 개념과 스트림 연산을 이용하여 컬렉션, 배열, I/O 자원 등의 데이터를 효율적으로 처리할 수 있도록 지원한다.&lt;/p&gt;

&lt;p&gt;Stream은 데이터 요소들의 연속적인 흐름을 나타내며, 다양한 연산을 수행하여 데이터를 변환, 필터링, 그룹화, 정렬 등을 할 수 있다. Stream API를 사용하면 반복문을 사용하지 않고도 데이터를 처리할 수 있으며, 코드의 가독성과 유지보수성을 향상시킬 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;3-stream-api의-주요-특징&quot;&gt;3. Stream API의 주요 특징&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;스트림은 데이터 소스로부터 데이터를 읽어올 수 있다. 이 데이터 소스는 컬렉션, 배열, I/O 채널, 메소드 등 다양한 형태일 수 있다.&lt;/li&gt;
  &lt;li&gt;스트림은 중간 연산과 최종 연산으로 구성된다. 중간 연산은 데이터를 변환, 필터링, 정렬 등을 수행하며, 최종 연산은 최종 결과를 생성하거나 반환한다.&lt;/li&gt;
  &lt;li&gt;스트림은 내부 반복을 이용하여 데이터를 처리한다. 이는 개발자가 직접 반복문을 작성하지 않고도 데이터를 처리할 수 있다는 것을 의미한다.&lt;/li&gt;
  &lt;li&gt;스트림은 지연 연산을 지원한다. 중간 연산을 수행할 때에는 실제로 데이터가 처리되지 않고, 최종 연산이 호출될 때에만 데이터가 처리된다. 이는 성능 최적화에 도움을 줄 수 있다.&lt;/li&gt;
  &lt;li&gt;스트림은 병렬 처리를 지원한다. 멀티 코어 환경에서 데이터를 병렬로 처리하여 처리 속도를 향상시킬 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Java 8의 Stream API는 함수형 인터페이스, 람다 식, 메서드 참조 등의 기능과 함께 사용되어 많은 유용한 연산을 제공하며, 코드를 간결하고 효율적으로 작성할 수 있도록 도와준다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>jjaemin0224</name>
        
        
      </author>

      

      
        <category term="java" />
      

      
        <summary type="html">1. Stream이란 컴퓨터 과학 및 정보 기술에서 사용되는 용어로, 데이터의 연속적인 흐름이나 시퀀스를 가리킨다. 일반적으로 데이터 스트림은 네트워크 통신, 파일 입출력, 센서 데이터 등 다양한 소스에서 나온 데이터를 의미한다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">[자바] Lombok</title>
      <link href="https://jjaemin0224.github.io/lombok" rel="alternate" type="text/html" title="[자바] Lombok" />
      <published>2023-03-10T01:30:00+09:00</published>
      <updated>2023-03-10T01:30:00+09:00</updated>
      <id>https://jjaemin0224.github.io/lombok</id>
      <content type="html" xml:base="https://jjaemin0224.github.io/lombok">&lt;hr /&gt;
&lt;h2 id=&quot;1-lombok-이란&quot;&gt;1. Lombok 이란&lt;/h2&gt;
&lt;p&gt;롬복(Lombok)은 Java 개발자들이 일상적으로 작성해야 하는 반복적인 코드를 줄여주는 Java 라이브러리다. 롬복은 자바 어노테이션을 기반으로 동작하며, 컴파일 시점에서 소스 코드를 분석하여 자동으로 Getter, Setter, 생성자, toString 메서드 등을 생성해준다.&lt;/p&gt;

&lt;p&gt;롬복을 사용하면 일반적으로 작성해야 하는 Getter와 Setter 메서드를 어노테이션만으로 대체할 수 있다. 또한, equals(), hashCode(), toString() 메서드 등을 자동으로 생성해주어 객체의 비교나 문자열 표현을 간편하게 할 수 있다. 롬복은 이 외에도 불변 클래스 생성, 빌더 패턴 지원 등의 기능을 제공한다.&lt;/p&gt;

&lt;p&gt;롬복을 사용하면 코드의 양을 줄일 수 있으므로 개발자는 더 간결하고 가독성이 좋은 코드를 작성할 수 있다. 또한, 롬복이 자동으로 생성해주는 코드는 컴파일 단계에서 생성되기 때문에 런타임 오버헤드가 발생하지 않는다.&lt;/p&gt;

&lt;p&gt;롬복은 자바 개발 도구와 호환되며, 대부분의 인기 있는 IDE(통합 개발 환경)에서 지원한다. 롬복의 주요 어노테이션에는 ‘@Getter’, ‘@Setter’, ‘@NoArgsConstructor’, ‘@AllArgConstructor’, ‘@ToString’, ‘@EqualsAndHashCode’, ‘@Builder’ 등이 있다.&lt;/p&gt;

&lt;p&gt;롬복은 개발자의 생산성을 향상시키고 반복적인 작업을 최소화하는 데 도움을 주는 유용한 도구다.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;2-롬복lombok의-주요-어노테이션&quot;&gt;2. 롬복(Lombok)의 주요 어노테이션&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;‘@Getter’, ‘@Setter’ : 필드에 적용하여 자동으로 Getter와 Setter 메서드를 생성한다. 해당 필드의 값을 가져오거나 설정하는 메서드를 자동으로 생성해주는 역할을 한다.&lt;/li&gt;
  &lt;li&gt;‘@NoArgsConstructor’, ‘@AllArgConstructor’ : 클래스에 적용하여 매개변수가 없는 기본 생성자(‘@NoArgsConstructor’)와 모든 필드를 매개변수로 받는 생성자(‘@AllArgConstructor’)를 자동으로 생성한다.&lt;/li&gt;
  &lt;li&gt;‘@ToString’ : 클래스에 적용하여 ‘toString()’ 메서드를 자동으로 생성한다. ‘toString()’ 메서드는 객체의 문자열 표현을 반환하는데 사용되며, 주로 디버깅이나 로깅 용도로 활용된다.&lt;/li&gt;
  &lt;li&gt;‘@EqualsAndHashCode’ : 클래스에 적용하여 ‘equals()’와 ‘hashCode()’ 메서드를 자동으로 생성한다. 이 메서드들은 객체의 동등성 비교와 해시 코드 계산에 사용된다.&lt;/li&gt;
  &lt;li&gt;‘@Builder’ : 클래스나 생성자에 적용하여 빌더 패턴을 자동으로 생성한다. 빌더 패턴은 객체 생성을 유연하고 가독성 있게 만들어주는 패턴으로, 복잡한 객체를 생성할 때 사용된다.
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;</content>

      
      
      
      
      

      <author>
          <name>jjaemin0224</name>
        
        
      </author>

      

      
        <category term="java" />
      

      
        <summary type="html">1. Lombok 이란 롬복(Lombok)은 Java 개발자들이 일상적으로 작성해야 하는 반복적인 코드를 줄여주는 Java 라이브러리다. 롬복은 자바 어노테이션을 기반으로 동작하며, 컴파일 시점에서 소스 코드를 분석하여 자동으로 Getter, Setter, 생성자, toString 메서드 등을 생성해준다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">[자바] JVM</title>
      <link href="https://jjaemin0224.github.io/jvm" rel="alternate" type="text/html" title="[자바] JVM" />
      <published>2023-03-06T01:30:00+09:00</published>
      <updated>2023-03-06T01:30:00+09:00</updated>
      <id>https://jjaemin0224.github.io/jvm</id>
      <content type="html" xml:base="https://jjaemin0224.github.io/jvm">&lt;hr /&gt;
&lt;h2 id=&quot;1-jvm이란-무엇인가&quot;&gt;1. JVM이란 무엇인가&lt;/h2&gt;

&lt;p&gt;JAVA Virtual Machine(자바 가상 머신)의 약자로, 자바의 바이트 코드를 실행할 수 있는 주체이다. 자바 바이트 코드는 운영체제(OS)에 독립적이며 모든 JVM은 규격에 정의된 대로 자바 바이트 코드를 실행한다. 또한 JVM은 자바 애플리케이션을 클래스 로더를 통해 읽어 들여 자바 API와 함께 실행한다.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;2-jvm의-메모리-구조&quot;&gt;2. JVM의 메모리 구조&lt;/h2&gt;

&lt;p&gt;응용 프로그램이 실행되면, JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고 JVM은 이 메모리를 용도에 따라 여러 영역으로 나눈다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/java/JVM1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;2-1-class-loader&quot;&gt;2-1. Class Loader&lt;/h4&gt;
&lt;p&gt;java에서 소스를 작성하면 .java파일이 생성되며 이 소스를 컴파일하면 .class파일(ByteCode)이 생성된다. 이렇게 생성된 .class파일들을 엮어서 JVM이 운영체제로 할당 받은 메모리 영역인 Runtime Data Area로 적재(Loading)한다.&lt;/p&gt;
&lt;h4 id=&quot;2-2-excution-engine&quot;&gt;2-2. Excution Engine&lt;/h4&gt;
&lt;p&gt;메모리에 적재된 클래스(ByteCode)들을 기계어(BinaryCode)로 변경하여 명령어 단위로 실행하는 역할을 한다. 인터프리터(Interpreter)방식과 JIT(Just-In-Time) 컴파일러를 사용하는 두 가지 방식이 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Interpreter : 명령어를 하나씩 실행하는 대화형식 컴파일. 파이썬이 대표적인 인터프리터 언어&lt;/li&gt;
  &lt;li&gt;JIT(Just-In-Time) Compiler : 적적한 시간에 전체 바이트 코드를 네이티브 코드로 변경해서 실행하므로 성능이 인터프리터보다 속도 면에서 성능이 좋다.
    &lt;h4 id=&quot;2-3-garbage-collector&quot;&gt;2-3. Garbage Collector&lt;/h4&gt;
    &lt;p&gt;Garbage Collector(GC)는 Heap 메모리 영역에 적재된 객체들 중 참조되지 않는 객체들을 탐색(애플리케이션이 생성한 객체의 생존 여부) 후 제거하는 역할을 한다. GC가 역할을 수행하는 시간을 정확히 언제인지 알 수 없다. GC의 또 다른 특징으로는 GC가 수행되는 동안 GC를 수행하는 쓰레드가 아닌 다른 모든 쓰레드가 일시 정지된다.&lt;/p&gt;
    &lt;h4 id=&quot;2-4-runtime-data-area&quot;&gt;2-4. Runtime Data Area&lt;/h4&gt;
    &lt;p&gt;JVM의 메모리 영역으로 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역이다. 이 영역은 크게 Method Area, Heap Area, Stack Area, PC Register, Natice Method Stack으로 나눌 수 있다.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;3-runtime-data-area-영역-분류&quot;&gt;3. Runtime Data Area 영역 분류&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/java/JVM2.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/assets/images/java/JVM3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3-1-method-area-메소드-영역&quot;&gt;3-1. Method Area (메소드 영역)&lt;/h4&gt;
&lt;p&gt;클래스 멤버 변수의 이름, 데이터 타입, 접근 제어자 정보 같은 field 정보들과 메소드의 이름, return 타입, 파라미터, 접근 제어자 정보 같은 method 정보들, type 정보, Constant Pool, static 변수, final class 변수 등이 생성되는 영역&lt;/p&gt;
&lt;h4 id=&quot;3-2-stack-area-스택-영역&quot;&gt;3-2. Stack Area (스택 영역)&lt;/h4&gt;
&lt;p&gt;지역 변수, 파라미터, 리턴 값, 연산에 사용되는 임시 값, 메소드 호출 등 임시적인 데이터들이 생성되는 영역. 정적 메모리 할당이 이루어지는 장소로 Heap 영역에 동적 할당된 값에 대한 참조를 얻을 수 있다.
ex. Person P = new Person(); 에서 Person P는 Stack 영역, new Person();은 Heap 영역에 할당&lt;/p&gt;
&lt;h4 id=&quot;3-3-pc-register&quot;&gt;3-3. PC Register&lt;/h4&gt;
&lt;p&gt;쓰레드가 생성될 때마다 생성되는 영역으로 쓰레드마다 하나씩 존재한다. 현재 쓰레드가 실행되는 부분의 주소와 명령을 저장하고 있는 영역이다. 이것을 이용하여 쓰레드를 돌아가면서 수행할 수 있도록 한다.&lt;/p&gt;
&lt;h4 id=&quot;3-4-native-method-stack&quot;&gt;3-4. Native Method Stack&lt;/h4&gt;
&lt;p&gt;자바 외의 언어로 작성된 Native 코드를 위한 메모리 영역. 보통 C/C++ 등의 코드를 수행하기 위한 Stack&lt;/p&gt;
&lt;h4 id=&quot;3-5-meta-space&quot;&gt;3-5. Meta Space&lt;/h4&gt;
&lt;p&gt;애플리케이션의 클래스나 메서드 정보, 또는 static으로 정의된 멤버 변수가 저장된 영역. 이전 버전의 Permanent 영역에 해당함.&lt;/p&gt;
&lt;h4 id=&quot;3-6-code-cache&quot;&gt;3-6. Code Cache&lt;/h4&gt;
&lt;p&gt;JIT(Just-In-Time) 컴파일러가 데이터를 저장하는 영역으로, 자주 접근하는 ‘컴파일된 코드 블록’이 저장된다. 이곳에 저장된 코드는 기계어로 이미 변환된 채 Cache되어 있어서 빠르게 실행할 수 있다.&lt;/p&gt;
&lt;h4 id=&quot;3-7-shared-library&quot;&gt;3-7. Shared Library&lt;/h4&gt;
&lt;p&gt;애플리케이션에서 사용할 공유 라이브러리가 기계어로 변환된 채 저장된 영역. 해당 OS에서 프로세스당 한 번씩 로드된다.&lt;/p&gt;
&lt;h4 id=&quot;3-8-heap-area-힙-영역&quot;&gt;3-8. Heap Area (힙 영역)&lt;/h4&gt;
&lt;p&gt;new 키워드로 생성된 객체와 배열이 생성되는 영역(즉, 인스턴스 변수(Instance Variable)가 생기는 영역)이다. 메소드 영역에 로드된 클래스만 생성이 가능하고, GC가 참조되지 않는 메모리를 확인하고 제거하게 된다.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;4-heap-영역의-분류&quot;&gt;4. Heap 영역의 분류&lt;/h2&gt;

&lt;p&gt;heap 영역은 현재 4개의 영역으로 나뉘는데 GC를 더욱 효율적으로 사용하기 위함이다.
JDK 7 까지는 permanent 영역이 heap에 존재했지만 JDK 8 부터는 permanent 영역은 사라지고 일부가 “meta space” 영역으로 변경되어 native stack 영역에 포함되었다.
GC는 Minor GC와 Major GC로 나뉜다.
&lt;img src=&quot;/assets/images/java/JVM4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;4-1-minor-gc--new-영역에서-일어나는-gc&quot;&gt;4-1. Minor GC : New 영역에서 일어나는 GC&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;최초로 객체가 생성되면 Eden 영역에 생성된다.&lt;/li&gt;
  &lt;li&gt;Eden 영역에 객체가 가득 차면 첫 번째 GC가 일어난다.&lt;/li&gt;
  &lt;li&gt;survivor1 영역에 Eden 영역의 메모리를 그대로 복사하고, 해당 영역을 제외한 다른 영역의 객체를 모두 제거한다.&lt;/li&gt;
  &lt;li&gt;Eden 영역의 메모리도 가득 차고 survivor1 영역의 메모리도 가득 차게 되면, Eden 영역에 생성된 객체와 survivor1 영역에 생성된 객체 중 참조되고 있는 객체가 있는지를 검사한다.&lt;/li&gt;
  &lt;li&gt;참조되고 있는 않은 객체를 제외한 참조되고 있는 객체만 survivor2 영역에 복사한다.&lt;/li&gt;
  &lt;li&gt;survivor2 영역을 제외한 다른 영역의 객체들을 제거한다.&lt;/li&gt;
  &lt;li&gt;위의 과정 중 일정 횟수 이상 참조되고 있는 객체들을 survivor2 영역에서 Old 영역으로 이동시킨다.
    &lt;h4 id=&quot;4-2-major-gc-full-gc--old-영역에서-일어나는-gc&quot;&gt;4-2. Major GC (Full GC) : Old 영역에서 일어나는 GC&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;Old 영역에 있는 모든 객체들을 검사하며 참조되고 있는지 확인한다.&lt;/li&gt;
  &lt;li&gt;참조되지 않은 객체들을 모아 한 번에 제거한다.
(이 때 Minor GC보다 시간이 많이 걸리고 실행 중 GC를 제외한 모든 쓰레드는 중지된다.) &lt;br /&gt;
Major GC가 일어나게 되면 Old 영역에 있는 참조가 없는 객체들을 표시하고 그 해당 객체들을 모두 제거하게 된다. 그 후 Heap 영역은 빈 공간이 생기는데 이 부분을 없애기 위해 재구성을 시행한다. 이 때 메모리를 옮기는데 다른 쓰레드가 메모리를 사용해버리면 안되므로 모든 쓰레드가 정지하게 되는 것이다.&lt;/li&gt;
&lt;/ol&gt;</content>

      
      
      
      
      

      <author>
          <name>jjaemin0224</name>
        
        
      </author>

      

      
        <category term="java" />
      

      
        <summary type="html">1. JVM이란 무엇인가</summary>
      

      
      
    </entry>
  
</feed>
