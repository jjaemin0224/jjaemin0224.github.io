<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>[알고리즘] 정렬</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- Font Awesome -->
    <!-- <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"> -->

    <!-- Web Font 추가 -->
    <!-- <link rel="preconnect" href="https://fonts.gstatic.com">
	<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300&display=swap" rel="stylesheet"> -->

    <!-- syntax.css 추가 -->
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="The only limit is your mind." />
    <link rel="shortcut icon" href="https://jjaemin0224.github.io/assets/images/blog/favicon.png" type="image/png" />
    <link rel="canonical" href="https://jjaemin0224.github.io/sorting-algorithm" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="Jaemin's BLOG" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="[알고리즘] 정렬" />
    <meta property="og:description" content="1. 정렬 알고리즘 1-1. 개념 정렬 알고리즘은 주어진 데이터를 일정한 순서로 정렬하는 알고리즘입니다. 데이터를 정렬하는 이유는 데이터를 보다 효율적으로 검색하거나 다른 연산을 수행하기 위함입니다. 다양한 정렬 아고리즘이 개발되었으며, 각 알고리즘은 다양한 특징과 성능을 가지고 있습니다. 여러 정렬 알고리즘 중에서 가장 기본적인 알고리즘은 버블 정렬(Bubble Sort)이며, 이 외에도 선택 정렬(Selection Sort)," />
    <meta property="og:url" content="https://jjaemin0224.github.io/sorting-algorithm" />
    <meta property="og:image" content="https://jjaemin0224.github.io/assets/images/blog/backgroud.jpg" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta property="article:author" content="https://www.facebook.com/" />
    <meta property="article:published_time" content="2023-05-13T17:30:00+09:00" />
    <meta property="article:modified_time" content="2023-05-13T17:30:00+09:00" />
    <meta property="article:tag" content="Algorithm" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="[알고리즘] 정렬" />
    <meta name="twitter:description" content="1. 정렬 알고리즘 1-1. 개념 정렬 알고리즘은 주어진 데이터를 일정한 순서로 정렬하는 알고리즘입니다. 데이터를 정렬하는 이유는 데이터를 보다 효율적으로 검색하거나 다른 연산을 수행하기 위함입니다. 다양한 정렬 아고리즘이 개발되었으며, 각 알고리즘은 다양한 특징과 성능을 가지고 있습니다. 여러 정렬 알고리즘 중에서 가장 기본적인 알고리즘은 버블 정렬(Bubble Sort)이며, 이 외에도 선택 정렬(Selection Sort)," />
    <meta name="twitter:url" content="https://jjaemin0224.github.io/" />
    <meta name="twitter:image" content="https://jjaemin0224.github.io/assets/images/blog/backgroud.jpg" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="Jaemin's BLOG" />
    <meta name="twitter:label2" content="Filed under" />
    <meta name="twitter:data2" content="Algorithm" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="1400" />
    <meta property="og:image:height" content="933" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "Jaemin's BLOG",
        "logo": "https://jjaemin0224.github.io/"
    },
    "url": "https://jjaemin0224.github.io/sorting-algorithm",
    "image": {
        "@type": "ImageObject",
        "url": "https://jjaemin0224.github.io/assets/images/blog/backgroud.jpg",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://jjaemin0224.github.io/sorting-algorithm"
    },
    "description": "1. 정렬 알고리즘 1-1. 개념 정렬 알고리즘은 주어진 데이터를 일정한 순서로 정렬하는 알고리즘입니다. 데이터를 정렬하는 이유는 데이터를 보다 효율적으로 검색하거나 다른 연산을 수행하기 위함입니다. 다양한 정렬 아고리즘이 개발되었으며, 각 알고리즘은 다양한 특징과 성능을 가지고 있습니다. 여러 정렬 알고리즘 중에서 가장 기본적인 알고리즘은 버블 정렬(Bubble Sort)이며, 이 외에도 선택 정렬(Selection Sort),"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="[알고리즘] 정렬" href="/feed.xml" />


</head>
<body class="post-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://jjaemin0224.github.io/">Jaemin's BLOG</a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem">
        <a href="/">Home</a>
    </li>
    <li class="nav-about" role="menuitem">
        <a href="/about/">About</a>
    </li>
    <!-- <li class="nav-knowledge" role="menuitem">
        <a href="/tag/knowledge/">Knowledge</a>
    </li> -->
    <li class="nav-archive" role="menuitem">
        <a href="/archive.html">All Posts</a>
    </li>
    <li class="nav-archive" role="menuitem">
        <a href="/author_archive.html">Tag Posts</a>
    </li>
</ul>

        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  tag-algorithm post no-image">

            <header class="post-full-header">
                <section class="post-full-meta">
                    <time class="post-full-meta-date" datetime="13 May 2023">13 May 2023</time>
                    
                        <span class="date-divider">/</span>
                        
                            
                               <a href='/tag/algorithm/'>ALGORITHM</a>
                            
                        
                    
                </section>
                <h1 class="post-full-title">[알고리즘] 정렬</h1>
            </header>

            <!-- 
             
            -->

            <section class="post-full-content">
                <div class="kg-card-markdown">
                    <hr />
<h2 id="1-정렬-알고리즘">1. 정렬 알고리즘</h2>

<h4 id="1-1-개념">1-1. 개념</h4>
<p>정렬 알고리즘은 주어진 데이터를 일정한 순서로 정렬하는 알고리즘입니다. 데이터를 정렬하는 이유는 데이터를 보다 효율적으로 검색하거나 다른 연산을 수행하기 위함입니다. 다양한 정렬 아고리즘이 개발되었으며, 각 알고리즘은 다양한 특징과 성능을 가지고 있습니다.</p>

<p>여러 정렬 알고리즘 중에서 가장 기본적인 알고리즘은 버블 정렬(Bubble Sort)이며, 이 외에도 선택 정렬(Selection Sort), 삽입 정렬(Insertion Sort), 퀵 정렬(Quick Sort), 병합 정렬(Merge Sort), 힙 정렬(Heap Sort) 등이 있습니다.</p>

<h4 id="1-2-특징">1-2. 특징</h4>
<ol>
  <li>시간 복잡도(Time Complexity)
    <blockquote>
      <p>정렬 알고리즘은 입력 크기에 따라 수행 시간이 달라집니다. 일부 알고리즘은 최선, 평균, 최악의 경우에 따라 다른 시간 복잡도를 가집니다.</p>
    </blockquote>
  </li>
  <li>공간 복잡도(Space Complexity)
    <blockquote>
      <p>정렬 알고리즘은 추가적인 메모리 공간을 요구할 수도 있습니다. 일부 알고리즘은 입력 데이터를 직접 정렬하는 것이 아니라 새로운 배열이나 리스트를 생성하여 정렬할 수 있습니다.</p>
    </blockquote>
  </li>
  <li>안정성(Stability)
    <blockquote>
      <p>일부 정렬 알고리즘은 동일한 값에 대해 상대적인 순서를 보존하는 안정한 정렬을 제공합니다. 안정한 정렬 알고리즘은 중요한 데이터에서 중복된 값이 있는 경우 유용합니다.</p>
    </blockquote>
  </li>
  <li>비교 기반 정렬(Comparison-based Sorting)
    <blockquote>
      <p>대부분의 정렬 알고리즘은 데이터 간의 상대적인 크기를 비교하여 정렬합니다. 이러한 알고리즘은 데이터 비교에 기반하여 정렬을 수행하므로 비교 기반 정렬 알고리즘이라고도 합니다.</p>
    </blockquote>
  </li>
  <li>내부 정렬(Internal Sorting)
    <blockquote>
      <p>대부분의 정렬 알고리즘은 메모리 상에서 수행되는 내부 정렬 알고리즘이며, 입력 데이터를 메모리에 모두 저장하고 정렬합니다.</p>
    </blockquote>
  </li>
  <li>외부 정렬(External Sorting)
    <blockquote>
      <p>정렬해야 하는 데이터가 메모리에 모두 올라오지 않고 디스크나 파일과 같은 외부 저장 장치에 저장된 경우에 사용되는 정렬 알고리즘입니다. 외부 정렬은 데이터의 일부만을 메모리에 올리고 정렬하는 과정 반복하여 정렬을 수행합니다.</p>
    </blockquote>
  </li>
</ol>

<p>이러한 특징들을 고려하여 정렬 알고리즘은 선택하게 되며, 입력 데이터의 크기, 성능 요구 사항, 안정성의 필요 여부 등을 고려하여 적합한 알고리즘을 선택하는 것이 중요합니다.</p>

<hr />
<h2 id="2-버블-정렬bubble-sort">2. 버블 정렬(Bubble Sort)</h2>

<p>버블 정렬(Bubble Sort)은 인접한 두 원소를 비교하고, 필요한 경우 위치를 교환하여 정렬하는 알고리즘입니다. 매번 인접한 두 원소를 비교하면서 가장 큰 원소가 배열의 맨뒤로 이동하는 과정을 반복하며 정렬을 수행합니다.</p>

<ul>
  <li>동작 과정
    <blockquote>
      <ol>
        <li>배열의 첫 번째 원소부터 마지막 원소까지 반복합니다.</li>
        <li>현재 원소와 다음 원소를 비교합니다.</li>
        <li>현재 원소가 다음 원소보다 크다면 두 원소의 위치를 교환합니다.</li>
        <li>배열의 끝까지 도달하면 가장 큰 원소가 맨 뒤로 이동한 것으므로, 다음 반복에서는 맨 뒤의 원소를 제외하고 정렬 과정을 반복합니다.</li>
        <li>정렬이 완료될 때까지 위의 과정을 반복합니다.</li>
      </ol>
    </blockquote>
  </li>
</ul>

<p>버블 정렬의 시간 복잡도는 최악, 평균, 최선의 경우 모두 O(n^2)입니다. 따라서 배열의 크기가 크거나 정렬할 데이터가 많은 경우에는 성능이 좋지 않을 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bubble_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="c1"># 배열 크기만큼 반복
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="c1"># 마지막 i개의 원소는 이미 정렬되었으므로 제외
</span>        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="c1"># 현재 원소와 다음 원소를 비교하여 위치 교환
</span>            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

<span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">64</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">90</span><span class="p">]</span>
<span class="n">bubble_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"정렬 결과:"</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>
<span class="c1"># 정렬 결과: [11, 12, 22, 25, 34, 64, 90]
</span></code></pre></div></div>

<hr />
<h2 id="3-선택-정렬selection-sort">3. 선택 정렬(Selection Sort)</h2>

<p>선택 정렬(Selection Sort)은 주어진 배열에서 가장 작은(또는 가장 큰) 원소를 선택하여 정렬하는 알고리즘입니다. 배열을 순회하면서 가장 작은 원소를 찾아 배열의 첫 번째 원소와 교환한 후, 다음으로 작은 원소를 찾아 두 번째 원소와 교환하는 과정을 반복하여 정렬을 수행합니다.</p>

<ul>
  <li>동작과정
    <blockquote>
      <ol>
        <li>배열의 첫 번째 원소를 기준으로 설정합니다.</li>
        <li>나머지 원소들을 순회하면서 현재 기준 원소보다 작은(또는 큰) 값을 찾습니다.</li>
        <li>가장 작은(또는 큰) 값을 찾으면 해당 값을 현재 기준 원소와 교환합니다.</li>
        <li>다음 원소를 기준으로 설정하고 위의 과정을 반복합니다.</li>
        <li>정렬이 완료될 때까지 위의 과정을 반복합니다.</li>
      </ol>
    </blockquote>
  </li>
</ul>

<p>선택 정렬의 시간 복잡도는 최악, 평균, 최선의 경우 모드 O(n^2)입니다. 버블 정렬과 마찬가지로 성능이 좋지 않을 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">selection_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="c1"># 배열 크기만큼 반복
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="c1"># 현재 기준 원소의 인덱스를 저장
</span>        <span class="n">min_idx</span> <span class="o">=</span> <span class="n">i</span>
        <span class="c1"># 나머지 원소들을 순회하며 최솟값을 찾음
</span>        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">min_idx</span><span class="p">]:</span>
                <span class="n">min_idx</span> <span class="o">=</span> <span class="n">j</span>
        <span class="c1"># 현재 기준 원소와 최솝값을 교환
</span>        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">min_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">min_idx</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">64</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">11</span><span class="p">]</span>
<span class="n">selection_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"정렬결과: "</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>
<span class="c1"># 정렬결과: [11, 12, 22, 25, 64]
</span></code></pre></div></div>

<hr />
<h2 id="4-삽입-정렬insertion-sort">4. 삽입 정렬(Insertion Sort)</h2>

<p>삽입 정렬(Insertion Sort)은 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누고, 정렬되지 않은 부분의 원소를 정렬된 부분에 삽입하는 방식으로 정렬하는 알고리즘입니다. 배열의 첫 번째 원소는 이미 정렬되었다고 가정하고, 두 번째 원소부터 시작하여 한 번에 하나씩 정렬된 부분에 삽입하면서 정렬을 완성합니다.</p>

<ul>
  <li>동작 과정
    <blockquote>
      <ol>
        <li>배열의 첫 번째 원소는 이미 정렬되었다고 가정합니다.</li>
        <li>정렬되지 않은 부분의 첫 번째 원소를 선택합니다.</li>
        <li>선택한 원소를 정렬된 부분의 올바른 위치에 삽입합니다. 이를 위해 정렬된 부분을 순회하면서 선택한 원소보다 큰 원소를 찾아 오른쪽으로 이동시킵니다.</li>
        <li>선택한 원소를 적절한 위치에 삽입하면 정렬된 부분의 크기가 1 증가합니다.</li>
        <li>정렬되지 않은 부분의 원소가 남아있다면, 2단계부터 반복하여 정렬을 완성합니다.</li>
      </ol>
    </blockquote>
  </li>
</ul>

<p>삽입 정렬의 시간 복잡도는 최악, 평균, 최선의 경우 모두 O(n^2)입니다. 버블 정렬과 선택 정렬과 마찬가지로 성능이 좋지 않을 수 있습니다. 하지만 입력 데이터가 이미 정렬되어 있는 경우 최선의 경우에는 선형 시간(O(n))에 정렬을 완료할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">insertion_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="c1"># 배열 크기만큼 반복
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># 선택한 원소
</span>        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>     <span class="c1"># key의 왼쪽에 있는 원소부터 비교하기 위한 인덱스
</span>        <span class="c1"># key보다 큰 원소를 오른쪽으로 한 칸씩 이동
</span>        <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">key</span><span class="p">:</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="c1"># key를 올바른 위치에 삽입
</span>        <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>

<span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">64</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">11</span><span class="p">]</span>
<span class="n">insertion_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"정렬 결과:"</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>
<span class="c1"># 정렬 결과: [11, 12, 22, 25, 64]
</span></code></pre></div></div>

<hr />
<h2 id="5-셸-정렬shell-sort">5. 셸 정렬(Shell Sort)</h2>

<p>셸 정렬(Shell Sort)은 삽입 정렬을 개선한 정렬 알고리즘으로, 배열을 일정한 간격으로 나누어 부분적으로 정렬한 후, 간격을 점차 줄여가며 정렬을 반복합니다. 간격을 줄여가면서 정렬하는 과정을 여러 번 반복하면서 최종적으로 전체 배열을 정렬합니다.</p>

<ul>
  <li>동작 과정
    <blockquote>
      <ol>
        <li>정렬할 배열을 일정한 간격(gap)으로 나눕니다.</li>
        <li>각 부분 배열에 대해 삽입 정렬을 수행합니다. 간격(gap)이 1이 될 때까지 이 과정을 반복합니다.</li>
        <li>간격(gap)을 줄여가며 정렬을 반복합니다. 일반적으로 간격(gap)은 초기 배열 크기의 절반으로 시작하여 점차 반으로 줄여가는 방식을 사용합니다.</li>
        <li>간격(gap)이 1이 되면 최종적으로 전체 배열을 정렬합니다.</li>
      </ol>
    </blockquote>
  </li>
</ul>

<p>셸 정렬의 시간 복잡도는 최악의 경우 O(n^2)이지만 평균적으로는 O(n log n) 정도의 성능을 가집니다. 삽입 정렬보다는 빠르지만, 퀵 정렬이나 병합 정렬과 같은 다른 고급 정렬 알고리즘에 비해서는 성능이 상대적으로 떨어집니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">shell_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">gap</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span>  <span class="c1"># 초기 간격 설정
</span>
    <span class="k">while</span> <span class="n">gap</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">gap</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">gap</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">gap</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">temp</span><span class="p">:</span>
                <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">gap</span><span class="p">]</span>
                <span class="n">j</span> <span class="o">-=</span> <span class="n">gap</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>

        <span class="n">gap</span> <span class="o">//=</span> <span class="mi">2</span>  <span class="c1"># 간격을 줄여가며 반복
</span>
<span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">64</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">11</span><span class="p">]</span>
<span class="n">shell_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"정렬 결과:"</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>
<span class="c1"># 정렬 결과: [11, 12, 22, 25, 64]
</span></code></pre></div></div>

<hr />
<h2 id="6-병합-정렬merge-sort">6. 병합 정렬(Merge Sort)</h2>

<p>병합 정렬(Merge Sort)은 분할 정복(Divide and Conquer) 방식을 사용하여 배열을 정렬하는 알고리즘입니다. 배열을 반으로 나눈 후, 각각을 재귀적으로 정렬하고 다시 합병하는 과정을 통해 정렬을 완성합니다.</p>

<ul>
  <li>동작 과정
    <blockquote>
      <ol>
        <li>배열을 반으로 나눕니다. 이때, 배열의 길이가 1 이하면 이미 정렬된 것으로 간주합니다.</li>
        <li>나뉜 배열을 각각 재귀적으로 정렬합니다.</li>
        <li>정렬된 두 개의 배열을 합병(merge)하여 하나의 정렬된 배열로 만듭니다. 합병 과정에서는 두 배열의 첫 번째 원소를 비교하여 작은 원소를 결과 배열에 추가하고, 해당 원소가 속한 배열의 다음 원소를 비교합니다.</li>
        <li>합병이 완료되면 최종적으로 정렬된 배열이 생성됩니다.</li>
      </ol>
    </blockquote>
  </li>
</ul>

<p>병합 정렬의 시간 복잡도는 항상 O(n log n)입니다. 배열을 분할하고 합병하는 과정을 log n번 반복하고, 각 단계에서의 합병에는 최대 n개의 원소가 참여하기 때문입니다. 따라서 대부분의 경우에 효율적인 정렬 알고리즘으로 사용됩니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>

    <span class="n">mid</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">merge_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">[:</span><span class="n">mid</span><span class="p">])</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">merge_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">:])</span>

    <span class="k">return</span> <span class="n">merge</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
    <span class="n">merged</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">left_index</span><span class="p">,</span> <span class="n">right_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">left_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="n">right_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">left</span><span class="p">[</span><span class="n">left_index</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">[</span><span class="n">right_index</span><span class="p">]:</span>
            <span class="n">merged</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">left</span><span class="p">[</span><span class="n">left_index</span><span class="p">])</span>
            <span class="n">left_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">merged</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">right</span><span class="p">[</span><span class="n">right_index</span><span class="p">])</span>
            <span class="n">right_index</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># 남은 원소들을 추가
</span>    <span class="n">merged</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">left</span><span class="p">[</span><span class="n">left_index</span><span class="p">:])</span>
    <span class="n">merged</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">right</span><span class="p">[</span><span class="n">right_index</span><span class="p">:])</span>

    <span class="k">return</span> <span class="n">merged</span>

<span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">64</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">11</span><span class="p">]</span>
<span class="n">sorted_arr</span> <span class="o">=</span> <span class="n">merge_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"정렬 결과:"</span><span class="p">,</span> <span class="n">sorted_arr</span><span class="p">)</span>
<span class="c1"># 정렬 결과: [11, 12, 22, 25, 64]
</span></code></pre></div></div>

<hr />
<h2 id="7-퀵-정렬quick-sort">7. 퀵 정렬(Quick Sort)</h2>

<p>퀵 정렬(Quick Sort)은 분할 정복(Divide and Conquer) 방식을 사용하여 배열을 정렬하는 알고리즘입니다. 배열에서 피벗(pivot)을 선택하고, 피벗을 기준으로 작은 원소는 피벗의 왼쪽으로, 큰 원소는 피벗의 오른쪽으로 분할합니다. 이후 각 부분 배열에 대해 재귀적으로 퀵 정렬을 적용하여 정렬을 완성합니다.</p>

<ul>
  <li>동작 과정
    <blockquote>
      <ol>
        <li>배열에서 피벗(pivot)을 선택합니다. 피벗은 일반적으로 배열의 중간 원소를 선택하거나 랜덤하게 선택합니다.</li>
        <li>피벗을 기준으로 작은 원소는 피벗의 왼쪽으로, 큰 원소는 피벗의 오른쪽으로 분할합니다. 이 과정을 피벗을 중심으로 수행하며, 작은 원소와 큰 원소를 교환합니다.</li>
        <li>분할된 두 개의 부분 배열에 대해 재귀적으로 위의 과정을 반복합니다.</li>
        <li>분할된 부분 배열의 크기가 1 이하가 되면 재귀를 종료합니다.</li>
        <li>모든 재귀 호출이 종료되면 정렬이 완료됩니다.</li>
      </ol>
    </blockquote>
  </li>
</ul>

<p>퀵 정렬의 시간 복잡도는 평균적으로 O(n log n)이며, 최악의 경우 O(n^2)입니다. 하지만 평균적인 경우에 매우 빠른 성능을 보이며, 대부분의 실제 데이터에 대해서 효과적으로 동작합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">quick_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>

    <span class="n">pivot</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">left</span><span class="p">,</span> <span class="n">equal</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">:</span>
            <span class="n">left</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="p">:</span>
            <span class="n">right</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">equal</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">quick_sort</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="n">equal</span> <span class="o">+</span> <span class="n">quick_sort</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

<span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">64</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">11</span><span class="p">]</span>
<span class="n">sorted_arr</span> <span class="o">=</span> <span class="n">quick_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"정렬 결과:"</span><span class="p">,</span> <span class="n">sorted_arr</span><span class="p">)</span>
<span class="c1"># 정렬 결과: [11, 12, 22, 25, 64]
</span></code></pre></div></div>

<hr />
<h2 id="8-힙-정렬heap-sort">8. 힙 정렬(Heap Sort)</h2>

<p>힙 정렬(Heap Sort)은 힙 자료구조를 기반으로한 정렬 알고리즘입니다. 힙은 완전 이진 트리의 일종으로, 부모 노드의 값이 항상 자식 노드의 값보다 크거나 작은 특성을 가지고 있습니다. 힙 정렬은 주어진 배열을 최대 힙 또는 최소 힙으로 구성한 후, 힙에서 최대값(또는 최소값)을 반복적으로 꺼내어 배열에 저장하여 정렬을 수행합니다.</p>

<ul>
  <li>동작 과정
    <blockquote>
      <ol>
        <li>주어진 배열을 최대 힙 또는 최소 힙으로 구성합니다. 최대 힙을 구성하는 경우에는 부모 노드의 값이 항상 자식 노드의 값보다 크도록, 최소 힙을 구성하는 경우에는 부모 노드의 값이 항상 자식 노드의 값보다 작도록 합니다.</li>
        <li>최대 힙 또는 최소 힙에서 루트 노드의 값을 꺼내어 배열의 가장 끝에 저장합니다.</li>
        <li>힙에서 루트 노드를 제거한 후, 힙의 특성을 유지하도록 조정(Heapify)합니다.</li>
        <li>배열의 끝에 저장된 값을 제외한 나머지 요소들에 대해 2~3단계를 반복 수행합니다.</li>
        <li>모든 요소를 꺼내면 배열은 정렬된 상태가 됩니다.</li>
      </ol>
    </blockquote>
  </li>
</ul>

<p>힙 정렬의 시간 복잡도는 항상 O(n log n)입니다. 힙의 구성에 O(n)의 시간이 소요되며, 배열의 크기만큼 루트 노드를 꺼내어 정렬하는 과정을 반복하므로 O(n log n)의 시간이 소요됩니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="n">largest</span> <span class="o">=</span> <span class="n">i</span>
    <span class="n">left</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">right</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span>

    <span class="k">if</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">largest</span><span class="p">]:</span>
        <span class="n">largest</span> <span class="o">=</span> <span class="n">left</span>

    <span class="k">if</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">largest</span><span class="p">]:</span>
        <span class="n">largest</span> <span class="o">=</span> <span class="n">right</span>

    <span class="k">if</span> <span class="n">largest</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">largest</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">largest</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">largest</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">heap_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="c1"># 최대 힙 구성
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

    <span class="c1"># 힙 정렬 수행
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">64</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">11</span><span class="p">]</span>
<span class="n">heap_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"정렬 결과:"</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>
<span class="c1"># 정렬 결과: [11, 12, 22, 25, 64]
</span></code></pre></div></div>

<hr />
<h2 id="9-버킷-정렬bucket-sort">9. 버킷 정렬(Bucket Sort)</h2>

<p>버킷 정렬(Bucket Sort)은 원소들을 동일한 크기의 버킷에 할당하고, 각 버킷을 정렬하여 최종적으로 버킷들을 합치는 방식으로 정렬을 수행하는 알고리즘입니다. 주어진 입력 배열이 균등한 분포를 가지고 있을 때 효과적으로 동작합니다.</p>

<ul>
  <li>동작 과정
    <blockquote>
      <ol>
        <li>입력 배열의 최소값(min)과 최대값(max)을 찾습니다.</li>
        <li>입력 배열의 범위를 버킷의 개수로 나누어 각 버킷의 범위(delta)를 구합니다.</li>
        <li>버킷의 개수만큼 빈 버킷을 생성합니다.</li>
        <li>입력 배열의 각 원소를 해당하는 버킷에 할당합니다. 원소 값이 범위 내에 속하는 버킷에 할당됩니다.</li>
        <li>각 버킷 내부에서는 적절한 정렬 알고리즘(일반적으로 삽입 정렬)을 사용하여 원소들을 정렬합니다.</li>
        <li>정렬된 각 버킷의 원소들을 차례대로 추출하여 합치면 정렬된 배열이 완성됩니다.</li>
      </ol>
    </blockquote>
  </li>
</ul>

<p>버킷 정렬의 시간 복잡도는 입력 배열의 원소 수(n)에 대해 O(n + k), 여기서 k는 버킷의 개수입니다. 입력 배열을 한 번 순회하여 각 원소를 버킷에 할당하는 시간이 O(n)이며, 각 버킷 내부에서의 정렬에 걸리는 시간이 O(k)입니다. 이 때, 버킷의 개수 k가 작을수록(입력 배열의 분포가 균등할수록) 더 효율적인 정렬 알고리즘이 됩니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">insertion_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">key</span><span class="p">:</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>

<span class="k">def</span> <span class="nf">bucket_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>

    <span class="n">min_val</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">max_val</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">bucket_size</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c1"># 버킷의 개수 설정
</span>
    <span class="c1"># 버킷 생성
</span>    <span class="n">buckets</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bucket_size</span><span class="p">)]</span>

    <span class="c1"># 원소를 버킷에 할당
</span>    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">num</span> <span class="o">-</span> <span class="n">min_val</span><span class="p">)</span> <span class="o">//</span> <span class="p">((</span><span class="n">max_val</span> <span class="o">-</span> <span class="n">min_val</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">bucket_size</span><span class="p">)</span>
        <span class="n">buckets</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>

    <span class="c1"># 버킷 내부의 원소들 정렬
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bucket_size</span><span class="p">):</span>
        <span class="n">insertion_sort</span><span class="p">(</span><span class="n">buckets</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># 정렬된 버킷을 합쳐서 결과 배열 생성
</span>    <span class="n">sorted_arr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bucket_size</span><span class="p">):</span>
        <span class="n">sorted_arr</span> <span class="o">+=</span> <span class="n">buckets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">sorted_arr</span>

<span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">64</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">11</span><span class="p">]</span>
<span class="n">sorted_arr</span> <span class="o">=</span> <span class="n">bucket_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"정렬 결과:"</span><span class="p">,</span> <span class="n">sorted_arr</span><span class="p">)</span>
<span class="c1"># 정렬 결과: [11, 12, 22, 25, 64]
</span></code></pre></div></div>

<hr />
<h2 id="10-기수-정렬radix-sort">10. 기수 정렬(Radix Sort)</h2>

<p>기수 정렬(Radix Sort)은 비교 기반 정렬 알고리즘이 아닌 자릿수를 기준으로 원소를 정렬하는 정렬 알고리즘입니다. 입력된 원소들을 자릿수별로 비교하여 정렬하는 방식으로 동작합니다.</p>

<ul>
  <li>동작 과정
    <blockquote>
      <ol>
        <li>입력 배열의 가장 작은 자릿수부터 가장 큰 자릿수까지 반복합니다.</li>
        <li>각 자릿수에 대해 원소들을 비교하여 정렬합니다. 이때, 자릿수에 따라 원소들을 그룹화하고, 각 그룹별로 정렬을 수행합니다.</li>
        <li>가장 작은 자릿수부터 가장 큰 자릿수까지 반복하여 모든 자릿수에 대한 정렬을 완료합니다.</li>
      </ol>
    </blockquote>
  </li>
</ul>

<p>기수 정렬은 주로 비교 기반 정렬 알고리즘에 비해 안정적인 성능을 보이며, 원소들이 동일한 자릿수를 가질 때 효과적으로 동작합니다. 또한, 정렬 대상이 정수 또는 고정된 자릿수를 가진 문자열과 같이 비교 가능한 형태일 때 사용될 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">counting_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">exp</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">10</span>

    <span class="c1"># 각 자릿수별로 빈도수 계산
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">//</span> <span class="n">exp</span>
        <span class="n">count</span><span class="p">[</span><span class="n">index</span> <span class="o">%</span> <span class="mi">10</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># count 배열 업데이트
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
        <span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">count</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

    <span class="c1"># output 배열 구성
</span>    <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">//</span> <span class="n">exp</span>
        <span class="n">output</span><span class="p">[</span><span class="n">count</span><span class="p">[</span><span class="n">index</span> <span class="o">%</span> <span class="mi">10</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">count</span><span class="p">[</span><span class="n">index</span> <span class="o">%</span> <span class="mi">10</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="c1"># 원본 배열에 output 배열 복사
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">radix_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">max_val</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">exp</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">while</span> <span class="n">max_val</span> <span class="o">//</span> <span class="n">exp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">counting_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">exp</span><span class="p">)</span>
        <span class="n">exp</span> <span class="o">*=</span> <span class="mi">10</span>

    <span class="k">return</span> <span class="n">arr</span>

<span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">170</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">802</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">66</span><span class="p">]</span>
<span class="n">sorted_arr</span> <span class="o">=</span> <span class="n">radix_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"정렬 결과:"</span><span class="p">,</span> <span class="n">sorted_arr</span><span class="p">)</span>
<span class="c1"># 정렬 결과: [2, 24, 45, 66, 75, 90, 170, 802]
</span></code></pre></div></div>

                </div>
            </section>

            <!-- Email subscribe form at the bottom of the page -->
            <!--
            
                <section class="subscribe-form">
                    <h3 class="subscribe-form-title">Subscribe to Jaemin's BLOG</h3>
                    <p>Get the latest posts delivered right to your inbox</p>
                    <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  />
    <input class="location" type="hidden" name="location"  />
    <input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()" 
               id="searchtext" type="text" name="searchtext"  
               placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>

                </section>
            
            -->

            <footer class="post-full-footer">
                <!-- Everything inside the #author tags pulls data from the author -->
                <!-- #author-->
                
                    
                        <section class="author-card">
                            
                                <img class="author-profile-image" src="/assets/images/blog/jaemin.jpg" alt="jjaemin0224" />
                            
                            <section class="author-card-content">
                                <h4 class="author-card-name"><a href="/author/jjaemin0224">jjaemin0224</a></h4>
                                
                                    <p>Read <a href="/author/jjaemin0224">more posts</a> by this author.</p>
                                
                            </section>
                        </section>
                        <div class="post-full-footer-right">
                            <a class="author-card-button" href="/author/jjaemin0224">Read More</a>
                        </div>
                    
                
                <!-- /author  -->
            </footer>

            <!-- If you use Disqus comments, just uncomment this block.
            The only thing you need to change is "test-apkdzgmqhj" - which
            should be replaced with your own Disqus site-id. -->
            

        </article>

    </div>
</main>

<!-- Links to Previous/Next posts -->
<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
            
                
                
                
                
                    <article class="read-next-card"
                        
                            style="background-image: url(/assets/images/blog/backgroud.jpg)"
                        
                    >
                        <header class="read-next-card-header">
                            <small class="read-next-card-header-sitetitle">&mdash; Jaemin's BLOG &mdash;</small>
                            
                                <h3 class="read-next-card-header-title"><a href="/tag/algorithm/">Algorithm</a></h3>
                            
                        </header>
                        <div class="read-next-divider"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 14.5s2 3 5 3 5.5-2.463 5.5-5.5S21 6.5 18 6.5c-5 0-7 11-12 11C2.962 17.5.5 15.037.5 12S3 6.5 6 6.5s4.5 3.5 4.5 3.5"/></svg>
</div>
                        <div class="read-next-card-content">
                            <ul>
                                
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                    
                                        
                                        
                                            <li><a href="/bfs">[알고리즘] BFS(너비 우선 탐색)</a></li>
                                        
                                    
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                    
                                        
                                        
                                            <li><a href="/exponentiation-by-squaring">[알고리즘] Exponentiation by Squaring (지수의 분할 정복)</a></li>
                                        
                                    
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                            <li><a href="/tree-data-structure">[알고리즘] 트리</a></li>
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                            </ul>
                        </div>
                        <footer class="read-next-card-footer">
                            <a href="/tag/algorithm/">
                                
                                    See all 6 posts  →
                                
                            </a>
                        </footer>
                    </article>
                
            

            <!-- If there's a next post, display it using the same markup included from - partials/post-card.hbs -->
            
                

    <article class="post-card post-template no-image">
        
        <div class="post-card-content">
            <a class="post-card-content-link" href="/b2739">
                <header class="post-card-header">
                    
                        
                            
                                <span class="post-card-tags">Baekjoon</span>
                            
                        
                    

                    <h2 class="post-card-title">[백준] 2739번(java)</h2>
                </header>
                <section class="post-card-excerpt">
                    
                        <p>구구단

</p>
                    
                </section>
            </a>
            <footer class="post-card-meta">
                
                    
                        
                        <img class="author-profile-image" src="/assets/images/blog/jaemin.jpg" alt="jjaemin0224" />
                        
                        <span class="post-card-author">
                            <a href="/author/jjaemin0224/">jjaemin0224</a>
                        </span>
                    
                
                <span class="reading-time">
                    
                    
                      1 min read
                    
                </span>
            </footer>
        </div>
    </article>

            

            <!-- If there's a previous post, display it using the same markup included from - partials/post-card.hbs -->
            
                

    <article class="post-card post-template no-image">
        
        <div class="post-card-content">
            <a class="post-card-content-link" href="/tree-data-structure">
                <header class="post-card-header">
                    
                        
                            
                                <span class="post-card-tags">Algorithm</span>
                            
                        
                    

                    <h2 class="post-card-title">[알고리즘] 트리</h2>
                </header>
                <section class="post-card-excerpt">
                    
                        <p>
1. 트리(Tree)

</p>
                    
                </section>
            </a>
            <footer class="post-card-meta">
                
                    
                        
                        <img class="author-profile-image" src="/assets/images/blog/jaemin.jpg" alt="jjaemin0224" />
                        
                        <span class="post-card-author">
                            <a href="/author/jjaemin0224/">jjaemin0224</a>
                        </span>
                    
                
                <span class="reading-time">
                    
                    
                      5 min read
                    
                </span>
            </footer>
        </div>
    </article>

            

        </div>
    </div>
</aside>

<!-- Floating header which appears on-scroll, included from includes/floating-header.hbs -->
<div class="floating-header">
    <div class="floating-header-logo">
        <a href="https://jjaemin0224.github.io/">
            
            <span>Jaemin's BLOG</span>
        </a>
    </div>
    <span class="floating-header-divider">&mdash;</span>
    <div class="floating-header-title">[알고리즘] 정렬</div>
    <!-- <div class="floating-header-share">
        <div class="floating-header-share-label">Share this <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <path d="M7.5 15.5V4a1.5 1.5 0 1 1 3 0v4.5h2a1 1 0 0 1 1 1h2a1 1 0 0 1 1 1H18a1.5 1.5 0 0 1 1.5 1.5v3.099c0 .929-.13 1.854-.385 2.748L17.5 23.5h-9c-1.5-2-5.417-8.673-5.417-8.673a1.2 1.2 0 0 1 1.76-1.605L7.5 15.5zm6-6v2m-3-3.5v3.5m6-1v2"/>
</svg>
</div>
        <a class="floating-header-share-tw" href="https://twitter.com/share?text=%5B%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%5D+%EC%A0%95%EB%A0%AC&amp;url=https://jjaemin0224.github.io/sorting-algorithm"
            onclick="window.open(this.href, 'share-twitter', 'width=550,height=235');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"/></svg>

        </a>
        <a class="floating-header-share-fb" href="https://www.facebook.com/sharer/sharer.php?u=https://jjaemin0224.github.io/sorting-algorithm"
            onclick="window.open(this.href, 'share-facebook','width=580,height=296');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"/></svg>

        </a>
    </div> -->
    <progress class="progress" value="0">
        <div class="progress-container">
            <span class="progress-bar"></span>
        </div>
    </progress>
</div>


<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->


        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://jjaemin0224.github.io/">Jaemin's BLOG</a> &copy; 2023</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyllt/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
        <div id="subscribe" class="subscribe-overlay">
            <a class="subscribe-overlay-close" href="#"></a>
            <div class="subscribe-overlay-content">
                
                <h1 class="subscribe-overlay-title">Search to Jaemin's BLOG</h1>
                <p class="subscribe-overlay-description">게시물 제목을 검색하세요!</p>
                <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  />
    <input class="location" type="hidden" name="location"  />
    <input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()" 
               id="searchtext" type="text" name="searchtext"  
               placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>

            </div>
        </div>
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', '', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>

// NOTE: Scroll performance is poor in Safari
// - this appears to be due to the events firing much more slowly in Safari.
//   Dropping the scroll event and using only a raf loop results in smoother
//   scrolling but continuous processing even when not scrolling
$(document).ready(function () {
    // Start fitVids
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
    // End fitVids

    var progressBar = document.querySelector('progress');
    var header = document.querySelector('.floating-header');
    var title = document.querySelector('.post-full-title');

    var lastScrollY = window.scrollY;
    var lastWindowHeight = window.innerHeight;
    var lastDocumentHeight = $(document).height();
    var ticking = false;

    function onScroll() {
        lastScrollY = window.scrollY;
        requestTick();
    }

    function onResize() {
        lastWindowHeight = window.innerHeight;
        lastDocumentHeight = $(document).height();
        requestTick();
    }

    function requestTick() {
        if (!ticking) {
            requestAnimationFrame(update);
        }
        ticking = true;
    }

    function update() {
        var trigger = title.getBoundingClientRect().top + window.scrollY;
        var triggerOffset = title.offsetHeight + 35;
        var progressMax = lastDocumentHeight - lastWindowHeight;

        // show/hide floating header
        if (lastScrollY >= trigger + triggerOffset) {
            header.classList.add('floating-active');
        } else {
            header.classList.remove('floating-active');
        }

        progressBar.setAttribute('max', progressMax);
        progressBar.setAttribute('value', lastScrollY);

        ticking = false;
    }

    window.addEventListener('scroll', onScroll, {passive: true});
    window.addEventListener('resize', onResize, false);

    update();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
